<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"11.js.html":{"id":"11.js.html","title":"Source: 11.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 11.js /** This module contains classes and * [mix-ins](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/) * to compile various stages of a little language * using builder actions to represent programs as trees * and visitors to interpret, check types, and compile. * The details are discussed in [chapter 11]{@tutorial 11-trees} and [appendix D]{@tutorial d-kit}. * * A tree consists of *nodes* represented as nested `Array` objects, * each consisting of a string *tag* selecting a method of a *visitor*, * followed by zero or more nodes or other argument values. * `visit` cannot be a tag. * * A tree node can have `.lineno` and `.type` properties referring to the * source line number and the type (`bool`, `number`, or `string`) delivered * by the node. {@linkcode module:Eleven~Visit#_dump visitor._dump(node)} displays * the properties if they exist. * * The module assumes that there are `globalThis` definitions * of `puts()` for output and `prompt()` for num which are available to `eval()`. * * @module Eleven * @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; * @version 2024-08-04 */ import * as EBNF from './ebnf.js'; import * as BNF from './bnf.js'; import * as Six from './06.js'; // --- 11/01 /** Base class for tree building. Private method names start with an underscore. @class @property {module:Base~Parser} parser - access to source position. */ class Build { /** Sets the property */ constructor (parser) { this.parser = parser; } /** Tags node with source position as `.lineno` if available. */ _lineno (node) { if (this.parser.current &amp;&amp; this.parser.current.lineno) node.lineno = this.parser.current.lineno; return node; } } /** Class actions to represent an arithmetic expression as a tree using recursive descent. @mixin @see [example 6/07](../?eg=06/07) */ const Build_RD = superclass =&gt; class extends superclass { /** `list: sum [{ ',' sum }];` returns `[ 'list' sum ... ]` @memberof module:Eleven~Build_RD @instance */ list (sum, many) { return [ 'list', sum ].concat(many ? many[0].map(alt =&gt; alt[1]) : []); } /** `sum: product [{ add | subtract }];` returns tree @memberof module:Eleven~Build_RD @instance */ sum (product, many) { return (many ? many[0] : []). reduce((sum, alt) =&gt; (alt[0][1] = sum, alt[0]), product); } /** `add: '+' product;` returns `[ 'add' null product ]` @memberof module:Eleven~Build_RD @instance */ add (x, right) { return [ 'add', null, right ]; } /** `subtract: '-' product;` returns `[ 'subtract' null product ]` @memberof module:Eleven~Build_RD @instance */ subtract (x, right) { return [ 'subtract', null, right ]; } /** `product: signed [{ multiply | divide }];` returns tree @memberof module:Eleven~Build_RD @instance */ product (signed, many) { return (many ? many[0] : []). reduce((product, alt) =&gt; (alt[0][1] = product, alt[0]), signed); } /** `multiply: '*' signed;` returns `[ 'multiply' null signed ]` @memberof module:Eleven~Build_RD @instance */ multiply (x, right) { return [ 'multiply', null, right ]; } /** `divide: '/' signed;` returns `[ 'divide' null signed ]` @memberof module:Eleven~Build_RD @instance */ divide (x, right) { return [ 'divide', null, right ]; } /** `signed: [ '-' ] term;` returns `term` or `[ 'minus' term ]` @memberof module:Eleven~Build_RD @instance */ signed (minus, term) { return minus ? [ 'minus', term ] : term; } /** `term: number | name | '(' sum ')';` returns tree @memberof module:Eleven~Build_RD @instance */ term (...val) { return val.length == 1 ? val[0] : val[1] } /** `number: Number;` returns `[ 'number' number ]` @memberof module:Eleven~Build_RD @instance */ number (number) { return [ 'number', parseInt(number, 10) ]; } }; // --- 11/02 /** Class actions to represent an arithmetic expression as a tree using a precedence table. @mixin */ const Build_Number = superclass =&gt; class extends superclass { /** `expr: add | ... | '(' expr ')' | number;` returns tree @memberof module:Eleven~Build_Number @instance */ expr (...values) { return values.length &gt; 1 ? values[1] : values[0]; } /** `add: expr '+' expr;` returns `[ 'add' a b ]` @memberof module:Eleven~Build_Number @instance */ add (a, x, b) { return this._lineno([ 'add', a, b ]); } /** `subtract: expr '-' expr;` returns `[ 'subtract' a b ]` @memberof module:Eleven~Build_Number @instance */ subtract (a, x, b) { return this._lineno([ 'subtract', a, b ]); } /** `multiply: expr '*' expr;` returns `[ 'multiply' a b ]` @memberof module:Eleven~Build_Number @instance */ multiply (a, x, b) { return this._lineno([ 'multiply', a, b ]); } /** `divide: expr '/' expr;` returns `[ 'divide' a b ]` @memberof module:Eleven~Build_Number @instance */ divide (a, x, b) { return this._lineno([ 'divide', a, b ]); } /** `power: expr '**' expr;` returns `[ 'power' a b ]` @memberof module:Eleven~Build_Number @instance */ power (a, x, b) { return this._lineno([ 'power', a, b ]); } /** `minus: '-' expr;` returns `[ 'minus' b ]` @memberof module:Eleven~Build_Number @instance */ minus (x, b) { return this._lineno([ 'minus', b ]); } /** `number: Number;` returns `[ 'number' number ]` @memberof module:Eleven~Build_Number @instance */ number (number) { return this._lineno([ 'number', parseInt(number, 10) ]); } }; // --- 11/03 /** Base class with methods to validate and visit a tree. Private method names start with an underscore. @class @property {RegExp} trace - selects matching tags to trace visits. @property {number} errors - count of calls to `_error()`. */ class Visit { trace = false; // RegExp selects tags to display errors = 0; // counts calls to _error() /** Displays and counts an error message. */ _error (lno, ... s) { if (typeof lno == 'number' &amp;&amp; lno &gt; 0) lno = `line ${lno}:`; else lno = s.splice(0, 1)[0]; puts(`error ${++ this.errors}: ${lno}`, ... s); } /** Recursively checks tree tags, throws an error if there is a problem. @param {Array} node - to validate. */ _tree (node) { // recursively validates a tree if (!(node instanceof Array)) return; if (!node.length) throw 'empty node'; if (typeof node[0] != 'string') throw 'node tag is not a string'; if (!node[0].length) throw 'empty node tag'; if (node[0] == 'visit') throw \"'visit' cannot be a tag\"; if (typeof this.constructor.prototype[node[0]] != 'function') throw node[0] + ': unknown node tag'; node.slice(1).forEach(node =&gt; this._tree(node)); } /** Creates a deep display of a node. @param {Array} node - to recursively traverse. @param {number} [shallow] - limits depth if non-negative, by default unlimited. */ _dump (node, shallow = -1) { // recursively dumps a tree if (!(node instanceof Array)) switch (typeof node) { case 'boolean': case 'number': return node; case 'string': return \"'\" + node.replace(/(['\\\\\\n])/g, \"\\\\$1\") + \"'\"; default: return typeof node; } let result = '[ ' + (!shallow ? this._dump(node[0]) : node.map(item =&gt; this._dump(item, shallow - 1)).join(' ')) + ' ]'; if ('lineno' in node) result += '.' + node.lineno; if ('type' in node) result += ':' + node.type; return result; } /** Visits a (valid!) tree node, returns either `node` itself or the result of calling tag as method for an array. @param {Array} node - to visit, using the tag as a method name and the node as argument. @param {RegExp} [trace] - sets `.trace` if specified. */ visit (node, trace) { if (trace instanceof RegExp) this.trace = trace; // not a list: return it if (!(node instanceof Array)) return node; // visit let result; const show = this.trace instanceof RegExp &amp;&amp; this.trace.test(node[0]) ? this._dump(node, 0) : false; try { return result = this.constructor.prototype[node[0]].call(this, node); } finally { if (show) puts(show, 'returns', this._dump(result, 1)); } } } /** Methods to evaluate arithmetic expressions. All of these expect `Number` values and return a `Number` result. @mixin */ const Eval_Number = superclass =&gt; class extends superclass { /** `[ 'add' a b ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ add (node) { return this.visit(node[1]) + this.visit(node[2]); } /** `[ 'subtract' a b ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ subtract (node) { return this.visit(node[1]) - this.visit(node[2]); } /** `[ 'multiply' a b ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ multiply (node) { return this.visit(node[1]) * this.visit(node[2]); } /** `[ 'divide' a b ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ divide (node) { return this.visit(node[1]) / this.visit(node[2]); } /** `[ 'power' a b ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ power (node) { return this.visit(node[1]) ** this.visit(node[2]); } /** `[ 'minus' a ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ minus (node) { return - this.visit(node[1]); } /** `[ 'number' a ]`; returns `Number` @memberof module:Eleven~Eval_Number @instance */ number (node) { return this.visit(node[1]); } }; /** Class actions for top-level rules to display and visit a tree. * For the `main` rule: ** Add optional arguments with visitor classes. ** Add an optional `RegExp` argument to display the tree between visits and trace each visit. * @mixin */ const Main = (superclass, ...args) =&gt; class extends superclass { /** Create and apply all but the last visitor, check the last. @return {Array} checked last visitor, last tree, trace if any. @throws {string} error message, e.g., error count or `_tree` issue. @memberof module:Eleven~Main @instance */ _doVisits (tree, args) { let trace; // (first) trace pattern, if any const visitors = args.filter(arg =&gt; { // remove patterns if (!(arg instanceof RegExp)) return true; if (!trace) trace = arg; return false; }), tail = visitors.splice(-1, 1); // last visitor, others if (!tail.length) throw 'main: no visitors'; let caller; // each visitor is constructed with caller [tree, caller] = visitors.reduce(([tree, caller], Visitor) =&gt; { const visitor = new Visitor (caller); // create next visitor visitor._tree(tree); // validate tree tree = visitor.visit(tree, trace); // visit if (trace) { puts(visitor._dump(tree)); } // trace, if any if (visitor.errors) throw `${visitor.errors} error(s)`; return [tree, visitor]; // done; next visit if any }, [tree, this]); // first caller is the builder const lastVisitor = new tail[0](caller); // last visitor object lastVisitor._tree(tree); // validate tree return [ lastVisitor, tree, trace ]; } /** `main: tree;` return the checked last visit as a function. @throws {string} error message, e.g., error count or `_tree` issue. @memberof module:Eleven~Main @instance */ main (tree) { let [lastVisitor, lastTree, trace] = this._doVisits(tree, args); return () =&gt; lastVisitor.visit(lastTree, trace); } /** `dump: tree;` Display and return the tree. @memberof module:Eleven~Main @instance */ dump (tree) { puts(new Visit()._dump(tree)); return tree; } /** `run: funct;` Execute the function and return the result. @memberof module:Eleven~Main @instance */ run (funct) { return funct(); } }; // --- 11/04 /** Class actions to represent a list of statements as a tree. @mixin */ const Build_Stmts = superclass =&gt; class extends superclass { /** `stmts: stmt [{ ';' stmt }];` returns `stmt` or `[ 'stmts' stmt ... ]` @memberof module:Eleven~Build_Stmts @instance */ stmts (stmt, many) { return many == null ? stmt : this._lineno([ 'stmts', ...many[0].reduce( (stmts, alt) =&gt; { stmts.push(alt[1]); return stmts; }, [ stmt ]) ]); } /** `stmt: print | ...;` returns tree @memberof module:Eleven~Build_Stmts @instance */ stmt (stmt) { return stmt; } /** `print: 'print' expr [{ ',' expr }];` returns `[ 'print' expr ... ]` @memberof module:Eleven~Build_Stmts @instance */ print (x, expr, many) { return this._lineno([ 'print', ...(many ? many[0] : [ ]).reduce( (exprs, alt) =&gt; { exprs.push(alt[1]); return exprs; }, [ expr ]) ]); } /** `loop: 'while' expr 'do' stmts 'od';` returns `[ 'loop' expr stmts ]` @memberof module:Eleven~Build_Stmts @instance */ loop (w, expr, d, stmts, o) { return this._lineno([ 'loop', expr, stmts ]); } /** `select: 'if' expr 'then' stmts [ 'else' stmts ] 'fi';` returns `[ 'select' expr left right? ]` @memberof module:Eleven~Build_Stmts @instance */ select (i, expr, t, left, opt, f) { const result = this._lineno([ 'select', expr, left ]); if (opt) result.push(opt[1]); return result; } }; /** Class actions to represent names in a tree. @mixin */ const Build_Names = superclass =&gt; class extends superclass { /** `assign: Name '=' expr;` returns `[ 'assign' name expr ]` @memberof module:Eleven~Build_Names @instance */ assign (name, x, expr) { return this._lineno([ 'assign', name, expr ]); } /** `name: Name;` returns `[ 'name' name ]` @memberof module:Eleven~Build_Names @instance */ name (name) { return this._lineno([ 'name', name ]); } }; /** Class actions to represent comparisons as trees. @mixin */ const Build_Cmps = superclass =&gt; class extends superclass { /** `eq: expr '=' expr;` returns `[ 'eq' a b ]` @memberof module:Eleven~Build_Cmps @instance */ eq (a, x, b) { return this._lineno([ 'eq', a, b ]); } /** `ne: expr '&lt;&gt;' expr;` returns `[ 'ne' a b ]` @memberof module:Eleven~Build_Cmps @instance */ ne (a, x, b) { return this._lineno([ 'ne', a, b ]); } /** `gt: expr '&gt;' expr;` returns `[ 'gt' a b ]` @memberof module:Eleven~Build_Cmps @instance */ gt (a, x, b) { return this._lineno([ 'gt', a, b ]); } /** `ge: expr '&gt;=' expr;` returns `[ 'ge' a b ]` @memberof module:Eleven~Build_Cmps @instance */ ge (a, x, b) { return this._lineno([ 'ge', a, b ]); } /** `lt: expr '&lt;' expr;` returns `[ 'lt' a b ]` @memberof module:Eleven~Build_Cmps @instance */ lt (a, x, b) { return this._lineno([ 'lt', a, b ]); } /** `le: expr '&lt;=' expr;` returns `[ 'le' a b ]` @memberof module:Eleven~Build_Cmps @instance */ le (a, x, b) { return this._lineno([ 'le', a, b ]); } }; // --- 11/05 /** Methods to interpret comparisons. All of these expect `Number` values and return a `Boolean` result. @mixin */ const Eval_Cmps = superclass =&gt; class extends superclass { /** `[ 'eq' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ eq (node) { return this.visit(node[1]) == this.visit(node[2]); } /** `[ 'ne' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ ne (node) { return this.visit(node[1]) != this.visit(node[2]); } /** `[ 'gt' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ gt (node) { return this.visit(node[1]) &gt; this.visit(node[2]); } /** `[ 'ge' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ ge (node) { return this.visit(node[1]) &gt;= this.visit(node[2]); } /** `[ 'lt' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ lt (node) { return this.visit(node[1]) &lt; this.visit(node[2]); } /** `[ 'le' a b ]`; returns `Boolean`. @memberof module:Eleven~Eval_Cmps @instance */ le (node) { return this.visit(node[1]) &lt;= this.visit(node[2]); } }; /** Methods to interpret a list of statements. @mixin */ const Eval_Stmts = superclass =&gt; class extends superclass { /** `[ 'stmts' stmt ... ]` @memberof module:Eleven~Eval_Stmts @instance */ stmts (node) { node.slice(1).forEach(stmt =&gt; this.visit(stmt)); } /** `[ 'print' value ... ]` @memberof module:Eleven~Eval_Stmts @instance */ print (node) { puts(...node.slice(1).map(value =&gt; this.visit(value))); } /** `[ 'loop' cond stmt ]` @memberof module:Eleven~Eval_Stmts @instance */ loop (node) { while (this.visit(node[1])) this.visit(node[2]); } /** `[ 'select' cond then else? ]` @memberof module:Eleven~Eval_Stmts @instance */ select (node) { if (this.visit(node[1])) this.visit(node[2]); else if (node.length &gt; 3) this.visit(node[3]); } }; /** Mixin with a symbol table. Private method names start with an underscore. @property {Map} symbols - symbol table, maps names to descriptions; imported from previous visitor, if any. @mixin */ const Symbols = superclass =&gt; class extends superclass { /** Creates the `Map` for symbol descriptions or gets it from the previous processor. @name constructor @param {Object} prev - previous visitor or builder. @memberof module:Eleven~Symbols @instance */ constructor (prev, ... more) { super(prev, ... more); this.symbols = prev?.symbols ?? new Map (); } /** Returns a name's description, if necessary creates it. @param {string} name - to allocate. @returns {ord:number} description which indicates creation order, starting at 1. @memberof module:Eleven~Symbols @instance */ _alloc (name) { let symbol = this.symbols.get(name); // check if exists if (!symbol) // create with ordinal this.symbols.set(name, symbol = { ord: this.symbols.size + 1 }); return symbol; } }; /** Method to interpret names, requires {@linkcode module:Eleven~Symbols Symbols}. @mixin */ const Eval_Names = superclass =&gt; class extends superclass { /** `[ 'name' name ]` returns the stored value. @memberof module:Eleven~Eval_Names @instance */ name (node) { const symbol = this._alloc(node[1]); if (!('value' in symbol)) symbol.value = 0; return symbol.value; } /** `[ 'assign' name value ]` @memberof module:Eleven~Eval_Names @instance */ assign (node) { this._alloc(node[1]).value = this.visit(node[2]); } }; // --- 11/06 /** Class actions to represent Boolean expressions as trees. @mixin */ const Build_Bool = superclass =&gt; class extends superclass { /** `or: expr 'or' expr;` returns `[ 'or' a b ]` @memberof module:Eleven~Build_Bool @instance */ or (a, x, b) { return this._lineno([ 'or', a, b ]); } /** `and: expr 'and' expr;` returns `[ 'and' a b ]` @memberof module:Eleven~Build_Bool @instance */ and (a, x, b) { return this._lineno([ 'and', a, b ]); } /** `not: 'not' expr;` returns `[ 'not' b ]` @memberof module:Eleven~Build_Bool @instance */ not (x, b) { return this._lineno([ 'not', b ]); } /** `bool: 'true' | 'false';` returns `[ 'bool' bool ]` @memberof module:Eleven~Build_Bool @instance */ bool (bool) { return this._lineno([ 'bool', bool == 'true' ]); } }; /** Class actions to represent string expressions as trees. @mixin */ const Build_String = superclass =&gt; class extends superclass { /** `input: 'input' [ String String ];` returns `[ 'input' unescaped-string unescaped-string ]` @memberof module:Eleven~Build_String @instance */ input (i, opt) { return (opt ? opt : [ ]). reduce((r, s) =&gt; (r.push(s.slice(1, -1).replace(/\\\\(.)/g, '$1')), r), [ 'input' ]); } /** `len: 'len' expr;` returns `[ 'len' b ]` @memberof module:Eleven~Build_String @instance */ len (x, b) { return this._lineno([ 'len', b ]); } /** `string: String;` returns `[ 'string' unescaped-string ]` @memberof module:Eleven~Build_String @instance */ string (string) { return this._lineno([ 'string', string.slice(1, -1).replace(/\\\\(.)/g, '$1') ]); } }; /** Class action to represent type casts as trees. @mixin */ const Build_Cast = superclass =&gt; class extends superclass { /** `type: 'bool' | 'number' | 'string';` returns `type` @memberof module:Eleven~Build_Cast @instance */ type (type) { return type; } /** `cast: '(' type ')' expr;` returns `[ 'cast' type b ]` @memberof module:Eleven~Build_Cast @instance */ cast (l, type, r, b) { return this._lineno([ 'cast', type, b ]); } }; /** Methods to interpret Boolean expressions. @mixin */ const Eval_Bool = superclass =&gt; class extends superclass { /** `[ 'or' a b ]` returns `Boolean`. @memberof module:Eleven~Eval_Bool @instance */ or (node) { return node.slice(1).reduce((result, tree) =&gt; { if (result) return result; // short-circuit result = this.visit(tree); if (typeof result != 'boolean') this._error(node.lineno, \"'or' non-boolean\"); return result; }, false); } /** `[ 'and' a b ]` returns `Boolean`. @memberof module:Eleven~Eval_Bool @instance */ and (node) { return node.slice(1).reduce((result, tree) =&gt; { if (!result) return result; // short-circuit result = this.visit(tree); if (typeof result != 'boolean') this._error(node.lineno, \"'and' non-boolean\"); return result; }, true); } /** `[ 'not' b ]` returns `Boolean`. @memberof module:Eleven~Eval_Bool @instance */ not (node) { const result = this.visit(node[1]); if (typeof result != 'boolean') this._error(node.lineno, \"'not' non-boolean\"); return !result; } /** `[ 'bool' value ]` returns `Boolean`. @memberof module:Eleven~Eval_Bool @instance */ bool (node) { if (typeof node[1] != 'boolean') this._error(node.lineno, \"'bool' non-boolean\"); return node[1]; } }; /** Methods to interpret string expressions. @mixin */ const Eval_String = superclass =&gt; class extends superclass { /** `[ 'concat' a b ]` returns `String`. @memberof module:Eleven~Eval_String @instance */ concat (node) { const vals = node.slice(1).map(this.visit.bind(this)); if (vals.some(val =&gt; typeof val != 'string')) this._error(node.lineno, \"'concat' non-string\"); return vals[0] + vals[1]; } /** `[ 'input' prompt? default? ]` returns `String`. @memberof module:Eleven~Eval_String @instance */ input (node) { return prompt(node[1] ?? '', node[2] ?? ''); } /** `[ 'len' b ]` returns `Number`. @memberof module:Eleven~Eval_String @instance */ len (node) { const val = this.visit(node[1]); if (typeof val != 'string') this._error(node.lineno, \"'len' non-string\"); return val.length; // undefined if not string } /** `[ 'string' value ]` returns `String`. @memberof module:Eleven~Eval_String @instance */ string (node) { if (typeof node[1] != 'string') this._error(node.lineno, \"'string' non-string\"); return node[1]; } }; /** Method to interpret explicit typing. @mixin */ const Eval_Cast = superclass =&gt; class extends superclass { /** `[ 'cast' type b ]` returns type-cast value. @memberof module:Eleven~Eval_Cast @instance */ cast (node) { switch (node[1]) { case 'bool': return !! this.visit(node[2]); case 'number': return Number(this.visit(node[2])); case 'string': return String(this.visit(node[2])); default: throw node[1] + ': not expected for cast'; } } }; // --- 11/07 /** Base class for type checking. @class */ class Check extends Visit { /** Utility: accepts `[ type value ]`, sets `.type` from tag, returns node. @param {Array} node - to check. */ _literal (node) { if (!(typeof node[1]).startsWith(node[0])) this._error(node.lineno, `expected ${node[0]} literal`); node.type = node[0]; return node; } /** Utility: visits and casts `node[index]` to `type` if needed, returns node. @param {string} type - expected. @param {Array} node - parent of subtree to check. @param {number} index - of subtree in `node`. */ _toType (type, node, index) { if (this.visit(node[index]).type != type) (node[index] = [ 'cast', type, node[index] ]).type = type; return node; } /** Utility: casts all operands to type if needed, sets `.type`, returns node. @param {string} type - expected. @param {Array} node - tree to check. */ _require (type, node) { node.slice(1).forEach((_, n) =&gt; this._toType(type, node, n+1)); node.type = type; return node; } } /** Methods to check arithmetic expressions, cast to `number` if needed, return `number` node. @mixin */ const Check_Number = superclass =&gt; class extends superclass { /** `[ 'add' a b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ add (node) { return this._require('number', node); } /** `[ 'subtract' a b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ subtract (node) { return this._require('number', node); } /** `[ 'multiply' a b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ multiply (node) { return this._require('number', node); } /** `[ 'divide' a b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ divide (node) { return this._require('number', node); } /** `[ 'power' a b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ power (node) { return this._require('number', node); } /** `[ 'minus' b ]` casts to `number`. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ minus (node) { return this._require('number', node); } /** `[ 'number' value ]` expects `number` value. @param {Array} node - to check. @memberof module:Eleven~Check_Number @instance */ number (node) { return this._literal(node); } }; /** Methods to check comparisons, cast to left operand's type if needed, return `bool` node. @mixin */ const Check_Cmps = superclass =&gt; class extends superclass { /** Casts right operand to left operand's type if needed. @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ _cmp (node) { const type = this.visit(node[1]).type; this._toType(type, node, 2); node.type = 'bool'; return node; } /** `[ 'eq' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ eq (node) { return this._cmp(node); } /** `[ 'ne' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ ne (node) { return this._cmp(node); } /** `[ 'gt' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ gt (node) { return this._cmp(node); } /** `[ 'ge' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ ge (node) { return this._cmp(node); } /** `[ 'lt' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ lt (node) { return this._cmp(node); } /** `[ 'le' a b ]` @param {Array} node - to check. @memberof module:Eleven~Check_Cmps @instance */ le (node) { return this._cmp(node); } }; /** Methods to check Boolean expressions, cast to `bool` if needed, return `bool` node. @mixin */ const Check_Bool = superclass =&gt; class extends superclass { /** `[ 'or' a b ]` casts to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Bool @instance */ or (node) { return this._require('bool', node); } /** `[ 'and' a b ]` casts to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Bool @instance */ and (node) { return this._require('bool', node); } /** `[ 'not' b ]` casts to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Bool @instance */ not (node) { return this._require('bool', node); } /** `[ 'bool' value ]` expects `boolean` value. @param {Array} node - to check. @memberof module:Eleven~Check_Bool @instance */ bool (node) { return this._literal(node); } }; /** Methods to check string expressions, cast to `string` if needed; requires {@linkcode module:Eleven~Check_Number06 Check_Number06} as superclass to defer to `add`. Return `string` node. @mixin */ const Check_String = superclass =&gt; class extends superclass { /** `[ 'input' prompt? default? ]` returns `node.string`. @param {Array} node - to check. @memberof module:Eleven~Check_String @instance */ input (node) { node.type = 'string'; return node; } /** `[ 'add' a b ]` for at least one `string` casts to `string` and returns `node` as `concat.string`. @param {Array} node - to check. @memberof module:Eleven~Check_String @instance */ add (node) { const a = this.visit(node[1]), b = this.visit(node[2]); if (a.type != 'string') { if (b.type != 'string') return super.add(node); // any any this._toType('string', node, 1); // any string } else if (b.type != 'string') this._toType('string', node, 2); // string any node[0] = 'concat'; // string string node.type = 'string'; return node; } /** `[ 'len' b ]` casts to `string` and returns `node.number`. @param {Array} node - to check. @memberof module:Eleven~Check_String @instance */ len (node) { this._require('string', node); node.type = 'number'; return node; } /** `[ 'string' value ]` expects `string` value, returns `node.string`. @param {Array} node - to check. @memberof module:Eleven~Check_String @instance */ string (node) { return this._literal(node); } }; /** Method to check explicit cast, sets `.type` from cast, returns typed node. @mixin */ const Check_Cast = superclass =&gt; class extends superclass { /** `[ 'cast' type b ]` returns `node.type`. @param {Array} node - to check. @memberof module:Eleven~Check_Cast @instance */ cast (node) { this.visit(node[2]); node.type = node[1]; return node; } }; // --- 11/08 /** Class actions to represent a block with declarations and other items as a tree. @mixin */ const Build_Dcl = superclass =&gt; class extends superclass { /** `block: item [{ ';' item }]; item: dcl | stmt;` returns `[ 'block' dcl... stmt... ]` @memberof module:Eleven~Build_Dcl @instance */ block (item, many) { const items = (many ? many[0] : []).reduce( (items, alt) =&gt; { items.push(alt[1][0]); return items; }, [ item[0] ]); return this._lineno([ 'block' ].concat( items.filter(item =&gt; item[0] == 'dcl'), items.filter(item =&gt; item[0] != 'dcl'))); } /** `dcl: type Name [{ ',' Name }];` returns `[ 'dcl' type name ... ]` @memberof module:Eleven~Build_Dcl @instance */ dcl (type, name, many) { return this._lineno([ 'dcl', type, name ]. concat(many ? many[0].map(alt =&gt; alt[1]) : [])); } }; /** Methods to check typed statements, return node. @mixin */ const Check_Stmts = superclass =&gt; class extends superclass { /** `[ 'stmts' stmt ... ]` checks each `stmt`. @param {Array} node - to check. @memberof module:Eleven~Check_Stmts @instance */ stmts (node) { node.slice(1).forEach(stmt =&gt; this.visit(stmt)); return node; } /** `[ 'print' value ... ]` values cast to `string`. @param {Array} node - to check. @memberof module:Eleven~Check_Stmts @instance */ print (node) { return this._require('string', node); } /** `[ 'loop' cond stmt ]` condition cast to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Stmts @instance */ loop (node) { this.visit(node[2]); return this._toType('bool', node, 1); } /** `[ 'select' cond then else? ]` condition cast to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Stmts @instance */ select (node) { node.slice(2).forEach(node =&gt; this.visit(node)); return this._toType('bool', node, 1); } }; /** Methods to check names, return (typed) node. Requires {@linkcode module:Eleven~Symbols Symbols}. @mixin */ const Check_Names = superclass =&gt; class extends superclass { /** Returns `node.type(name)`, if undefined `node.number`. @param {Array} node - to check. @memberof module:Eleven~Check_Names @instance */ name (node) { node.type = this._type(node.lineno, node[1]); return node; } /** Utility: returns type of name, defaulted to `number`. @param {number} lineno - for error message, if any. @param {string} name - to find. @memberof module:Eleven~Check_Names @instance */ _type (lineno, name) { const symbol = this._alloc(name); if (!('type' in symbol)) { this._error(lineno, name + ': undefined'); symbol.type = 'number'; } return symbol.type; } /** `[ 'assign' name value ]` casts `value` to type of `name`. @param {Array} node - to check. @memberof module:Eleven~Check_Names @instance */ assign (node) { return this._toType(this._type(node.lineno, node[1]), node, 2); } }; /** Methods to check a list of statements and declarations, return node. @mixin */ const Check_Dcl = superclass =&gt; class extends superclass { /** `[ 'block' dcl ... other ... ]` replaces each node by the result of the visit, returns `node`. @param {Array} node - to check. @memberof module:Eleven~Check_Dcl @instance */ block (node) { node.slice(1).forEach((item, n) =&gt; node[n + 1] = this.visit(item)); return node; } /** `[ 'dcl' type Name ...]` allocates and types each `Name`, returns `node`. @memberof module:Eleven~Check_Dcl @instance */ dcl (node) { node.slice(2).forEach(name =&gt; { if (this.symbols.has(name)) this._error(node.lineno, name + ': duplicate'); this._alloc(name).type = node[1]; }); return node; } }; // --- 11/09 /** Methods to interpret a block with declarations and other items; requires {@linkcode module:Eleven~Symbols Symbols}. @mixin */ const Eval_Dcl = superclass =&gt; class extends superclass { /** `[ 'block' dcl ... other ... ]` visits all. @memberof module:Eleven~Eval_Dcl @instance */ block (node) { node.slice(1).forEach(item =&gt; this.visit(item)); } /** `[ 'dcl' type name ...]` defines as `false`, `0`, or empty strings. @memberof module:Eleven~Eval_Dcl @instance */ dcl (node) { node.slice(2).forEach(name =&gt; { if (this.symbols.has(name) &amp;&amp; 'value' in this.symbols.get(name)) this._error(node.lineno, name + ': duplicate'); switch (node[1]) { case 'bool': this._alloc(name).value = false; break; case 'number': this._alloc(name).value = 0; break; case 'string': this._alloc(name).value = ''; break; default: this._error(node.lineno, node[1] + \": not in 'dcl'\"); } }); } }; // --- 11/10 /** Class action for a top-level rule to visit a tree and return a stack machine; requires {@linkcode module:Eleven~Main} and {@linkcode module:Eleven~Code} as last visitor. @mixin */ const Compile = (superclass, ...args) =&gt; class extends superclass { /** Create and apply all visitors, return `executable`. @throws {string} error message, e.g., error count or `_tree` issue. @memberof module:Eleven~Compile @instance */ compile (tree) { const [lastVisitor, lastTree, trace] = this._doVisits(tree, args); lastVisitor.visit(lastTree, trace); if (trace) puts(lastVisitor.machine.toString()); return lastVisitor.executable; } }; /** Base class for code generation. @property {Object} Machine - stack machine generator class. @property {module:Six~Machine10} machine - stack machine to generate code for. @class @extends module:Eleven~Visit */ class Code extends Visit { /** Stack machine generator class. */ get Machine () { return this.#Machine ??= Six.Machine10; } #Machine; /** Extended stack machine instructions. */ get Instructions () { return this.#Instructions ??= superclass =&gt; superclass; } #Instructions; /** Stack machine generator. */ get machine () { return this.#machine ??= new (this.Instructions(this.Machine)) (); } #machine; /** The executable. */ get executable () { return this.machine.run(0); } /** Visits the subtrees and generates an instruction. @param {string} op - instruction name. @returns {number} end of code memory. */ _postfix (node, op) { node.slice(1).forEach(node =&gt; this.visit(node)); return this.machine.gen(op); } } /** Methods to generate code for arithmetic expressions; all return the next code address. @mixin */ const Code_Number = superclass =&gt; class extends superclass { /** `Power` instruction. */ get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a b -&gt; ... a**b` */ Power (memory) { memory.splice(-2, 2, memory.at(-2) ** memory.at(-1)); } }; } #Instructions; /** `[ 'add' a b ]` @memberof module:Eleven~Code_Number @instance */ add (node) { return this._postfix(node, 'Add'); } /** `[ 'subtract' a b ]` @memberof module:Eleven~Code_Number @instance */ subtract (node) { return this._postfix(node, 'Subtract'); } /** `[ 'multiply' a b ]` @memberof module:Eleven~Code_Number @instance */ multiply (node) { return this._postfix(node, 'Multiply'); } /** `[ 'divide' a b ]` @memberof module:Eleven~Code_Number @instance */ divide (node) { return this._postfix(node, 'Divide'); } /** `[ 'power' a b ]` @memberof module:Eleven~Code_Number @instance */ power (node) { return this._postfix(node, 'Power'); } /** `[ 'minus' a ]` @memberof module:Eleven~Code_Number @instance */ minus (node) { return this._postfix(node, 'Minus'); } /** `[ 'number' a ]` @memberof module:Eleven~Code_Number @instance */ number (node) { if (typeof node[1] != 'number') this._error(node.lineno, \"'number' non-number\"); return this.machine.gen('Push', node[1]); } }; // --- 11/11 /** Methods to generate code for comparisons; all return the next code address. Uses {@linkcode module:Six~Machine11 Machine11}. Requires {@linkcode module:Eleven~Symbols Symbols} for frame size and tracing. @mixin */ const Code_Cmps = superclass =&gt; class extends superclass { /** [Override] Use `Six.Machine11`. @memberof module:Eleven~Code_Cmps @instance */ get Machine () { return this.#Machine ??= Six.Machine11; } #Machine; /** [Override] The executable, checks for `trace` variable. @memberof module:Eleven~Code_Cmps @instance */ get executable () { const trace = this.symbols.get('trace'); return this.machine.run(this.symbols.size, 0, trace ? trace.ord - 1 : false); } /** `[ 'eq' a b ]` @memberof module:Eleven~Code_Cmps @instance */ eq (node) { return this._postfix(node, 'Eq'); } /** `[ 'ne' a b ]` @memberof module:Eleven~Code_Cmps @instance */ ne (node) { return this._postfix(node, 'Ne'); } /** `[ 'gt' a b ]` @memberof module:Eleven~Code_Cmps @instance */ gt (node) { return this._postfix(node, 'Gt'); } /** `[ 'ge' a b ]` @memberof module:Eleven~Code_Cmps @instance */ ge (node) { return this._postfix(node, 'Ge'); } /** `[ 'lt' a b ]` @memberof module:Eleven~Code_Cmps @instance */ lt (node) { return this._postfix(node, 'Lt'); } /** `[ 'le' a b ]` @memberof module:Eleven~Code_Cmps @instance */ le (node) { return this._postfix(node, 'Le'); } }; /** Methods to generate code for names; all return the next code address. Requires {@linkcode module:Eleven~Symbols Symbols}. @mixin */ const Code_Names = superclass =&gt; class extends superclass { /** `[ 'name' name ]` @memberof module:Eleven~Code_Names @instance */ name (node) { return this.machine.gen('Load', this._alloc(node[1]).ord - 1); } /** `[ 'assign' name value ]` returns next code address. @memberof module:Eleven~Code_Names @instance */ assign (node) { this.visit(node[2]); this.machine.gen('Store', this._alloc(node[1]).ord - 1); return this.machine.gen('Pop'); } }; /** Methods to generate code for statements; all return the next code address. Requires {@linkcode module:Eleven~Code_Cmps Code_Cmps}. Adds `Bnzero` to `super.Instructions`. @mixin */ const Code_Stmts = superclass =&gt; class extends superclass { /** [Override] Add `Bnzero`. @memberof module:Eleven~Code_Stmts @instance */ get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... bool -&gt; ... | pc: bool? a` */ Bnzero (a) { return memory =&gt; { if (memory.pop()) memory.pc = a; } } }; } #Instructions; /** `[ 'stmts' stmt ... ]` @memberof module:Eleven~Code_Stmts @instance */ stmts (node) { return node.slice(1).reduce((end, stmt) =&gt; this.visit(stmt), 0); } /** `[ 'print' value ... ]` @memberof module:Eleven~Code_Stmts @instance */ print (node) { node.slice(1).forEach(value =&gt; this.visit(value)); return this.machine.gen('Print', node.length - 1); } /** `[ 'loop' cond stmt ]` @memberof module:Eleven~Code_Stmts @instance */ loop (node) { const a = this.machine.code.push(null) - 1, // a: Branch b b = this.visit(node[2]); // a+1: stmt this.visit(node[1]); // b: cond this.machine.code[a] = this.machine.ins('Branch', b); // fixup return this.machine.gen('Bnzero', a + 1); // Bnzero a+1 } /** `[ 'select' cond then else? ]` @memberof module:Eleven~Code_Stmts @instance */ select (node) { const a = this.visit(node[1]); // cond this.machine.code.push(null); // a: Bzero b let b = this.visit(node[2]), end = b; // then if (node.length &gt; 3) { // b:end: this.machine.code.push(null); // Branch end end = this.visit(node[3]); // b: else // end: this.machine.code[b ++] = this.machine.ins('Branch', end); } this.machine.code[a] = this.machine.ins('Bzero', b); // fixup return end; } }; // --- 11/12 /** Methods to generate code for Boolean expressions; all return the next code address. Adds `IfTrue`, `IfFalse`, and `Not` to `super.Instructions`. @mixin */ const Code_Bool = superclass =&gt; class extends superclass { /** [Override] Add `IfTrue`, `IfFalse`, and `Not`. @memberof module:Eleven~Code_Bool @instance */ get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... bool -&gt; ... bool | pc: bool? a` */ IfTrue (a) { return memory =&gt; { if (memory.at(-1)) memory.pc = a; }; } /** `stack: ... bool -&gt; ... bool | pc: !bool? a` */ IfFalse (a) { return memory =&gt; { if (!memory.at(-1)) memory.pc = a; }; } /** `stack: ... a -&gt; ... !a` */ Not (memory) { memory.splice(-1, 1, !memory.at(-1)); } }; } #Instructions; /** `[ 'or' a b ]` @memberof module:Eleven~Code_Bool @instance */ or (node) { this.visit(node[1]); // push a const x = this.machine.code.push(null) - 1; // x: IfTrue y this.machine.gen('Pop'); // pop a const y = this.visit(node[2]); // push b // y: this.machine.code[x] = this.machine.ins('IfTrue', y); // fixup return y; } /** `[ 'and' a b ]` @memberof module:Eleven~Code_Bool @instance */ and (node) { this.visit(node[1]); // push a const x = this.machine.code.push(null) - 1; // x: IfFalse y this.machine.gen('Pop'); // pop a const y = this.visit(node[2]); // push b // y: this.machine.code[x] = this.machine.ins('IfFalse', y); // fixup return y; } /** `[ 'not' b ]` @memberof module:Eleven~Code_Bool @instance */ not (node) { return this._postfix(node, 'Not'); } /** `[ 'bool' value ]` @memberof module:Eleven~Code_Bool @instance */ bool (node) { if (typeof node[1] != 'boolean') throw `[ 'bool' ${node[1]} ]: not boolean`; return this.machine.gen('Push', node[1]); } }; /** Methods to generate code for string expressions; all return the next code address. Adds `Concat`, `Len`, and `InputString` to {@linkcode module:Six~Machine11 Machine11}. @mixin */ const Code_String = superclass =&gt; class extends superclass { /** Convert raw to literal string. Only escapes single quote, newline, backslash; see {@link module:Base~Tuple#escape}. @memberof module:Eleven~Code_String @instance */ _escape (s) { return `'${s.replace(/['\\n\\\\]/g, '\\\\$&amp;')}'`; } /** [Override] Show strings in memory. @memberof module:Eleven~Code_String @instance */ get Machine () { const escape = this._escape.bind(this); return this.#Machine ??= class extends super.Machine { /** Show strings in memory. */ get Memory () { return this.#Memory ??= class extends super.Memory { toString () { return '[ ' + this.map( v =&gt; typeof v == 'string' ? escape(v) : v ).join(' ') + ' ]'; } }; } #Memory; }; } #Machine; /** [Override] Add `InputString`, `Concat`, and `Len`. @memberof module:Eleven~Code_String @instance */ get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a b -&gt; ... a+b` */ Concat (memory) { memory.splice(-2, 2, memory.at(-2) + memory.at(-1)); } /** `stack: ... a -&gt; ... a.length` */ Len (memory) { memory.splice(-1, 1, memory.at(-1).length); } /** `stack: ... -&gt; ... val` */ InputString (prmpt, dflt) { return memory =&gt; memory.push(prompt(prmpt, dflt)); } }; } #Instructions; /** `[ 'input' prompt? default? ]` returns next code address. @memberof module:Eleven~Code_String @instance */ input (node) { return this.machine.gen('InputString', this._escape(node[1] ?? \"''\"), this._escape(node[2] ?? \"''\")); } /** `[ 'concat' a b ]` @memberof module:Eleven~Code_String @instance */ concat (node) { return this._postfix(node, 'Concat'); } /** `[ 'len' b ]` returns `number`. @memberof module:Eleven~Code_String @instance */ len (node) { return this._postfix(node, 'Len'); } /** `[ 'string' value ]` returns `string`. @memberof module:Eleven~Code_String @instance */ string (node) { if (typeof node[1] != 'string') throw `[ 'string' ${node[1]} ]: not string`; return this.machine.gen('Push', this._escape(node[1])); } }; /** Method to generate code for `cast`; returns the next code address. Adds `Cast` to {@linkcode module:Six~Machine11 Machine11}. @mixin */ const Code_Cast = superclass =&gt; class extends superclass { /** [Override] Add `Cast`. @memberof module:Eleven~Code_Cast @instance */ get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a -&gt; ... cast a` */ Cast (to, from) { let cast; switch (to + '-' + from) { case 'bool-number': cast = x =&gt; !!x; break; case 'bool-string': cast = x =&gt; /^\\s*true\\s*$/i.test(x); break; case 'number-bool': case 'number-string': cast = Number; break; case 'string-bool': case 'string-number': cast = String; break; default: throw `Cast ${to} ${from}: illegal cast`; } return memory =&gt; memory.splice(-1, 1, cast(memory.at(-1))); } }; } #Instructions; /** `[ 'cast' type b ]` @memberof module:Eleven~Code_Cast @instance */ cast (node) { this.visit(node[2]); return this.machine.gen('Cast', `'${node[1]}'`, `'${node[2].type}'`); } }; /** Methods to generate code for `block` and `dcl`; all return the next code address. Requires {@linkcode module:Eleven~Symbols Symbols}. @mixin */ const Code_Dcl = superclass =&gt; class extends superclass { /** `[ 'block' dcl ... stmt ... ]` visits all. @memberof module:Eleven~Code_Dcl @instance */ block (node) { return node.slice(1).reduce((end, node) =&gt; this.visit(node), 0); } /** `[ 'dcl' type name ...]` allocate, initializes `bool` and `string`. @memberof module:Eleven~Code_Dcl @instance */ dcl (node) { return node.slice(2).reduce((end, name) =&gt; { const addr = this._alloc(name).ord - 1; switch (node[1]) { case 'number': return this.machine.code.length; case 'bool': this.machine.gen('Push', false); break; case 'string': this.machine.gen('Push', \"''\"); break; } this.machine.gen('Store', addr); return this.machine.gen('Pop'); }, 0); } }; export { Build, Build_RD // 11/01 ,Build_Number // 11/02 ,Visit, Eval_Number, Main // 11/03 ,Build_Stmts, Build_Names, Build_Cmps // 11/04 ,Eval_Cmps, Eval_Stmts, Symbols, Eval_Names // 11/05 ,Build_String, Build_Bool, Build_Cast, Eval_String,Eval_Bool, Eval_Cast // 11/06 ,Check, Check_Number, Check_Cmps, Check_Bool, Check_String, Check_Cast // 11/07 ,Build_Dcl, Check_Stmts, Check_Names, Check_Dcl // 11/08 ,Eval_Dcl // 11/09 ,Compile, Code, Code_Number // 11/10 ,Code_Cmps, Code_Names, Code_Stmts // 11/11 ,Code_Bool, Code_String, Code_Cast, Code_Dcl // 11/12 }; × Search results Close "},"bnf.js.html":{"id":"bnf.js.html","title":"Source: bnf.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: bnf.js /** A module which extends the {@link module:Base Base module} * and supports creating scanners and SLR(1) parsers from BNF grammars. * Parsers employ the [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) * to be traced and to call actions written in JavaScript. * * The fundamental object created by this module is a {@linkcode module:BNF~Grammar Grammar} * which could be prepared from grammar rules using the syntax defined * {@link module:BNF~Grammar#bnf here}. * Grammars are written as ordered pairs and can define precedences. * * The state table is created from sets of positions in rules, * and conflicts are resolved using the lookahead and follow sets, * and precedences, if available, * i.e., it is a [simplified implementation of LR(1)](https://en.wikipedia.org/wiki/Simple_LR_parser). * The table is not optimized. * * An {@link module:EBNF~Grammar EBNF grammar}, * optionally with precedences and `$error`, * can be imported for SLR(1) parsing, * but the {@link module:BNF BNF} and {@link module:EBNF EBNF} modules * only depend on the {@link module:Base Base module} and not on each other. * * The grammar rules, precedence levels, and states * are represented using a number of classes summarized below. * {@linkcode module:BNF~Grammar#check check()} creates a state table * which controls a {@linkcode module:BNF~Parser Parser}. * A {@linkcode module:Base~Scanner Scanner} is created from the grammar's terminals. * * Objects are created using factory methods which check parameters * and maintain inventories. All factory methods are defined in {@linkcode module:BNF~Grammar Grammar} * and the factory methods for all but {@linkcode module:BNF~Message Message} have the same name as the classes * (with lower-case initials). * * All properties have getters, very few have setters, i.e., there is * no assignment outside class boundaries. | class | main properties | main methods | | ----- | --------------- | ------------ | | {@linkcode module:BNF~Grammar Grammar}: {@linkcode module:Base~Factory Factory} | `config`, `ebnf`, `sr`, `rr`, `rules`: `Array&lt;`{@linkcode module:BNF~Rule Rule}`&gt;`,&lt;br&gt;`states`: `Array&lt;`{@linkcode module:BNF~State State}`&gt;` | {@linkcode module:BNF~Grammar#check check()}, {@linkcode module:BNF~Grammar#parser parser()}, {@linkcode module:BNF~Parser#build build()}, {@linkcode module:BNF~Parser#trace trace()} | | {@linkcode module:BNF~Rule Rule} | `nt`, `symbols`: `Array&lt;`{@linkcode module:Base~Symbol Symbol}`&gt;`, `prec`, `empty`, `reached`, `finite`, `first`, `reduced` | | | {@linkcode module:BNF~NT NT}: {@linkcode module:Base~NT NT}: {@linkcode module:Base~Symbol Symbol} | `name`, `ord`, `rules`: `Array&lt;`{@linkcode module:BNF~Rule Rule}`&gt;`, `empty`, `reached`, `finite`, `first`, `follow` | | | {@linkcode module:BNF~Lit Lit}: {@linkcode module:Base~Lit Lit}: {@linkcode module:Base~T T}: {@linkcode module:Base~Symbol Symbol} | `name`, `value`, `ord`, `prec`, `used`, `first` | {@linkcode module:BNF~Lit#unescape unescape(s)} | | {@linkcode module:BNF~Token Token}: {@linkcode module:Base~Token Token}: {@linkcode module:Base~T T}: {@linkcode module:Base~Symbol Symbol} | `name`, `pat`, `ord`, `prec`, `used`, `first` | | | {@linkcode module:BNF~State State} | `marks`: `Array&lt;`{@linkcode module:BNF~Mark Mark}`&gt;`, `core`,&lt;br&gt;`messages`: `Object&lt;ord,` {@linkcode module:BNF~Message Message}`&gt;` | {@linkcode module:BNF~State#advance advance(state)}, {@linkcode module:BNF~State#equals equals(core)} | | {@linkcode module:BNF~Mark Mark} | `rule`, `position`, `complete` | {@linkcode module:BNF~Mark#advance advance()}, {@linkcode module:BNF~Mark#equals equals(mark)} | | {@linkcode module:BNF~Message Message} | `message`, `symbol`, `info` | | | {@linkcode module:BNF~Parser Parser} | `grammar`, `stack[]`, `state`: {@linkcode module:BNF~State State}, `values[]` | {@linkcode module:BNF~Parser#parse parse(input)} | @module BNF @see module:Base @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-07-25 */ import * as Base from './base.js'; /** @mixin @property {number} ord - global index; set in {@linkcode module:BNF~Grammar#check check()}. @property {Object.&lt;number, module:Base~T&gt;} first - maps `ord` to `this`. */ const T = (superclass) =&gt; class extends superclass { #ord = undefined; get ord () { return this.#ord; } set ord (value) { typeof this.#ord == 'undefined' &amp;&amp; (this.#ord = value); } #first = { }; get first () { return this.#first; } /** Displays ordinal number, if any, and description of terminal. @returns {string} @memberof module:BNF~T @instance */ dump () { return (this.ord &gt;= 0 ? this.ord : '?') + ': ' + super.dump(); } } /** Represents a literal symbol for BNF. @mixes module:BNF~T @property {number} ord - global index; set in {@linkcode module:BNF~Grammar#check check()}. @property {Object.&lt;number, module:Base~T&gt;} first - maps `ord` to `this`. @extends module:Base~Lit @property {string} name - representation for a literal. Empty string is reserved for `$eof`, the end of input. @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {string} value - (unquoted) value for the literal; empty string for `$eof`, too. @property {boolean} [screened] - set true only during scanner construction if literal value matches a token pattern. */ class Lit extends T(Base.Lit) { /** Creates a literal symbol for BNF; see factory method {@linkcode module:BNF~Grammar#lit grammar.lit()}. @param {string} [name] - a (quoted) representation for the literal. */ constructor (name) { super(name); } } /** Represents a token symbol for BNF. mixes module:BNF~T @property {number} ord - global index; set in {@linkcode module:BNF~Grammar#check check()}. @property {Object.&lt;number, module:Base~T&gt;} first - maps `ord` to `this`. @extends module:Base~Token @property {string} name - name for the token. Empty string is reserved for `$error`, can be something unexpected. @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {RegExp} pat - pattern for token; empty `RegExp` for `$error`. @property {Array&lt;Lit&gt;} [screen] - contains literals with values matching the pattern, if any. */ class Token extends T(Base.Token) { /** Creates a token symbol for BNF; see factory method {@linkcode module:BNF~Grammar#token grammar.token()}. @param {string} name - token name. @param {RegExp} pat - for a token. */ constructor (name, pat) { super(name, pat); } } /** Represents a non-terminal symbol for BNF. @property {number} index - non-terminal's index in `.nts`. @property {number} ord - non-terminal's global index; set in {@linkcode module:BNF~Grammar#check check()}. @property {module:BNF~Rule[]} rules - defining `this`. @property {boolean} empty - true if no input can be accepted. @property {boolean} reached - true if this can be reached from rule zero. @property {boolean} finite - true if there is a non-recursive expansion. @property {Object.&lt;number, module:BNF~T&gt;} first - terminals at front, maps ord to {@link module:BNF~T}. @property {Object.&lt;number, module:BNF~T&gt;} follow - terminals following, maps ord to {@link module:BNF~T}. @extends module:Base~NT @property {string} name - name for the non-terminal. Empty string is reserved for `$accept`, can be left-hand side of a start rule. */ class NT extends Base.NT { #index; get index () { return this.#index; } #ord = undefined; get ord () { return this.#ord; } set ord (value) { typeof this.#ord == 'undefined' &amp;&amp; (this.#ord = value); } #rules = []; get rules () { return this.#rules; } #empty; get empty () { return this.#empty; } set empty (_) { this.#empty = true; } // cannot unset it #reached = false; get reached () { return this.#reached; } set reached (_) { this.#reached = true; } // cannot unset it #finite = false; get finite () { return this.#finite; } set finite (_) { this.#finite = true; } // cannot unset it #first = {}; get first () { return this.#first; } #follow = {}; get follow () { return this.#follow; } /** Creates a non-terminal symbol for BNF; see factory method {@linkcode module:BNF~Grammar#nt grammar.nt()}. @param {string} name - non-terminal's name. @param {number} index - non-terminal's index in `.nts`. */ constructor (name, index) { super(name); this.#index = index; } /** Displays index or ord and name and contents of all sets. @returns {string} */ dump () { const result = [ (' ' + (this.ord ? this.ord : this.index)).substr(-3) + ': ' + this.toString() ]; if (this.empty) result.push('empty: true'); for (let set in { first:0, follow:0 }) { const r = Object.values(this[set]).map(t =&gt; t.toString()).join(' '); if (r.length) result.push(set + ': ' + r); } return result.join('\\n\\t'); } } /** Represents a BNF rule, i.e., an ordered pair. @property {module:BNF~NT} nt - rule's non-terminal (left-hand side). @property {Array&lt;module:Base~Symbol&gt;} symbols - rule's right-hand side. @property {number} index - rule's index in {@linkcode module:BNF~Grammar grammar.rules}. @property {boolean} empty - computed from `.symbols`. @property {boolean} reached - true if this can be reached from rule zero. @property {boolean} finite - true if all non-terminals in the right-hand side have {@link module:BNF~NT}`.finite` set. @property {Object.&lt;number, module:BNF~T&gt;} first - terminals at front, maps ord to {@link module:BNF~T}. @property {boolean} reduced - true if this rule has been reduced. @property {?Object} prec - precedence. @property {string} prec.assoc - associativity, `'%left'`, `'%right'` or `'%nonassoc'` if any. @property {number} prec.level - precedence level, from 0. @property {module:BNF~T} prec.t - terminal providing the precedence. */ class Rule { #nt; get nt () { return this.#nt; } #symbols; get symbols () { return this.#symbols; } #index; get index () { return this.#index; } get empty () { return !this.symbols.length; } #reached = false; get reached () { return this.#reached; } set reached (_) { this.#reached = true; } // cannot unset it #finite = false; get finite () { return this.#finite; } set finite (_) { this.#finite = true; } // cannot unset it #first = {}; get first () { return this.#first; } #reduced = false; get reduced () { return this.#reduced; } set reduced (_) { this.#reduced = true; } // cannot unset it ?? #prec; get prec () { return this.#prec; } /** Creates a BNF rule; see {@linkcode module:BNF~Grammar#rule rule()} factory method. @param {module:BNF~NT} nt - left-hand side, non-terminal. @param {module:Base~Symbol[]} symbols right-hand side. @param {number} index - rule's index in {@link module:BNF~Grammar}`.rules`. @param {?Object} [prec] - precedence, if any. */ constructor (nt, symbols, index, prec) { this.#nt = nt; this.#symbols = symbols; this.#index = index; this.#prec = prec; } /** Displays a rule in BNF notation. @param {number} [mark] - precedes a symbol on the right-hand side if it is in range. @returns {string} */ toString (mark) { let result = this.nt + ': ' + this.symbols.map((symbol, n) =&gt; (n == mark ? '● ' : '') + symbol).join(' '); if (this.symbols.length == mark) result += (this.symbols.length ? ' ●' : '●'); if (this.prec) result += ' %prec ' + this.prec.t; return result + ';'; } /** Displays index, rule, `empty`, and content of `first`. @returns {string} */ dump () { const result = [ (this.index &gt;= 0 ? (' ' + this.index).substr(-3) + ': ' : '') + this.toString() ]; if (this.empty) result.push('empty: true'); const r = Object.values(this.first).map(t =&gt; t.toString()).join(' '); if (r.length) result.push('first: ' + r); return result.join('\\n\\t'); } } /** Represents a message of the parser automaton. @property {string} verb - one of `'accept'`, `'error'`, `'goto'`, `'reduce'`, or `'shift'`. @property {module:Base~Symbol} symbol - symbol on which to message. @property {Number|module:BNF~Rule} info - additional information, if any. */ class Message { #verb; get verb () { return this.#verb; } #symbol; get symbol () { return this.#symbol; } #info; get info () { return this.#info; } set info (info) { this.#info = info; } /** Creates a new message; see factory methods {@linkcode module:BNF~Grammar#accept grammar.accept()}, {@linkcode module:BNF~Grammar#reduce grammar.reduce()}, {@linkcode module:BNF~Grammar#shift_or_goto grammar.shift_or_goto()}, and {@linkcode module:BNF~Parser#observe parser.observe()}. @param {string} verb - one of `'accept'`, `'error'`, `'goto'`, `'reduce'`, or `'shift'`. @param {module:BNF~T|module:BNF~NT} symbol - symbol on which to send message. @param {Number|module:BNF~Rule} info - additional information, if any. */ constructor (verb, symbol, info) { this.#verb = verb; this.#symbol = symbol; this.#info = info; } /** Displays symbol, message, and additional information if any. @returns {string} */ toString () { let result = (this.symbol + ' ').substr(0, 13) + this.verb; switch (this.verb) { case 'goto': case 'shift': result += ' ' + this.info; break; case 'reduce': result += ' (' + this.info + ')'; break; } return result; }; } /** Represents a mark in a rule. @property {function()} assert - bound to {@linkcode module:BNF~Grammar#assert grammar.assert()}. @property {function()} mark - bound to {@linkcode module:BNF~Grammar#mark grammar.mark()}. @property {module:BNF~Rule} rule - rule to mark. @property {number} position - position in rule, before a symbol or after all. @property {boolean} complete - true if position is after all symbols. */ class Mark { #assert; get assert () { return this.#assert; } #mark; get mark () { return this.#mark; } #rule; get rule () { return this.#rule; } #position; get position () { return this.#position; } #complete; get complete () { return this.#complete; } /** Creates a new mark for a rule; see factory method {@linkcode module:BNF~Grammar#mark grammar.mark()}. @param {module:BNF~Grammar} grammar - supplies factory method. @param {module:BNF~Rule} rule - rule to mark. @param {number} position - position in rule, before a symbol or after all. */ constructor (grammar, rule, position) { // \"inherit\" assert() and mark() this.#assert = grammar.constructor.prototype.assert.bind(grammar); this.#mark = grammar.constructor.prototype.mark.bind(grammar); this.#rule = rule; this.#position = position; this.#complete = position == this.rule.symbols.length; } /** Displays the marked rule. @returns {string} */ toString () { return this.rule.toString(this.position); } /** Compares two marks. @param {module:BNF~Mark} c to compare to `this`. @returns true if same rule and same position. */ equals (c) { this.assert(c instanceof Mark, 'equals():', c, 'not a marked rule'); return this.rule === c.rule &amp;&amp; this.position == c.position; } /** Advances the mark. @returns {module:BNF~Mark} a new configuration with the mark moved right, i.e., `position` increased by 1. */ advance () { return this.mark(this.rule, this.position + 1); } } /** Represents a state of the automaton. @property {module:BNF~Grammar} grammar - owner of this state. @property {module:BNF~Mark[]} marks - core and closure defining this state. @property {number} core - number of marked rules in the core. @property {Object.&lt;number, module:BNF~Message&gt;} messages - maps possible next symbols to messages. @property {string[]} errors - errors detected in this state, if any. */ class State { #grammar; get grammar () { return this.#grammar; } #marks; get marks () { return this.#marks; } #core; get core () { return this.#core; } #messages; get messages () { return this.#messages; } #errors = []; get errors () { return this.#errors; } /** Creates a new state of the automaton; see factory method {@linkcode module:BNF~Grammar#state grammar.state()}. @param {module:BNF~Grammar} grammar - owner of this state. @param {module:BNF~Mark[]} marks - core and closure defining this state. @param {number} core - number of marked rules in the core. @param {Object.&lt;number, module:BNF~Message&gt;} messages - maps possible next symbols to `null`. */ constructor (grammar, marks, core, messages) { this.#grammar = grammar; this.#marks = marks; this.#core = core; this.#messages = messages; } /** Displays core configurations and messages. @returns {string} */ toString () { return this.dump(true); } /** Displays all marked rules and messages. @param {boolean} core if true, only displays core configurations. @returns {string} */ dump (core) { return ' ' + (core ? this.marks.slice(0, this.core) : this.marks). map(mark =&gt; mark.toString()). concat('', ... Object.values(this.messages). map(a =&gt; (a ? a.toString() : 'null'))).join('\\n ') + (this.errors.length ? '\\n' + this.errors.join('\\n') : ''); } /** Compares a core of marked rules to this state's core. @param {module:BNF~Mark[]} core - to compare to `this`. @returns true if this state has the same core (in any order). */ equals (core) { this.grammar.assert(core instanceof Array &amp;&amp; core.every(mark =&gt; mark instanceof Mark), 'equals():', core, 'not a list of marked rules'); // same core sizes? return this.core == core.length &amp;&amp; // same elements? this.marks.slice(0, this.core).every(a =&gt; core.some(b =&gt; a.equals(b))); } /** Populates the `.messages` table. Fills in `reduce` for complete rules, `shift` for terminals, `accept` for the end of input terminal, and `goto` for non-terminals. @param {number} stateNumber - this state's number for error messages. */ advance (stateNumber) { this.grammar.assert(typeof stateNumber == 'number' &amp;&amp; this.grammar.states[stateNumber] === this, 'advance():', stateNumber, 'invalid state number'); // following construction, messages maps every literal/token/non-terminal // which can follow this state to null. const error = (... s) =&gt; (this.errors.push(s.join(' ')), this.grammar.message('state', stateNumber + ':', ... s)); // create reduce messages for complete rules this.marks.forEach(mark =&gt; { if (mark.complete) { const rule = mark.rule; // rule we are in // for each terminal which can follow the rule in the grammar for (let t in rule.nt.follow) { // ordinal number const f = rule.nt.follow[t]; // terminal which can follow if (!(t in this.messages)) { // can it follow in this state? // if t is not in messages it cannot follow this state -&gt; reduce rule.reduced = true; this.messages[t] = this.grammar.reduce(f, rule); } else if (this.messages[t] == null) { // if (t, null) is in messages, depending on precedences we might have a s/r conflict if (rule.prec &amp;&amp; f.prec.assoc) { // rule and terminal have defined precedence if (rule.prec.level &gt; f.prec.level) { // rule's precedence is higher -&gt; reduce rule.reduced = true; this.messages[t] = this.grammar.reduce(f, rule); } else if (rule.prec.level &lt; f.prec.level) { // rule's precedence is lower -&gt; shift (below) } else // equal precedence switch (rule.prec.assoc) { case '%left': // left-associative -&gt; reduce rule.reduced = true; this.messages[t] = this.grammar.reduce(f, rule); case '%right': // right-associative -&gt; shift (below) break; case '%nonassoc': // non-associative -&gt; error action rule.reduced = true; // avoid message delete this.messages[t]; // i.e. f as input would be an error } } else { // no precedence available ++ this.grammar.sr; error('shift/reduce conflict between', f.toString(), 'and rule', '(' + rule + ')'); } // resolved as a shift (below) } else { // t is in messages and messages[t] is already set as a reduce const r2 = this.messages[t].info; // the conflict ++ this.grammar.rr; error('for', f.toString(), 'reduce/reduce conflict between', '(' + rule + ')', 'and', '(' + r2 + ')'); // resolve for rule which is first in the grammar if (rule.index &lt; r2.index) this.messages[t].info = rule; } // done with this t } // done with every t which can follow } // done with every complete mark }, this); // create accept/shift messages for each next symbol which has none for (let a in this.messages) { if (this.messages[a] == null) { if (a == this.grammar.lit().ord) { // special case: $eof this.messages[a] = this.grammar.accept(); this.grammar.rules[0].reduced = true; } else { // create next core by advancing marker over one symbol const next = [ ]; let symbol = null; this.marks.forEach(mark =&gt; { // find a as next symbol in all marks if (!mark.complete &amp;&amp; a == mark.rule.symbols[mark.position].ord) { // remember symbol and push mark after symbol symbol = mark.rule.symbols[mark.position]; next.push(mark.advance()); } }, this); // add new state with next as core, if any // shift/goto existent or new state if (!this.grammar.states.some((state, s) =&gt; state.equals(next) ? (this.messages[a] = this.grammar.shift_or_goto(symbol, s), true) : false , this)) { this.messages[a] = this.grammar.shift_or_goto(symbol, this.grammar.states.length); this.grammar.states.push(this.grammar.state(next)); } } } // done with all symbols w/out a message } // done with all symbols } } /** * Represents a context-free grammar to create SLR(1) parsers. * Contains factory methods to create objects to represent the grammar as a tree * and to represent the parsers' state table. * &lt;p&gt;A `Grammar` object can be asked to generate * {@link module:Base~Factory#scanner scanners} and [parsers](#parser) * to process input sentences conforming to the grammar. * If a parser is called with suitable {@link module:Base~Action actions} * it can transform input. * @property {?module:EBNF~Grammar} ebnf - set only if created from EBNF Grammar. * @property {Array&lt;module:BNF~Rule&gt;} rules - list of grammar rules, can be pushed. * @property {Array&lt;module:BNF~State&gt;} states - list of possible states for parser. * @property {number} sr - number of shift/reduce conflicts. * @property {number} rr - number of reduce/reduce conflicts. * * @extends module:Base~Factory * @property {Object.&lt;string, Object&gt;} config - maps names to configurable values. * @property {function(string[])} config.log - function to print strings, by default `console.log`. * @property {RegExp} config.lits - restricts literal representation, by default single-quoted; * must be anchored. * @property {RegExp} config.tokens - restricts token names, by default alphanumeric; * must be anchored. * @property {RegExp} config.nts - restricts non-terminal names, by default alphanumeric; * must be anchored. * @property {string} config.uniq - prefix for unique non-terminal names, by default `$-`. * * @property {boolean} [config.error] - if true, insert `$error` when translating `some`. * @property {boolean} [config.lookahead] - if true, trace lookahead when parsing. * @property {RegEx} [config.trace] - if set, observe with * {@linkcode module:BNF~Parser#trace grammar.trace( , config.trace)}; * only affects {@linkcode module:BNF~Grammar#parser grammar.parser()}. * @property {boolean} [config.build] - if set, build with * {@linkcode module:BNF~Parser#build grammar.build()}; * only affects {@linkcode module:BNF~Grammar#parser grammar.parser()}. * * @property {Array&lt;module:Base~Lit&gt;} lits - list of unique literals, can be pushed. * @property {Object.&lt;string, module:Base~Lit&gt;} litsByName - maps `'x'` to unique literal. * @property {Array&lt;module:Base~Token&gt;} tokens - list of unique tokens, can be pushed. * @property {Object.&lt;string, module:Base~Token&gt;} tokensByName - maps name to unique token. * @property {Array&lt;module:Base~Precedence&gt;} levels - list of precedence levels, can be pushed. * @property {Array&lt;module:Base~NT&gt;} nts - list of unique non-terminals, can be pushed. * @property {Object.&lt;string, module:Base~NT&gt;} ntsByName - maps name to unique non-terminal. * @property {number} errors - incremented by {@linkcode module:Base~Factory#error error()} method. * * @example &lt;caption&gt; LL(1) recursive descent parsing &lt;/caption&gt; * const e = new EBNF.Grammar(' ... grammar ... ') * e.parser(/ ... skip .../)(' ... input ... ') * e.parser(/ ... skip .../)(' ... input ... ', { ... actions ... }) * @example &lt;caption&gt; equivalent SLR(1) stack-based parsing &lt;/caption&gt; * const b = BNF.Grammar.fromEBNF(e) * b.parser(/ ... skip .../)(' ... input ... ') * b.parser(/ ... skip .../)(' ... input ... ', { ... actions ... }) * @example &lt;caption&gt; details &lt;/caption&gt; * const b = BNF.Grammar.fromEBNF(e) * const s = b.scanner(/ ... skip ... /) * new BNF.Parser(b).parse(s.scan(' ... input ... ').concat(null), b.build()) * new BNF.Parser(b).parse(s.scan(' ... input ... ').concat(null), b.build({ ... actions ... })) */ class Grammar extends Base.Factory { #ebnf = null; get ebnf () { return this.#ebnf; } set ebnf (value) { this.#ebnf = value; } #rules = []; get rules () { return this.#rules; } #states = []; get states () { return this.#states; } #sr = 0; get sr () { return this.#sr; } set sr (value) { this.#sr = value; } #rr = 0; get rr () { return this.#rr; } set rr (value) { this.#rr = value; } /** Creates a grammar representation. Creates the `$accept` non-terminal, `$eof` *end of input* literal, and `$error` token, and reserves rule zero: `$accept:` *start* `$eof;`. Defines tokens, if any. @param {?string} [grammar] - the grammar to represent, using the {@link module:BNF~Grammar.bnf BNF grammar} and {@link module:BNF~Grammar.terminals BNF token and literal notation}. This can be omitted to construct the rules directly using the factory methods. @param {?Object.&lt;string, RegExp&gt;} [tokens] - maps token names, if any, in the new grammar to their patterns which must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, and should use `(:? )` rather than `( )` for grouping. `tokens` can map the empty string to a skip pattern which will be used to interpret the grammar string. @param {Object.&lt;string, Object&gt;} [config] - overwrites configurable values' defaults; loaded first but can only be the third parameter. @throws {Error} an error for bad token definitions or syntax errors in the grammar. */ constructor (grammar = '', tokens = {}, config = {}) { super(); // create rule zero and the singletons. this.rule(this.nt()); // reserve $accept and rule zero this.lit().used = true; // reserve $eof (used in rule zero) this.token(); // reserve $error // load configuration, if any if (typeof config == 'object' &amp;&amp; config !== null) Object.assign(this.config, config); // compile grammar into this? if (typeof grammar == 'string') { // skip pattern let skip = /\\s+/; // load tokens, [''] is skip if (typeof tokens == 'object' &amp;&amp; tokens !== null) { if ('' in tokens) { skip = (tokens['']); delete tokens['']; } Object.entries(tokens).forEach(kv =&gt; this.token(kv[0], kv[1]), this); } // need to send output to the new config Grammar.grammar.config.log = this.config.log; // compile grammar Grammar.grammar.parser(skip).parse(grammar, new Actions(this)); // only load tokens (from grammar) } else if (typeof grammar == 'object' &amp;&amp; grammar !== null) { delete grammar['']; // if any this.add(grammar); // i.e., the token definitions if any } } /** Completes the grammar representation and reports if there are errors; call exactly once. Creates rule zero: `$accept:` *start* `$eof;`. Sets ordinal number for literals, then tokens, then non-terminals. Checks that all rules are reached and all non-terminals can reduce to a terminal. Computes first and follow sets. Creates state table. Checks that all rules can be reduced. @param {module:BNF~NT} start - the *start* non-terminal. */ check (start) { this.assert(!this.rules[0].symbols.length, 'check():', this, 'can only check a grammar once'); this.assert(start instanceof NT, 'check():', start, 'start must be a non-terminal'); // create rule zero this.rules[0].symbols.push(start, this.lit()); // set ord, create first for literals this.lits.forEach((lit, n) =&gt; lit.first[lit.ord = n] = lit); // set ord after literals, create first for tokens this.tokens.forEach((token, n) =&gt; token.first[token.ord = n + this.lits.length] = token, this); // set ord after literals and tokens this.nts.forEach((nt, n) =&gt; nt.ord = n + this.tokens.length + this.lits.length, this); // check that all non-terminals are defined this.nts.forEach(nt =&gt; !nt.rules.length &amp;&amp; this.error(nt.name, 'is undefined'), this); // set and check recursively that all non-terminals can be reached from rule 0 const setReached = rule =&gt; rule.reached || ( rule.reached = rule.nt.reached = true, rule.symbols.forEach(nt =&gt; nt instanceof NT &amp;&amp; nt.rules.forEach(setReached))); setReached(this.rules[0]); this.nts.forEach( nt =&gt; nt.reached || this.error(nt.name, 'cannot be reached from rule zero'), this); // check that all non-terminals have a finite expansion let changed; do { changed = false; // until no more changes this.rules.forEach(rule =&gt; { // check rule if (!rule.nt.finite &amp;&amp; // undecided? rule.symbols.some(sym =&gt; sym instanceof Base.T || sym.finite)) // has T or finite NT changed = rule.finite = rule.nt.finite = true; // changed: finite! }); } while (changed); this.nts.forEach(nt =&gt; nt.finite || this.error(nt.name, 'is not finite'), this); // add elements in bs to as, return true if change const merge = (as, bs) =&gt; Object.entries(bs).reduce( (result, kv) =&gt; kv[0] in as ? result : (as[kv[0]] = kv[1], true), false); // compute first for non-terminals and rules do { changed = false; // until no more changes // for each rule with non-empty rhs this.rules.forEach((rule, r) =&gt; { if (rule.symbols.length) { // for each symbol in rhs, as long as they accept empty if (rule.symbols.every(sym =&gt; { // add symbol's first to rule's first if (merge(rule.first, sym.first)) changed = true; // continue only if nt accepts empty return sym instanceof NT ? sym.empty : false; })) // if all accept empty, so does rule if (!rule.empty) changed = rule.empty = true; // add rule's first to nt's first, ditto empty if (merge(rule.nt.first, rule.first)) changed = true; if (!rule.nt.empty &amp;&amp; rule.empty) changed = rule.nt.empty = true; } }); } while (changed); // compute follow for non-terminals do { changed = false; // until no more changes // for each non-empty rule this.rules.forEach(rule =&gt; rule.symbols.length &amp;&amp; // over rhs in reverse order rule.symbols.reduceRight((follow, last) =&gt; { if (last instanceof NT) { if (merge(last.follow, follow)) changed = true; if (last.empty) // if empty, pass follow further forward return Object.assign({}, last.first, follow); } // otherwise, pass first forward return last.first; }, rule.nt.follow)); } while (changed); // create state[0]: mark rule 0 in position 0 this.states.push(this.state([this.mark(this.rules[0], 0)])); // tell each state to advance; this creates new states which are also advanced for (let s = 0; s &lt; this.states.length; ++ s) this.states[s].advance(s); // check that all rules can be reduced this.rules.forEach((rule, r) =&gt; rule.reduced || this.error('rule', r, '(' + rule + ')', 'is never reduced'), this); if (this.errors) this.message('errors: ' + this.errors); if (this.sr) this.message('shift/reduce conflicts: ' + this.sr); if (this.rr) this.message('reduce/reduce conflicts: ' + this.rr); } /** Factory method to create a unique literal symbol, maintains `.lits` and `.litsByName` @param {string} [literal] - literal's representation conforming to `.config.lits`. If omitted represents the `$eof` literal terminal. @param {boolean} [used] - if `true` mark literal as used. @returns {module:BNF~Lit} a unique literal. */ lit (literal = '', used) { // return existing literal? let lit = this.litsByName[literal]; if (! lit) { // create new literal lit = new Lit(literal); this.add(lit); } if (used) lit.used = true; return lit; } /** Factory method to create a unique token symbol, maintains `.tokens` and `.tokensByName`. @param {string} [name] - token's name conforming to `.config.tokens`; error if a non-terminal. If omitted represents the `$error` token with an empty `RegExp`. @param {RegExp} [pat] - pattern to match values representing the token in input; used only when the token is created, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )` rather than `( )` for grouping. @param {boolean} [used] - if `true` mark token as used. @returns {module:BNF~Token} a unique token. */ token (name = '', pat, used) { // return existing token? let token = this.tokensByName[name]; if (! token) { // don't allow non-terminal if (name != '' &amp;&amp; name in this.ntsByName) this.error(name, 'is already defined as a non-terminal'); // create new token token = new Token(name, name.length ? pat : new RegExp()); this.add(token); } if (used) token.used = true; return token; } /** Factory method to create a unique non-terminal symbol, maintains `.nts` and `.ntsByName`. @param {string} [name] - non-terminal's name conforming to `config.nts`; error if a token. If omitted represents the `$accept` non-terminal, if not a string creates a unique name (intended for EBNF translation). @returns {module:BNF~NT} a unique non-terminal. */ nt (name = '') { // unique name? if (typeof name != 'string') name = this.config.uniq + this.nts.length; // return existing non-terminal? let nt = this.ntsByName[name]; if (! nt) { // don't allow token if (name != '' &amp;&amp; name in this.tokensByName) this.error(name, 'is already defined as a token'); // create new non-terminal nt = new NT(name, this.nts.length); this.add(nt); } return nt; } /** Factory method to create a rule representation for BNF. Maintains rule's non-terminal's `.rules` and `this.rules`. Maintains rule's non-terminal's `.empty`. Precedence levels have to be defined prior to using this method. @param {module:BNF~NT} nt - left-hand side, non-terminal. @param {module:Base~Symbol[]} [symbols] - right-hand side, list of symbols. @param {?module:Base~T} [terminal] - can define rule's precedence, by default the precedence of the rightmost terminal, if any. @returns {module:BNF~Rule} a new rule representation. */ rule (nt, symbols = [], terminal = null) { this.assert(nt instanceof NT, 'rule():', nt, 'not a non-terminal'); this.assert(symbols instanceof Array &amp;&amp; symbols.every(s =&gt; s instanceof Lit || s instanceof Token || s instanceof NT), 'rule():', symbols, 'not an array of terminals and non-terminals'); if (terminal === null) // implicit precedence from last terminal with precedence if any symbols.forEach(s =&gt; { if (!(s instanceof NT) &amp;&amp; s.prec.assoc) terminal = s; }); else { // explicit precedence this.assert(terminal instanceof Base.T, 'rule():', terminal, 'not a terminal'); if (!terminal.prec.assoc) { this.error(terminal + ' has undefined precedence'); terminal = null; } } // create new rule const rule = new Rule(nt, symbols, this.rules.length, terminal === null ? null : Object.assign({}, { t: terminal }, terminal.prec)); // check for empty unless rule zero if (this.rules.length &amp;&amp; !symbols.length) nt.empty = true; // add new rule to rule's nt's rules and this.rules rule.nt.rules.push(rule); this.rules.push(rule); return rule; } /** Factory method to create the `accept` message for `$eof`. @returns {module:BNF~Message} an object representing the message. */ accept () { return new Message('accept', this.lit(), ''); } /** Factory method to create a `reduce` message. @param {module:Base~T} t - terminal on which to send message. @param {module:BNF~Rule} rule - rule to reduce. @returns {module:BNF~Message} an object representing the message. */ reduce (t, rule) { this.assert(t instanceof Base.T, 'reduce():', t, 'not a terminal symbol'); this.assert(rule instanceof Rule, 'reduce():', rule, 'not a Rule'); return new Message('reduce', t, rule); } /** Factory method to create a `shift` or `goto` message. @param {module:Base~Symbol} symbol - symbol on which to send message. @param {number} state - state to shift to. @returns {module:BNF~Message} an object representing the message. */ shift_or_goto (symbol, state) { this.assert(symbol instanceof Base.Symbol, 'shift_or_goto():', symbol, 'not a symbol'); this.assert(typeof state == 'number' &amp;&amp; state &gt;= 0 &amp;&amp; state &lt;= this.states.length, 'shift_or_goto():', state, 'invalid state'); return new Message(symbol instanceof Base.T ? 'shift' : 'goto', symbol, state); } /** Factory method to represent a mark in a rule. @param {module:BNF~Rule} rule - rule to mark. @param {number} position - position in rule, before a symbol or after all. @returns {module:BNF~Mark} an object representing the marked rule. */ mark (rule, position) { this.assert(rule instanceof Rule, 'mark():', rule, 'not a Rule'); this.assert(typeof position == 'number' &amp;&amp; position &gt;= 0 &amp;&amp; position &lt;= rule.symbols.length, 'mark():', position, 'invalid position'); return new Mark(this, rule, position); } /** Factory method to represent a state of the parser automaton. The state is created from the core marks; rules in the closure are added. @param {module:BNF~Mark[]} core - list of marks in the core, closure is added. @returns {module:BNF~State} an object representing the state. */ state (core) { this.assert(core instanceof Array &amp;&amp; core.every(mark =&gt; mark instanceof Mark), 'state():', core, 'not an array of marked rules'); const coreLength = core.length; // for efficient state comparison const messages = {}; // initialized to map all possible next symbols to null // compute closure: loop over core and added marks for (let c = 0; c &lt; core.length; ++ c) // for each incomplete mark if (!core[c].complete) { // next symbol in a mark const s = core[c].rule.symbols[core[c].position]; if (s instanceof NT &amp;&amp; !(s.ord in messages)) // add all rules for a new non-terminal, marked at 0 s.rules.forEach(rule =&gt; core.push(this.mark(rule, 0)), this); // map this next terminal or non-terminal to null messages[s.ord] = null; } return new State(this, core, coreLength, messages); } /** Factory method to create a parser to recognize and process input. @param {RegEx} [skip] - a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use flags, must not be anchored, should use `(:? )`rather than `( )` for grouping. @returns {module:BNF~Parser} the parser. */ parser (skip = new RegExp('\\\\s+')) { // /\\s+/ crashes jsdoc this.assert(skip instanceof RegExp, 'parser():', skip, 'not a regular expression'); return new Parser(this, skip); } /** Displays description of grammar and number of errors if any. @param {boolean} [states] - if true, also displays state table. @returns {string} */ toString (states) { const result = []; if (this.ebnf) result.push('EBNF:', '', this.ebnf.toString(), '', 'BNF:', ''); if (this.levels.length) result.push(... this.levels.map(level =&gt; ' ' + level.toString()), ''); if (this.rules.length) result.push(... this.rules.map((rule, n) =&gt; (' ' + n).substr(-3) + ' ' + rule.toString()), ''); result.push('literals: ' + this.lits.filter(lit =&gt; lit.used).join(', ')); result.push('tokens: ' + this.tokens.filter(token =&gt; token.used). map(token =&gt; token + ' ' + token.pat).join(', ')); result.push('non-terminals: ' + this.nts.join(', ')); if (states &amp;&amp; this.states.length) result.push('', this.states.map((state, n) =&gt; 'state ' + n + '\\n' + state.toString()).join('\\n\\n')); if (this.errors + this.sr + this.rr) result.push(''); if (this.errors) result.push('errors: ' + this.errors); if (this.sr) result.push('shift/reduce conflicts: ' + this.sr); if (this.rr) result.push('reduce/reduce conflicts: ' + this.rr); return result.join('\\n'); } /** Displays grammar, terminals, and non-terminals with name and contents of all sets. Displays number of errors if any. @param {?Object} a - with one argument (kludge!) acts as a static method and displays the argument converting nested arrays to a string – useful because `console.debug` only reaches 3 levels. @param {boolean} states - if true also displays states. @returns {string} */ dump (a, states) { // kludge part if (arguments.length == 1) return super.dump(a); const result = []; if (this.ebnf) result.push('EBNF:', '', this.ebnf.toString(), '', 'BNF:', ''); if (this.levels.length) result.push(... this.levels.map(level =&gt; ' ' + level.toString()), ''); if (this.rules.length) result.push(... this.rules.map((rule, n) =&gt; rule.dump()), ''); result.push('literals: ' + this.lits.join(', ')); result.push('tokens: ' + this.tokens.map(token =&gt; token + ' ' + token.pat).join(', ')); result.push('non-terminals:', ... this.nts.map(nt =&gt; nt.dump())); if (states &amp;&amp; this.states.length) result.push('', this.states.map((state, n) =&gt; 'state ' + n + '\\n' + state.dump()).join('\\n\\n')); if (this.errors + this.sr + this.rr) result.push(''); if (this.errors) result.push('errors: ' + this.errors); if (this.sr) result.push('shift/reduce conflicts: ' + this.sr); if (this.rr) result.push('reduce/reduce conflicts: ' + this.rr); return result.join('\\n'); } } /** Wraps a method {@linkcode module:BNF~Parser#parse parser.parse()} which recognizes input and calls on an observer, if any. Unlike {@linkcode module:BNF~Grammar#parser grammar.parser().parse()}, here input can be presented in pieces, i.e., the method throws `true` if it should be called with more input. @property {?module:Base~Scanner} scanner - tokenizes input. @property {boolean} parsing - true while recognition is in progress. @property {boolean} building - true if recognition calls {@linkcode module:BNF~Parser#build build()}. @property {Array.&lt;number&gt;} stack - stack of state numbers. @property {module:BNF~State} state - current state. @property {Array.&lt;object&gt;} values - parallels state stack, nested lists or action results. @property {?(function|Array.&lt;module:Base~Tuple&gt;|boolean)} input - provides input as tuples. `null`, an empty array, or a `null` array element act as `$eof`. `false` is set to request more input. @property {?module:Base~Tuple} current - current input tuple, if any. @property {Array.&lt;module:Base~Tuple&gt;} tuples - available tuples. @property {number} index - index of next tuple. @extends module:Base~Parser @property {module:BNF~Grammar} grammar - represents the grammar and states, counts errors; concurrent recognition will trash error counting. @property {?Object} actions - maps rule names to action methods during recognition. */ class Parser extends Base.Parser { #scanner; get scanner () { return this.#scanner; } #parsing = false; get parsing () { return this.#parsing; } #building; get building () { return this.#building; } #stack; get stack () { return this.#stack; } #state; get state () { return this.grammar.states[this.stack.at(-1)]; } #values; get values () { return this.#values; } #input; get input () { return this.#input; } #current = null; get current () { return this.#current; } #tuples = []; get tuples () { return this.#tuples; } #index = 0; get index () { return this.#index; } /** Creates a parser; see {@linkcode module:BNF~Grammar#parser parser()} factory method. @param {module:BNF~Grammar} grammar - represents grammar and states. @param {RegExp} [skip] - a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )`rather than `( )` for grouping. */ constructor (grammar, skip) { super(grammar); this.#scanner = grammar.scanner(skip); } /** Parses (some more) input. `actions` can only be supplied with the first input; however, the function is serially reusable. Resets and reports `.errors` for the grammar. @param {?(string|Array.&lt;module:Base~Tuple&gt;|function)} input - a string is scanned into tuples with `null` appended as end of input; can be a function which returns an array of tuples. `null`, an empty array, or a `null` array element act like a tuple containing `$eof`. @param {Function|Object} [actions] - a function is assumed to be a class and a singleton is created with `this` as constructor argument. The object maps rule names to action methods. @param {Object} arg - used as further constructor arguments. @returns {Object} result from observer, if any; ends one recognition. @throws {boolean|Error|string} `true` for more input, `Error` or error message otherwise — terminates one recognition. */ parse (input, actions, ...arg) { this.grammar.assert(input === null || typeof input == 'string' || typeof input == 'function' || (input instanceof Array &amp;&amp; input.every(elt =&gt; elt === null || elt instanceof Base.Tuple)), 'parse():', input, 'is not a string, a Tuple array, a function, or null'); // initialize? if (this.parsing) this.grammar.assert(arguments.length == 1, 'parse(): cannot accept actions while parsing'); else { // to start parsing, create stack in state 0 this.#parsing = true; this.#stack = [ 0 ]; // reset error count this.grammar.errors = 0; // set up actions, if any this.grammar.assert(!actions || actions instanceof Object || actions instanceof Function, 'parse():', actions, 'actions has no methods'); super.parse(actions, ...arg); // set up list building this.#building = this.grammar.config.build || // configured to build lists this.grammar.ebnf || // fromEBNF grammar implicitly builds this.actions; // actions require lists // create a value stack only for building if (this.building) this.#values = [ [ ] ] else delete this.values; // headline trace if any if (this.grammar.config.trace) this.grammar.message('STATE TUPLE MESSAGE RETURNS'); } // initialize for next() this.#input = typeof input == 'string' ? this.scanner.scan(input).concat(null) : input; this.#current = null; this.#tuples = []; this.#index = 0; // call/cc: throw [ result ] to return result from the parser try { while (true) { this.current || this.next(); if (this.current.t &amp;&amp; this.current.t.ord in this.state.messages) { // expected input if (this.process(this.current)) this.next(); // consumed } else // illegal character or unexpected input this.recover(); } } catch (outcome) { this.grammar.assert(outcome === true || (outcome instanceof Array &amp;&amp; outcome.length == 1) || typeof outcome == 'string' || outcome instanceof Error, 'parse():', outcome, 'is not true, [ return-value ], Error, or error message'); if (outcome !== true) { this.#parsing = false; if (this.grammar.errors) // from actions, maybe this.grammar.message('parse():', this.grammar.errors, this.grammar.errors &gt; 1 ? 'errors' : 'error'); } if (outcome instanceof Array) return outcome[0]; if (outcome instanceof Error) console.trace(outcome.message); throw outcome; } } /** Part of {@linkcode module:BNF~Parser#parse parse()}. Sets `.current` to a new tuple, but not past `$eof`. @private @throws `true` to ask for more input. */ next () { this.grammar.assert(this.tuples instanceof Array &amp;&amp; this.tuples.every(t =&gt; t === null || t instanceof Base.Tuple), 'next():', this.tuples, 'not an array of Tuple'); if (this.index &gt;= this.tuples.length) { // no tuples left if (typeof this.input == 'function') // call for input this.#tuples = this.input(); else if (this.input === false) // throw true for more input throw true; else // consume input (this.#tuples = this.input, this.#input = false); this.grammar.assert(this.tuples === null || (this.tuples instanceof Array &amp;&amp; this.tuples.every(t =&gt; t === null || t instanceof Base.Tuple)), 'next():', this.tuples, 'not null or an array of Tuple'); if (!this.tuples || this.tuples.length == 0) // none? arrange for end of input tuple this.#tuples = [ null ]; this.#index = 0; } // use 'index' tuple if ((this.#current = this.tuples[this.index]) == null) // null? set end of input tuple this.#current = this.tuples[this.index] = this.grammar.tuple(0, this.grammar.lit()); // advance index (to later tokenize more) but don't run past end of input tuple if (this.current.t !== this.grammar.lit()) ++ this.#index; if (this.grammar.config.lookahead) this.grammar.message(this.current.toString()); } /** Part of {@linkcode module:BNF~Parser#parse parse()}. processes an expected input: sends message to {@linkcode module:BNF~Parser#observe observe()} and handles the state stack and the result, if any. @private @param {module:Base~Tuple} tuple - to be processed. @returns {boolean} `true` if tuple is consumed (shift), `false` if not (reduce). @throws {string|Object[]} fatal error message or `[ result ]` if `accept` message. */ process (tuple) { this.grammar.assert(tuple instanceof Base.Tuple, 'process():', tuple, 'not a Tuple'); // get message and inform observer const verb = this.state.messages[tuple.t.ord].verb, info = this.state.messages[tuple.t.ord].info, result = this.observe(tuple, verb, info); // process switch (verb) { default: // should not happen throw 'fatal error: process(): ' + verb + ' not accept, shift, or reduce'; case 'accept': throw [ result ]; // parse ends with success case 'shift': this.grammar.assert(typeof info == 'number' &amp;&amp; info &gt;= 0 &amp;&amp; info &lt; this.grammar.states.length, 'process():', info, 'not a state number for shift'); this.stack.push(info); // shift to new state return true; // tuple consumed case 'reduce': // reduce a rule this.grammar.assert(info instanceof Rule, 'process():', info, 'not a Rule for reduce'); // pop the stack by the length of the rule, uncover state this.stack.length -= info.symbols.length; // there has to be a goto for the non-terminal const g = this.state.messages[info.nt.ord]; this.grammar.assert(g instanceof Message &amp;&amp; g.verb == 'goto', 'process():', g.verb, 'reduce expects goto'); this.grammar.assert(typeof g.info == 'number' &amp;&amp; g.info &gt;= 0 &amp;&amp; g.info &lt; this.grammar.states.length, 'process():', g.info, 'not a state number for goto'); this.observe(tuple, g.verb, g.info); // observe the goto this.stack.push(g.info); // goto to new state return false; // tuple still available } } /** Recognition observer, part of {@linkcode module:BNF~Parser#parse parse()}. Calls {@linkcode module:BNF~Parser#build build()} to create a result, if any; calls {@linkcode module:BNF~Parser#trace trace()} if configured; reports `info` from an `error` message, if any, @private @param {module:Base~Tuple} tuple - current input. @param {string} verb - of message. @param {module:BNF~Rule|number|string} info - of message. @returns {Object} the result. */ observe (tuple, verb, info) { this.grammar.assert(tuple instanceof Base.Tuple, 'observe():', tuple, 'not a Tuple'); this.grammar.assert(/^(accept|shift|reduce|goto|error)$/.test(verb), 'observe():', verb, 'not accept, shift, reduce, or error'); const result = this.building ? this.build(tuple, verb, info) : null; if (this.grammar.config.trace instanceof RegExp &amp;&amp; this.grammar.config.trace.test(verb)) this.trace(tuple, verb, info, result); if (verb == 'error' &amp;&amp; info &amp;&amp; info.length) this.error(info); return result; } /** Formats and displays trace, part of {@linkcode module:BNF~Parser#parse parse()}. @private @param {module:Base~Tuple} tuple - current input. @param {string} verb - of message. @param {module:BNF~Rule|number|string} info - of message. @param {Object} the result. */ trace (tuple, verb, info, result) { const w = (' '+ this.stack.at(-1)) .substr(-3); const t = (tuple + ' ') .substr(0, 15); const v = (verb + ' ') .substr(0, 6); const i = (verb == 'error' ? (info === null ? 'null' : '-message- ') : info + ' ').padEnd(39) .substr(0, 39); const r = this.grammar.dump(result) .substr(0, 39); this.grammar.message(w + ' ' + t + ' '+ v + ' ' + i + ' '+ r); // 3 2 15 2 6 2 39 2 39 -&gt; 110 max } /** List builder, part of {@linkcode module:BNF~Parser#parse parse()}. Manages the value stack to collect nested lists of all terminal values and applies {@link module:Base~Action action methods} matching rule names which can restructure the list of values collected for a rule. &lt;p&gt;If the grammar is created from an {@link module:EBNF~Grammar EBNF grammar} the generated rules `$-#: $-# other;` and `$-#: ;` have implicit actions to support transparency for actions. &lt;p&gt;An action should throw an `Error` to abort recognition or a string to report an error and return `null` as result. | verb | effect | | ------- | ------ | | `'shift'` | pushes the tuple's terminal's value onto the value stack; returns `null`. | | `'reduce'` | pops one value per symbol, presents the list to an {@link module:Base~Action action function} if any; returns the list or the result. | | `'goto'` | the result of the preceding `'reduce'` is on top of the value stack; returns `null`. | | `'accept'` | returns the top-level value. | | `'error'` | if there is no `info` pops one value and returns ` null`. | @private @param {module:Base~Tuple} tuple - current input. @param {string} verb - `'shift'`, `'reduce'`, `'goto'`, `'accept'`, or `'error'`. @param {module:BNF~Rule|module:Base~T|number|string} info - a reference to the relevant rule, terminal, or state number, or an error message. @returns {object} anything on success. @throws {Error} with an error message to abort recognition. */ build (tuple, verb, info) { switch (verb) { case 'shift': this.values.push(tuple.value); return null; case 'reduce': const len = info.symbols.length; let result = this.values.splice(- len, len); // can be [] if (this.grammar.ebnf &amp;&amp; info.nt.name.startsWith(this.grammar.config.uniq)) { if (len == 2 &amp;&amp; info.symbols[0] === info.nt) result.splice(0, 1, ...result[0]); else if (!len) result = null; } else try { result = this.act(info.nt.name, result); // apply action, if any } catch (e) { if (e instanceof Error) { console.trace(e); throw e; } this.error(e); result = null; } // perform upcoming 'goto' message this.values.push(result); return result; case 'goto': return null; case 'accept': return this.values.pop(); case 'error': if (!info) this.values.pop(); return null; } } /** Part of {@linkcode module:BNF~Parser#parse parse()}. Attempts error recovery within the current input sequence. Sends one 'error' with an error message, works on input and stack until a `shift` `$error` and `shift` `current` are done. Sends 'error' with null message every time the stack is popped. Returns when `current` was consumed to resume normal processing. @private @throws `true` to ask for more input, i.e., abandons recovery. @throws `[ result ]` for `$accept`. @throws `'irrecoverable error'` if the stack is empty. */ recover () { const error = this.grammar.token(), eof = this.grammar.lit(); // produce error message listing expected symbols in state table // and run the message past the observer this.observe(this.current, 'error', `${this.current} is not allowed\\nexpecting:` + Object.entries(this.state.messages).reduce((s, kv) =&gt; s += kv[1].symbol instanceof Base.T &amp;&amp; kv[1].symbol !== error ? ' ' + kv[1].symbol : '', '')); // drop any illegal character sent by the scanner while (!this.current.t) this.next(); // next tuple, throws true for more input // now at tuple with $eof or actual input console.assert(this.current instanceof Base.Tuple &amp;&amp; this.current.t instanceof Base.T, 'recover expects Tuple'); pop: while (this.stack.length &gt; 0) { if (!(error.ord in this.state.messages)) { // $error unexpected this.observe(this.current, 'error', null); // pop value stack this.stack.pop(); // pop state stack continue; } // else $error expected if (this.process(this.grammar.tuple(this.current.lineno, error))) while (true) // did shift $error, now search for input if (this.current.t?.ord in this.state.messages) { if (this.process(this.current)) { // did shift current this.#current = null; // consume return; // recovery should be complete } // else did reduce+goto before current, retry } else if (this.current.t === eof) { // end of input this.grammar.message('terminating at ' + this.current); break pop; // cannot recover } else { // current is not expected: discard this.grammar.message('discarding ' + this.current); this.next(); } // else did reduce before $error, process $error again or pop } throw 'irrecoverable error'; } /** Displays the current state stack and value stack, if any. @returns {string} */ toString () { return this.stack ? 'stack (length ' + this.stack.length +'):\\n' + this.stack.map((state, n) =&gt; (' ' + (state + ' ').substr(0, 4) + (this.building ? this.grammar.dump(this.values[n]) : '') ).substr(0, 79), this).join('\\n') : 'no stack available'; } /** Displays a message; lets grammar count it as an error. @param {object[]} s - message, to be displayed; prefixed by `.current` and joined by blanks. @return {string} the message. */ error (... s) { return this.grammar.error(this.index &gt;= 0 ? 'at' + ' ' + (this.current ? this.current.toString() : 'end of input') + ':' : '', ... s); } } /** * Grammar describing the BNF notation accepted by {@linkcode module:BNF~Grammar new Grammar()}: * &lt;p&gt; A *grammar* consists of an optional sequence of *precedence levels* * followed by one or more rules. * &lt;p&gt; Each *precedence level* consists of an associativity followed by one or more literals * or token names and terminated with a semicolon. Precedence levels are increasing. * &lt;p&gt; Each *rule* consists of a non-terminal name on the left-hand side, * a colon, a *symbol sequence* on the right-hand side, and a semicolon. * Rules with the same names are alternatives. * &lt;p&gt; A *symbol sequence* contains zero or more items, such as a non-terminal name, * a self-defining {@link module:BNF~Grammar.terminals literal}, or * the name of a {@link module:BNF~Grammar.terminals token}. * @example &lt;caption&gt; BNF grammars' grammar &lt;/caption&gt; * grammar: precedences rules; * precedences: ; * precedences: precedences '%left' terminals ';'; * precedences: precedences '%right' terminals ';'; * precedences: precedences '%nonassoc' terminals ';'; * terminals: terminal; * terminals: terminals terminal; * terminal: lit; * terminal: name; * rules: rule; * rules: rules rule; * rule: Name ':' symbols ';'; * rule: Name ':' symbols '%prec' terminal ';'; * symbols: ; * symbols: symbols name; * symbols: symbols lit; * name: Name; * lit: Lit; * @constant {string} */ Grammar.bnf = [ \"grammar: precedences rules;\", \"precedences: ;\", \"precedences: precedences '%left' terminals ';';\", \"precedences: precedences '%right' terminals ';';\", \"precedences: precedences '%nonassoc' terminals ';';\", \"terminals: terminal;\", \"terminals: terminals terminal;\", \"terminal: lit;\", \"terminal: name;\", \"rules: rule;\", \"rules: rules rule;\", \"rule: Name ':' symbols ';';\", \"rule: Name ':' symbols '%prec' terminal ';';\", \"symbols: ;\", \"symbols: symbols name;\", \"symbols: symbols lit;\", \"name: Name;\", \"lit: Lit;\" ].join('\\n'); /** * Token definitions for `Lit` and `Name` * in {@linkcode module:BNF~Grammar#bnf Grammar#bnf}. * &lt;p&gt; *Literals* represent themselves and are single-quoted strings * using `\\` only to escape single quotes and `\\` itself. * &lt;p&gt; A *Name* either represents a non-terminal or a *token*. * &lt;p&gt; *Tokens* represent sets of inputs, such as names or numbers, * and are alphanumeric names which must start with a letter * and may include underscores. * &lt;p&gt;`$error` is a special token to control error recovery. * @example &lt;caption&gt; BNF grammars' tokens &lt;/caption&gt; * { * Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, * Name: /[A-Za-z][A-Za-z0-9_]*|\\$error/ * } * @see {@linkcode module:BNF~Parser#recover recover()} * @see {@linkcode module:BNF~Grammar.grammar Grammar.grammar} * @constant {Object&lt;string,RegExp&gt;} */ Grammar.terminals = { Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, Name: /[A-Za-z][A-Za-z0-9_]*|\\$error/ }; /** * The BNF grammars' grammar; created when the module is loaded * and used internally in {@linkcode module:BNF~Grammar new Grammar()}. * @see {@linkcode module:BNF~Actions Actions} * @constant {module:BNF~Grammar} * @private */ Grammar.grammar = new Grammar(Grammar.terminals); { // grammar: precedences rules; Grammar.grammar.rule(Grammar.grammar.nt('grammar'), [ Grammar.grammar.nt('precedences'), Grammar.grammar.nt('rules') ]); // precedences: ; Grammar.grammar.rule(Grammar.grammar.nt('precedences'), [ ]); // precedences: precedences '%left' terminals ';'; Grammar.grammar.rule(Grammar.grammar.nt('precedences'), [ Grammar.grammar.nt('precedences'), Grammar.grammar.lit(\"'%left'\"), Grammar.grammar.nt('terminals'), Grammar.grammar.lit(\"';'\") ]); // precedences: precedences '%right' terminals ';'; Grammar.grammar.rule(Grammar.grammar.nt('precedences'), [ Grammar.grammar.nt('precedences'), Grammar.grammar.lit(\"'%right'\"), Grammar.grammar.nt('terminals'), Grammar.grammar.lit(\"';'\") ]); // precedences: precedences '%nonassoc' terminals ';'; Grammar.grammar.rule(Grammar.grammar.nt('precedences'), [ Grammar.grammar.nt('precedences'), Grammar.grammar.lit(\"'%nonassoc'\"), Grammar.grammar.nt('terminals'), Grammar.grammar.lit(\"';'\") ]); // terminals: terminal; Grammar.grammar.rule(Grammar.grammar.nt('terminals'), [ Grammar.grammar.nt('terminal') ]); // terminals: terminals terminal; Grammar.grammar.rule(Grammar.grammar.nt('terminals'), [ Grammar.grammar.nt('terminals'), Grammar.grammar.nt('terminal') ]); // terminal: lit; Grammar.grammar.rule(Grammar.grammar.nt('terminal'), [ Grammar.grammar.nt('lit') ]); // terminal: name; Grammar.grammar.rule(Grammar.grammar.nt('terminal'), [ Grammar.grammar.nt('name') ]); // rules: rule; Grammar.grammar.rule(Grammar.grammar.nt('rules'), [ Grammar.grammar.nt('rule') ]); // rules: rules rule; Grammar.grammar.rule(Grammar.grammar.nt('rules'), [ Grammar.grammar.nt('rules'), Grammar.grammar.nt('rule') ]); // rule: Name ':' symbols ';'; Grammar.grammar.rule(Grammar.grammar.nt('rule'), [ Grammar.grammar.token('Name'), Grammar.grammar.lit(\"':'\"), Grammar.grammar.nt('symbols'), Grammar.grammar.lit(\"';'\") ]); // rule: Name ':' symbols '%prec' terminal ';'; Grammar.grammar.rule(Grammar.grammar.nt('rule'), [ Grammar.grammar.token('Name'), Grammar.grammar.lit(\"':'\"), Grammar.grammar.nt('symbols'), Grammar.grammar.lit(\"'%prec'\"), Grammar.grammar.nt('terminal'), Grammar.grammar.lit(\"';'\") ]); // symbols: ; Grammar.grammar.rule(Grammar.grammar.nt('symbols'), [ ]); // symbols: symbols name; Grammar.grammar.rule(Grammar.grammar.nt('symbols'), [ Grammar.grammar.nt('symbols'), Grammar.grammar.nt('name') ]); // symbols: symbols lit; Grammar.grammar.rule(Grammar.grammar.nt('symbols'), [ Grammar.grammar.nt('symbols'), Grammar.grammar.nt('lit') ]); // name: Name; Grammar.grammar.rule(Grammar.grammar.nt('name'), [ Grammar.grammar.token('Name') ]); // lit: Lit; Grammar.grammar.rule(Grammar.grammar.nt('lit'), [ Grammar.grammar.token('Lit') ]); // all but $error are used Grammar.grammar.lits.forEach(lit =&gt; lit.used = true); Grammar.grammar.tokens.forEach(token =&gt; { if (token.name.length) token.used = true; }); Grammar.grammar.check(Grammar.grammar.nt('grammar')); } /** * Factory method to represent an {@link module:EBNF~Grammar EBNF grammar} * as a {@link module:BNF~Grammar BNF grammar} and check it. * @param {module:EBNF~Grammar} ebnf - grammar to represent. * @param {Object.&lt;string, Object&gt;} config - overwrites configurable values' defaults. * @returns the {@link module:BNF~Grammar BNF grammar}, ready for parsing. * @throws `'unexpected term in EBNF sequence'` *node* * @example &lt;caption&gt; Translating &lt;code&gt;[ s | t | ... ]&lt;/code&gt; &lt;/caption&gt; * $-#: ; * $-#: s; * $-#: t; * ... * @example &lt;caption&gt; Translating &lt;code&gt;{ s | t | ... }&lt;/code&gt; &lt;/caption&gt; * $-##: $-#; * $-##: $-## $-#; * $-##: $error; * $-##: $-## $error; * $-#: s; * $-#: t; * ... * @constant {function(String,Object)} */ Grammar.fromEBNF = (ebnf, config) =&gt; { const g = new Grammar(null, null, config); g.ebnf = ebnf; // [ s | t | ... ] -&gt; $-#: | s | t | ... ; const opt = opt =&gt; { const nt = g.nt({}); // unique // $-#: ; g.rule(nt); // $-#: alt; ... opt.seqs.forEach(s =&gt; g.rule(nt, seq(s)), g); return nt; }; // { s | t | ... } -&gt; $-#: s | t | ...; // $-##: $-# | $-## $-# | $error | $-## $error; const some = some =&gt; { const nt = g.nt({}), nt1 = g.nt({}); // unique // $-#: alt; ... some.seqs.forEach(s =&gt; g.rule(nt1, seq(s)), g); // $-##: $-#; g.rule(nt, [ nt1 ]); // $-##: $-## $-#; g.rule(nt, [ nt, nt1 ]); if (g.config.error) { const e = g.token(); // $-##: $error; g.rule(nt, [ e ]); // $-##: $-## $error; g.rule(nt, [ nt, e ]); } return nt; }; // a b ... -&gt; [ a, b, ... ] const seq = (seq) =&gt; seq.nodes.reduce((list, node) =&gt; { switch (node.constructor.name) { case 'Lit': list.push(g.lit(node.name)); return list; case 'Token': list.push(g.token(node.name, node.pat)); return list; case 'NT': list.push(g.nt(node.name)); return list; case 'Opt': list.push(opt(node)); return list; case 'Some': list.push(some(node)); return list; } throw Error('unexpected term in EBNF sequence ' + node.toString()); }, []); // (re)create (used) literals ebnf.lits.filter(l =&gt; l.used).forEach(l =&gt; g.lit(l.name, true)); // (re)create (used) tokens ebnf.tokens.filter(t =&gt; t.used).forEach(t =&gt; g.token(t.name, t.pat, true)); // (re)create precedences if any ebnf.levels.forEach(level =&gt; g.precedence(level.assoc, level.terminals.map(t =&gt; { const l = g.litsByName[t.name]; if (l) return l; return g.tokensByName[t.name]; }) ) ); // create start non-terminal const start = g.nt(ebnf.rules[0].nt.name); // create non-terminals and rules ebnf.rules.forEach(rule =&gt; { // record non-terminal const nt = g.nt(rule.nt.name); // create rules rule.seqs.forEach(s =&gt; { if (s.terminal) { let prec = g.litsByName[s.terminal.name]; if (! prec) prec = g.tokensByName[s.terminal.name]; g.rule(nt, seq(s), prec); } else g.rule(nt, seq(s)); }); }); // wrap up g.check(start); return g; }; /** The BNF grammar parser's actions, used internally in {@linkcode module:BNF~Grammar new Grammar()}. The methods intentionally defeat the argument count checks. @property {module:BNF~Grammar} g - the grammar to add precedences and rules to. @private */ class Actions { #g; get g () { return this.#g; } /** Creates the singleton with the {@link module:Base~Action action methods}. @param {module:BNF~Grammar} g - to hold the rule representations. */ constructor (g) { this.#g = g; } /** `grammar: precedences rules;` @returns {module:BNF~Grammar} g - represents and checks the grammar. */ grammar (p, r) { this.g.check(this.g.rules[1].nt); return this.g; } /** `precedences: ;` `precedences: precedences '%left' terminals ';';` `precedences: precedences '%right' terminals ';';` `precedences: precedences '%nonassoc' terminals ';';` */ precedences (... arg) { return ((p, assoc, terminals) =&gt; { if (assoc) this.g.precedence(assoc, terminals); })(... arg); } /** `terminals: terminal;` `terminals: terminals terminal;` @returns {module:BNF~Lit|module:BNF~Token} represents a list of terminals. */ terminals (... t) { if (t.length == 1) return [ t[0] ]; t[0].push(t[1]); return t[0]; } /** `terminal: lit;` `terminal: name;` @returns {module:BNF~Lit|module:BNF~Token} represents a terminal. */ terminal (item) { if (!(item instanceof NT)) return item; this.g.error(item.name + ': precedence requires a terminal'); return null; } /** `rule: Name ':' symbols ';';` `rule: Name ':' symbols '%prec' terminal ';';` @returns {module:BNF~Rule} represents a rule. */ rule (... arg) { return ((name, _, symbols, p, terminal) =&gt; this.g.rule(this.g.nt(name), symbols, terminal) )(... arg); } /** `symbols: ;` `symbols: symbols name;` `symbols: symbols lit;` @returns {module:Base~Symbol[]} represents a list of symbols. */ symbols (... symbols) { if (!symbols.length) return [ ]; symbols[0].push(symbols[1]); return symbols[0]; } /** `name: Name;` @returns {module:BNF~Token|module:BNF~NT} represents a used token or a non-terminal. */ name (name) { if (name == '$error') return this.g.token('', new RegExp(), true); if (name in this.g.tokensByName) return this.g.token(name, undefined, true); return this.g.nt(name); } /** `lit: Lit;` @returns {module:BNF~Lit} represents a used literal. */ lit (literal) { return this.g.lit(literal, true); } } export { Lit, Token, NT, Rule, Message, Mark, State, Grammar, Parser, Actions }; × Search results Close "},"base.js.html":{"id":"base.js.html","title":"Source: base.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: base.js /** A module which contains classes and methods shared by both, the {@link module:BNF BNF} and {@link module:EBNF EBNF} modules. It implements messaging, creating precedence levels, and creating scanners. | class | main properties | main methods | | ----- | --------------- | ------------ | | {@linkcode module:Base~Factory Factory} | `config`, `errors`,&lt;br&gt;`lits`[`ByName`], `tokens`[`ByName`], `nts`[`ByName`],&lt;br&gt;`levels`: `Array&lt;`{@linkcode module:Base~Precedence Precedence}`&gt;` | {@linkcode module:Base~Factory#add add(item)}, {@linkcode module:Base~Factory#dump dump(item)},&lt;br&gt;{@linkcode module:Base~Factory#assert assert(condition, ...)},&lt;br&gt;{@linkcode module:Base~Factory#error error(...)},&lt;br&gt;{@linkcode module:Base~Factory#message message(...)} | | {@linkcode module:Base~Precedence Precedence} | `assoc`, `terminals` | | | {@linkcode module:Base~Scanner Scanner} | `pattern` | {@linkcode module:Base~Scanner#scan scan(input)}: `Array&lt;`{@linkcode module:Base~Tuple Tuple}`&gt;` | | {@linkcode module:Base~Tuple Tuple} | `lineno`, `t`, `value` | {@linkcode module:Base~Tuple#escape escape(s)} | @module Base @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-13 */ /** Contains configurable values, inventories, and factory methods to create scanners, tokenized input tuples, and precedence levels. @property {Object.&lt;string, Object&gt;} config - maps names to configurable values. @property {function(string[])} config.log - function to print strings, by default `console.log`. @property {RegExp} config.lits - restricts literal representation, by default single-quoted; must be anchored. @property {RegExp} config.tokens - restricts token names, by default alphanumeric; must be anchored. @property {RegExp} config.nts - restricts non-terminal names, by default alphanumeric; must be anchored. @property {string} config.uniq - prefix for unique non-terminal names, by default `$-`. @property {Array&lt;module:Base~Lit&gt;} lits - list of unique literals, can be pushed. @property {Object.&lt;string, module:Base~Lit&gt;} litsByName - maps `'x'` to unique literal. @property {Array&lt;module:Base~Token&gt;} tokens - list of unique tokens, can be pushed. @property {Object.&lt;string, module:Base~Token&gt;} tokensByName - maps name to unique token. @property {Array&lt;module:Base~Precedence&gt;} levels - list of precedence levels, can be pushed. @property {Array&lt;module:Base~NT&gt;} nts - list of unique non-terminals, can be pushed. @property {Object.&lt;string, module:Base~NT&gt;} ntsByName - maps name to unique non-terminal. @property {number} errors - incremented by {@linkcode module:Base~Factory#error error()} method; can be reset, e.g., to count during recognition. @property {boolean} noargs - don't check for argument count errors in {@linkcode module:Base~Parser#act act()} method. @abstract */ class Factory { #config = { log: console.log, lits: /^'(?:[^'\\\\]|\\\\['\\\\])+'$/, tokens: /^[A-Za-z][A-Za-z0-9_]*$/, nts: /^[A-Za-z][A-Za-z0-9_]*$/, uniq: '$-', noargs: false }; get config () { return this.#config; } #lits = []; get lits () { return this.#lits; } #litsByName = { }; get litsByName () { return this.#litsByName; } #tokens = [ ]; get tokens () { return this.#tokens; } #tokensByName = { }; get tokensByName () { return this.#tokensByName; } #levels = []; get levels () { return this.#levels; } #nts = [ ]; get nts () { return this.#nts; } #ntsByName = { }; get ntsByName () { return this.#ntsByName; } #errors = 0; get errors () { return this.#errors; } set errors (errors) { this.#errors = errors; } /** Adds a new symbol to the proper inventory or creates and adds new tokens. Must be called with a new, unique symbol or with a map of token names to patterns. Validates item names against `.config`. Token patterns must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, and should use `(:? )` rather than `( )` for grouping. @param {Symbol|Object.&lt;string, RegExp&gt;} item - to add to the proper inventory or create and add. */ add (item) { if (item instanceof Symbol) { this.assert(typeof item.name == 'string', 'add():', item, 'name not a string'); if (item instanceof Lit) { this.assert(item.name == '' || this.config.lits.test(item.name), 'add():', item, 'invalid literal'); this.assert(!(item.name in this.litsByName), 'add():', item, 'already in litsByName'); this.lits.push(item); this.litsByName[item.name] = item; } else if (item instanceof Token) { this.assert(item.name == '' || this.config.tokens.test(item.name), 'add():', item, 'invalid token name'); this.assert(item.pat instanceof RegExp, 'add():', item, 'not a regular expression pattern'); if (item.name.length) { this.assert(!item.pat.test(''), 'add():', item, 'pattern accepts empty input'); this.assert(!/[dgy]/.test(item.pat.flags), 'add():', item, 'pattern uses \"d\", \"g\", or \"y\" flag(s)'); } this.assert(!(item.name in this.tokensByName), 'add():', item, 'already in tokensByName'); this.tokens.push(item); this.tokensByName[item.name] = item; } else if (item instanceof NT) { this.assert(item.name == '' || item.name.startsWith(this.config.uniq) || this.config.nts.test(item.name), 'add():', item, 'invalid non-terminal name'); this.assert(!(item.name in this.ntsByName), 'add():', item, 'already in ntsByName'); this.nts.push(item); this.ntsByName[item.name] = item; } else this.assert(false, 'add():', item, 'no suitable inventory'); } else { this.assert(item instanceof Object, item, 'not a map of token definitions'); Object.entries(item).forEach(kv =&gt; this.token(kv[0], kv[1]), this); } } /** Displays an object as a string; in particular, nested arrays. This is useful because `console.debug` only reaches 3 levels. @param {Object} [a] - the object to display; if omitted, returns an empty string. @returns {string} */ dump (a) { if (!arguments.length) return ''; switch (typeof a) { case 'string': return \"'\" + a.replace(/([\\\\'])/g, \"\\\\$1\") + \"'\"; // could do more... case 'object': if (a) switch (a.constructor.name) { case 'Array': return '[ ' + a.map(elt =&gt; this.dump(elt)).join(' ') + ' ]'; default: return a.constructor.name + ' { ' + a.toString() + ' }'; } return 'null'; } return '' + a; } /** Factory method to represent a list of terminals with equal precedence level and equal associativity. Creates a new {@linkcode module:Base~Precedence Precedence} object, adds it to `.levels`, adds `.prec.level` and `.prec.assoc` to all terminals in the list, and checks for duplicates. @param {string} assoc - associativity: `'%left'`, `'%right'`, or `'%nonassoc'`. @param {Array.&lt;?module:Base~T&gt;} terminals - to add, `null` elements are ignored; no duplicates. @returns {?module:Base~Precedence} representing the set, or `null` if there are no terminals. */ precedence (assoc, terminals) { this.assert(/^%(left|right|nonassoc)$/.test(assoc), 'precedence():', assoc, 'invalid associativity'); this.assert(terminals instanceof Array &amp;&amp; terminals.every(t =&gt; t === null || t instanceof T), 'precedence():', terminals, 'invalid list of termials'); let result = null; terminals = terminals.filter(t =&gt; !!t); if (terminals.length) { terminals.forEach(t =&gt; { this.assert(!t.prec.assoc, 'precedence():', t, 'is a duplicate precedence definition'); t.prec.level = this.levels.length, t.prec.assoc = assoc; }, this); result = new Precedence(assoc, terminals); this.levels.push(result); } return result; } /** Factory method to create a scanner. @param {RegExp} [skip] - a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )` rather than `( )` for grouping. @param {Array&lt;T&gt;} [terminals] - ordered list to create the lexical analysis pattern. @returns {?module:Base~Scanner} the scanner. */ scanner (skip = new RegExp('\\\\s+'), terminals) { // /\\s+/ crashes jsdoc this.assert(skip instanceof RegExp, 'scanner():', skip, 'not a regular expression'); this.assert(!skip.test(''), 'scanner():', skip, 'skip accepts empty input'); this.assert(!/[dgy]/.test(skip.flags), 'scanner():', skip, 'skip uses \"d\", \"g\", or \"y\" flag(s)'); // can't check anchor and grouping. this.assert(!terminals || (terminals instanceof Array &amp;&amp; terminals.every(t =&gt; t instanceof T)), 'scanner():', terminals + ':', 'not a list of terminals'); return new Scanner(this, skip, terminals); } /** Factory method to create an element of a tokenized input stream. @param {number} lineno - input position. @param {?module:Base~T} t - terminal, i.e., literal or token object; {@linkcode module:Base~Scanner#scan scan()} uses `null` for an illegal character. @param {?string} [value] - terminal's representation in the input. @returns {module:Base~Tuple} an element of a tokenized input stream. */ tuple (lineno, t, value = null) { this.assert(typeof lineno == 'number' &amp;&amp; lineno &gt;= 0, 'tuple():', lineno, 'invalid line number'); this.assert(t === null || t instanceof T, 'tuple():', t, 'invalid terminal'); this.assert(value === null || typeof value == 'string', 'tuple():', value, 'invalid value'); return new Tuple(lineno, t, value === null ? '' : value); } /** Displays a message and throws an error if a condition is not met; primarily used for stronger argument typing. @param {boolean} condition - should be true. @param {Array&lt;?object&gt;} s - message, to be displayed; joined by blanks. @throws {string} message if condition is not met. */ assert (condition, ...s) { if (!condition) throw this.message('assertion error:', ... s); } /** Displays a message and counts it as an error. @param {Array&lt;?object&gt;} s - message, to be displayed; joined by blanks. @return {string} the message. */ error (...s) { ++ this.errors; return this.message('error:', ... s); } /** Displays a message on the configured `.log`. @param {Array&lt;?object&gt;} s - message, to be displayed; joined by blanks. @return {string} the message. */ message (...s) { const message = s.map(s =&gt; s === null ? 'null' : s.toString()).join(' '); this.config.log(message); return message; } } /** Represents a symbol in the grammar alphabets. Symbols are only created through factory methods in the grammar which arrange for uniqueness. @property {string} name - name for a token or non-terminal, representation for a literal. An empty string is used for one reserved symbol in each subclass. @abstract */ class Symbol { #name; get name () { return this.#name; } /** Creates a symbol; should only be used by subclass. @param {string} name - symbol name. */ constructor (name) { this.#name = name; } } /** Represents a terminal, i.e., a literal or a token. @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {boolean} used - true if used in a grammar. @extends module:Base~Symbol @property {string} name - name for a token, representation for a literal. @abstract */ class T extends Symbol { #prec = { }; get prec () { return this.#prec; } #used = false; get used () { return this.#used; } set used (_) { this.#used = true; } // cannot clear /** Creates a terminal; should only be used by subclass. @param {string} name - name for a token, representation for a literal. */ constructor (name) { super(name); } /** Displays description and precedence, if any. @returns {string} */ dump () { return this.toString() + (this.prec.assoc ? ' ' + this.prec.assoc + ' ' + this.prec.level : ''); } } /** Represents a literal symbol. @property {string} value - (unquoted) value for the literal; empty string for `$eof`, too. @property {boolean} [screened] - set true only during scanner construction if literal value matches a token pattern. @extends module:Base~T @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {boolean} used - true if used in a grammar. @property {string} name - name for a token, representation for a literal. @abstract */ class Lit extends T { #value; get value () { return this.#value; } /** Creates a literal symbol; should only be used by factory method. Extracts value from representation. @param {string} name - (quoted) representation for the literal. Empty string is reserved for `$eof`, the end of input. */ constructor (name) { super(name); this.#value = name.length ? this.unescape(name) : ''; } /** Displays representation of a literal or `$eof`. @returns {string} */ toString () { return this.name.length ? this.name : '$eof'; } /** Removes leading and trailing delimiter character and elaboarates backslash escapes. @param {string} s - string to unescape. @returns {string} unquoted, unescaped string. */ unescape (s) { let result = '', c; for (let i = 1; i &lt; s.length - 1; ) if ((c = s.charAt(i ++)) != '\\\\') result += c; else if (i &gt;= s.length - 1) result += '\\\\'; // trailing backslash in literal else if ((c = 'bfnrtv\\\\\\''.indexOf(s.charAt(i ++))) &gt;= 0) result += '\\b\\f\\n\\r\\t\\v\\\\\\''.charAt(c); else switch (c = s.charAt(i - 1)) { case 'x': if (i + 1 &lt; s.length-1 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i)) &gt;= 0 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i + 1)) &gt;= 0) { result += String.fromCharCode(parseInt(s.substr(i, 2), 16)); i += 2; } else result += 'x'; // bad \\x break; case 'u': if (i + 3 &lt; s.length-1 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i)) &gt;= 0 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i + 1)) &gt;= 0 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i + 2)) &gt;= 0 &amp;&amp; '0123456789abcdef'.indexOf(s.charAt(i + 3)) &gt;= 0) { result += String.fromCharCode(parseInt(s.substr(i, 4), 16)); i += 4; } else result += 'u'; // bad \\u break; default: // bad \\ result += c; } return result; } } /** Represents a token symbol. @property {RegExp} pat - pattern for token; empty `RegExp` for `$error`. @property {Array&lt;Lit&gt;} [screen] - contains literals with values matching the pattern, if any. @extends module:Base~T @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {boolean} used - true if used in a grammar. @property {string} name - name for a token, representation for a literal. Empty string is reserved for `$error`, can be something unexpected. @abstract */ class Token extends T { #pat; get pat () { return this.#pat; } /** Creates a token symbol; should only be used by factory method. @param {string} name - token name. Empty string is reserved for `$error`, something unexpected. @param {RegExp} pat - pattern for token; empty `RegExp` for `$error`. */ constructor (name, pat) { super(name); this.#pat = pat; } /** Displays name of a token or `$error`. @returns {string} */ toString () { return this.name.length ? this.name : '$error'; } } /** Represents a list of terminal symbols of equal precedence and associativity. @property {string} assoc - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`. @property {Array&lt;module:Base~T&gt;} terminals - list of terminal symbols. */ class Precedence { #assoc; get assoc () { return this.#assoc; } #terminals; get terminals () { return this.#terminals; } /** Creates a new precedence level; see factory method {@linkcode module:Base~Factory grammar.precedence()}. @param {string} assoc - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`. @property {Array&lt;module:Base~T&gt;} terminals - list of terminals. */ constructor (assoc, terminals) { this.#assoc = assoc; this.#terminals = terminals; } /** Displays associativity and the list of terminals. @returns {string}. */ toString () { return this.assoc + ' ' + this.terminals.join(' '); } /** Displays associativity and the list of terminals. @returns {string}. */ dump () { return this.toString(); } } /** Represents a non-terminal symbol. @extends module:Base~Symbol @property {string} name - name for the non-terminal. Empty string is reserved for `$accept`, can be left-hand side of a start rule. @abstract */ class NT extends Symbol { /** Creates a non-terminal symbol; should only be used by factory method. @param {string} name - non-terminal's name. */ constructor (name) { super(name); } /** Displays name of a non-terminal or `$accept`. @returns {string} */ toString () { return this.name.length ? this.name : '$accept'; } /** Displays name of a non-terminal or `$accept`. @returns {string} */ dump () { return this.toString(); } } /** Represents an element of a tokenized input stream. @property {number} lineno - input position. @property {?module:Base~T} t - terminal, i.e., literal or token object. `null` is reserved for unrecognizable input. @property {string} value - `t`'s representation in the input. */ class Tuple { #lineno; get lineno () { return this.#lineno; } #t; get t () { return this.#t; } #value; get value () { return this.#value; } /** Creates an element of a tokenized input stream; see factory method {@linkcode module:Base~Factory#tuple grammar.tuple()}. @param {number} lineno - input position. @param {?module:Base~T} t - terminal, i.e., literal or token object. `null` is reserved for unrecognizable input. @param {string} value - `t`'s representation in the input. */ constructor (lineno, t, value) { this.#lineno = lineno; this.#t = t; this.#value = value; } /** Displays position, terminal, and associated value. @returns {string}. */ toString () { return (this.lineno &gt; 0 ? '(' + this.lineno + ') ' : 'eof ') + (!this.t ? this.escape(this.value) // unrecognizable input : this.t instanceof Lit ? this.t.toString() // literal representation or `$eof` : this.t.toString == '$error' ? '$error' : this.escape(this.value) + ' ' + this.t); // token } /** Escapes non-ASCII and invisible characters using backslash. Similar to {@linkcode module:Base~Scanner#escape Scanner.escape()}. @param {string} s - string to escape. @returns {string} double-quoted, escaped string. @example escape(null) // returns empty string escape('x') // returns string containing \"x\" escape('\\b') // returns string containing \"\\b\" escape('y') // returns string containing \"\\x##\" or \"\\u####\" */ escape (s) { if (s == null) return ''; let result = '\"'; for (let i = 0; i &lt; s.length; ++ i) { let c = s.charAt(i); let cc = '\\b\\f\\n\\r\\t\\v\\\\\"'.indexOf(c); if (cc &gt;= 0) result += '\\\\' + 'bfnrtv\\\\\"'.charAt(cc); else if (c &gt;= ' ' &amp;&amp; c &lt;= '~') result += c; else if ((cc = s.charCodeAt(i)) &lt; 16) result += '\\\\x0' + cc.toString(16); else if (cc &lt; 256) result += '\\\\x' + cc.toString(16); else if (cc &lt; 16 * 256) result += '\\\\u0' + cc.toString(16); else result += '\\\\u' + cc.toString(16); } return result + '\"'; } } /** Wraps a function which tokenizes a string. Token patterns should not partially overlap literals, e.g., `/[a-z]+/` would conceal `'formula1'`. @property {function(string[])} assert - bound to {@linkcode module:Base~Factory#assert factory.assert()}. @property {function(string[])} tuple - bound to {@linkcode module:Base~Factory#tuple factory.tuple()}. @property {Array.&lt;module:Base~T&gt;} terminals - ordered for pattern; first tokens ordered by ascending name then literals ordered by decreasing length. @property {RegExp} skip - a pattern to define ignorable character sequences, should not accept empty input, should not use flags, should not be anchored, should use `(:? )` rather than `( )` for grouping. @property {RegExp} pattern - read-only, concatenates capture groups with `skip` and `terminals`, used to disect input. */ class Scanner { #assert; get assert () { return this.#assert; } #tuple; get tuple () { return this.#tuple; } #terminals; get terminals () { return this.#terminals; } #skip; get skip () { return this.#skip; } #pattern; get pattern () { return this.#pattern; } /** Creates the pattern used to tokenize a string; see factory method {@linkcode module:Base~Factory#scanner grammar.scanner()}. @param {module:Base~Factory} factory - supplies literals and tokens; unused terminals and `$eof` and `$error`, if any, are ignored. @param {RegExp} skip - a pattern to define ignorable character sequences, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )` rather than `( )` for grouping. @param {Array&lt;T&gt;} [terminals] - ordered list corresponding to `.pattern`; if omitted, tokens by ascending name and then literals by decreasing length. */ constructor (factory, skip, terminals) { // \"inherit\" assert() and tuple() this.#assert = factory.constructor.prototype.assert.bind(factory); this.#tuple = factory.constructor.prototype.tuple.bind(factory); if (terminals) this.#terminals = terminals; // and we hope for the best else { // import non-empty, used literals, sorted by decreasing length const lits = factory.lits.filter(lit =&gt; lit.used &amp;&amp; lit.name.length).sort( (a, b) =&gt; a === b ? 0 : a.value &lt; b.value ? 1 : -1); // import non-empty, used tokens, sorted by ascending name const tokens = factory.tokens.filter(token =&gt; token.used &amp;&amp; token.name.length).sort( (a, b) =&gt; a === b ? 0 : a.name &lt; b.name ? -1 : 1); // token.screen = non-empty map of covered literals, if any // lit.screened = true if literal is covered by one token, two or more is bad tokens.forEach(token =&gt; { let keep = false; token.screen = lits.reduce((map, lit) =&gt; { const match = token.pat.exec(lit.value); // match? if (match &amp;&amp; match[0] == lit.value) { // exact this.assert(!lit.screened, lit + ': must not be recognized by more than one token pattern'); lit.screened = true; keep = true; map[lit.value] = lit; // to be screened for } return map; }, { }); if (!keep) delete token.screen; // nothing to screen }); // tokens followed by non-screened literals this.#terminals = tokens.concat(lits.filter(lit =&gt; !lit.screened)); // remove screened flags if any lits.forEach(lit =&gt; { delete lit.screened; }); } this.#skip = skip; // pattern = ^(:? ( skip ) | ( token ) |.. | ( literal ) |.. ) flags: mg let pattern = [ ]; // skip pattern.push('(' + skip.toString().slice(1, -1) + ')'); // terminals pattern.push(... this.terminals.map(t =&gt; '(' + (t instanceof Lit ? this.escape(t.value) : t.pat.toString().slice(1, -1)) + ')')); this.#pattern = new RegExp(pattern.join('|'), 'mg'); } /** Tokenizes a string. @param {string} input - to be divided into literals and tokens. @returns {Array.&lt;module:Base~Tuple&gt;} a list of literals and tokens. The list contains one `Tuple` with a `null` terminal for each character sequence which is neither ignorable nor a literal or a token. */ scan (input) { this.assert(typeof input == 'string', 'scan():', input, 'not a string'); // returns number of \\n in s const nl = s =&gt; s.replaceAll(/[^\\n]/g, '').length; const result = []; let lineno = 1, m, begin = this.pattern.lastIndex = 0; while (this.pattern.lastIndex &lt; input.length) // loop over input if (m = this.pattern.exec(input)) { // find anything? if (m.index &gt; begin) { // illegal char at beginning? const illegal = input.substr(begin, m.index - begin); result.push(this.tuple(lineno, null, illegal)); lineno += nl(illegal); // count \\n } m.slice(2).some((input, n) =&gt; { // non-skip capture groups if (!input || !input.length) return false; // group did not match let t = this.terminals[n], // corresponding terminal lit; // result of screening if any if (t instanceof Token &amp;&amp; t.screen &amp;&amp; (lit = t.screen[input])) t = lit; result.push(this.tuple(lineno, t, input)); // new tuple return true; }); lineno += nl(m[0]); // count \\n begin = this.pattern.lastIndex; // next scan starts here } else { // nothing left to find result.push(this.tuple(lineno, null, input.substr(begin))); break; } return result; } /** Escapes most characters by `\\.` or `\\x..` or `\\u....`. Similar to {@linkcode module:Base~Tuple#escape Tuple.escape()}. @param {string} s - string to escape. @returns {string} escaped string. escape(null) // will crash escape('a') // [alphanumerics] returns string containing a escape('\\b') // [controls] returns string containing \\b escape('s') // [specials] returns string containing \\s escape('x') // [other] returns string containing \\x## or \\u#### */ escape (s) { this.assert(typeof s == 'string', 'escape():', s, 'not a string'); let result = ''; for (let i = 0; i &lt; s.length; ++ i) { let c = s.charAt(i), cc; if (c.search(/[a-zA-Z0-9_]/) &gt;= 0) result += c; else if ((cc = '\"\\b\\f\\n\\r\\t\\v\\\\\\''.indexOf(c)) &gt;= 0) result += '\\\\' + '\"bfnrtv\\\\\\''.charAt(cc); else if (c.search(/[\\x20-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7e]/) &gt;= 0) result += '\\\\' + c; else { c = s.charCodeAt(i); if (c &lt; 16) result += '\\\\x0' + c.toString(16); else if (c &lt; 256) result += '\\\\x' + c.toString(16); else if (c &lt; 16*256) result += '\\\\u0' + c.toString(16); else result += '\\\\u' + c.toString(16); } } return result; } } /** Method to process values collected by a rule. @callback Action @param {...Object} value - one value collected per item on the right-hand side. @returns {Object} the value to be collected in the parent rule or returned by recognition. @throws {string|Error} a string with an error message to continue recognition or an `Error` with an error message to abort recognition. */ /** Abstract base class for recognition based on a grammar. Should wrap a method `parse()` which recognizes input, builds a tree of nested lists, and creates and calls on an object with {@link module:Base~Action action methods}, if any. @property {module:Base~Factory} grammar - represents the grammar, counts errors; concurrent recognition will trash error counting. @property {?Object} actions - maps rule names to action methods during recognition. @abstract */ class Parser { #grammar; get grammar () { return this.#grammar; } #actions = null; get actions () { return this.#actions; } /** Creates a parser; only used by subclass to set `.grammar`. @param {module:Base~Factory} grammar - represents grammar. */ constructor (grammar) { this.#grammar = grammar; } /** Only used by subclass to set `.actions`; resets `.errors` for the grammar. Should recognize an input sentence. @param {Function|Object} [actions] - a function is assumed to be a class and a singleton is created with `this` as constructor argument. The object maps rule names to action methods. @param {Object} arg - used as further constructor arguments. */ parse (actions, ...arg) { // action methods? try { if (actions instanceof Function) this.#actions = new actions(this, ...arg); else if (actions instanceof Object) this.#actions = actions; } catch (e) { throw new Error( this.grammar.error('parse cannot create actions:', e instanceof Error ? e.message : e) ); } // reset error count this.grammar.errors = 0; } /** Calls an {@link module:Base~Action action method}. Checks argument count unless `grammar.config.noargs` is set or the method expects no arguments, i.e., has a rest parameter. @param {string} name - rule name to match. @param {Array} result - list of arguments. @returns action method result or unchanged `result`. */ act (name, result) { if (this.actions) { const method = this.actions.constructor.prototype[name]; if (typeof method == 'function') { if (this.grammar.config.actions) // trace before this.grammar.config.log(name + '(' + result.map(arg =&gt; this.grammar.dump(arg)).join(', ') + ')', 'returns'); // call action method result = this.call(this.actions, method, ...result); if (this.grammar.config.actions) // trace after this.grammar.config.log(this.grammar.dump(result)); } } return result; } /** Checks if argument and parameter count of a method match unless the method expects no parameters, or has a rest parameter or `grammar.config.noargs` is true. @param {object} target - to apply method to. @param {function} method - to check. @param {Object} args - arguments to pass. @returns {Object} method result. @example &lt;caption&gt;&lt;tt&gt; super.method(arg1, .. argn) &lt;/tt&gt;&lt;/caption&gt; this.parser.call(this, super.method, arg1, .. argn) */ call (target, method, ...args) { if (method.length &amp;&amp; !this.grammar.config.noargs &amp;&amp; method.length != args.length) this.grammar.error(`${method.name} arguments: expected ${method.length}, ` + `received ${args.length}`); return method.apply(target, args); } } export { Factory, Lit, NT, Parser, Precedence, Scanner, Symbol, T, Token, Tuple }; × Search results Close "},"ebnf.js.html":{"id":"ebnf.js.html","title":"Source: ebnf.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: ebnf.js /** A module which extends the {@link module:Base Base module} * and supports creating scanners and recursive descent parsers * from [LL(1) grammars](https://en.wikipedia.org/wiki/LL_parser) * and actions written in JavaScript. * * The fundamental object created by this module * is a {@linkcode module:EBNF~Grammar Grammar} prepared from grammar rules * using the syntax defined {@link module:EBNF~Grammar.ebnf here}. * The syntax includes alternative and optional and iterated sequences, * all of which must not recognize empty input. * [This book chapter]{@tutorial 02-grammars} explains how to write grammar rules. * * A {@linkcode module:EBNF~Grammar Grammar}, optionally with precedences, * can be imported by the {@link module:BNF BNF module} for stack-based parsing, * but the {@link module:BNF BNF} and {@link module:EBNF EBNF} modules * do not depend on each other. * * The grammar rules are represented using a number of classes * as discussed in [this book chapter]{@tutorial 04-parser} * and summarized in the following table: | tree structure | getters | checking | parsing | | --- | --- | --- | --- | | {@linkcode module:EBNF~Grammar Grammar} | `config`, `rules`, `prefix` | {@linkcode module:EBNF~Grammar#check check()} | {@linkcode module:EBNF~Grammar#parser parser().}{@linkcode module:EBNF~Parser#parse parse()} | | {@linkcode module:EBNF~Node Node} | `grammar`, `expect`, `#follow` | {@linkcode module:EBNF~Node#shallow shallow()}, {@linkcode module:EBNF~Node#deep deep()}, {@linkcode module:EBNF~Node#follow follow()}, {@linkcode module:EBNF~Node#check check()} | {@linkcode module:EBNF~Node#parse parse()}: `string`&lt;br&gt;for terminals | | {@linkcode module:EBNF~Lit Lit}: {@linkcode module:Base~Lit Lit}: {@linkcode module:Base~T T}: {@linkcode module:Base~Symbol Symbol} + {@linkcode module:EBNF~Node Node} | `name`, `value`, `prec`, `used`, `expect` | | : `string` | | {@linkcode module:EBNF~Token Token}: {@linkcode module:Base~Token Token}: {@linkcode module:Base~T T}: {@linkcode module:Base~Symbol Symbol} + {@linkcode module:EBNF~Node Node} | `name`, `pat`, `prec`, `used`, `expect` | | : `string` | | {@linkcode module:EBNF~NT NT}: {@linkcode module:Base~NT NT}: {@linkcode module:Base~Symbol Symbol} + {@linkcode module:EBNF~Node Node} | `name`, `rule`: {@linkcode module:EBNF~Rule Rule}, `expect` | {@linkcode module:EBNF~NT#shallow shallow()}, {@linkcode module:EBNF~NT#deep deep()}, {@linkcode module:EBNF~NT#follow follow()} | {@linkcode module:EBNF~NT#parse parse()}: `Array`&lt;br&gt;\\|{@linkcode module:Base~Action action} *value* | | {@linkcode module:EBNF~Alt Alt} + {@linkcode module:EBNF~Node Node} | `seqs`: {@linkcode module:EBNF~Seq Seq[]}, `expect` | {@linkcode module:EBNF~Alt#shallow shallow()}, {@linkcode module:EBNF~Alt#deep deep()}, {@linkcode module:EBNF~Alt#follow follow()}, {@linkcode module:EBNF~Alt#check check()} | {@linkcode module:EBNF~Alt#parse parse()}: `Array` | | {@linkcode module:EBNF~Rule Rule}: {@linkcode module:EBNF~Alt Alt} | `nt`, `recursed`, `reached` | {@linkcode module:EBNF~Rule#shallow shallow()}, {@linkcode module:EBNF~Rule#deep deep()} | {@linkcode module:EBNF~Rule#parse parse()}: `Array`&lt;br&gt;\\|{@linkcode module:Base~Action action} *value* | | {@linkcode module:EBNF~Opt Opt}: {@linkcode module:EBNF~Alt Alt} | | {@linkcode module:EBNF~Opt#check check()} | : `null`\\|`Array` | | {@linkcode module:EBNF~Some Some}: {@linkcode module:EBNF~Alt Alt} | | {@linkcode module:EBNF~Some#follow follow()}, {@linkcode module:EBNF~Some#check check()} | {@linkcode module:EBNF~Some#parse parse()}: `Array`\\&lt;`Array`\\&gt; | | {@linkcode module:EBNF~Seq Seq} + {@linkcode module:EBNF~Node Node} | `nodes`: `Array&lt;`{@linkcode module:Base~Symbol Symbol}\\|{@linkcode module:EBNF~Opt Opt}\\|{@linkcode module:EBNF~Some Some&gt;}, `prec`: {@linkcode module:EBNF~Term Term} , `expect` | {@linkcode module:EBNF~Seq#shallow shallow()}, {@linkcode module:EBNF~Seq#deep deep()}, {@linkcode module:EBNF~Seq#follow follow()}, {@linkcode module:EBNF~Seq#check check()} | {@linkcode module:EBNF~Seq#parse parse()}: `Array` | @module EBNF @see module:Base @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-12 */ import * as Base from './base.js'; /** Acts as a superclass of all elements of a grammar tree, specifies the methods to recursively check LL(1) and defines the `parse` method for terminal symbols. @mixin @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Node#follow node.follow()}. */ const Node = (superclass) =&gt; class extends superclass { #expect = new Set(); get expect () { return this.#expect; } #follow = null; /** Manage `.expect` during grammar checking: ** `shallow()` acts as getter; override to compute `.expect` from left to right as far as necessary. ** `shallow(` increment `)` acts as setter; adds to `.expect`. ** `deep()` also acts as getter, override to completely compute `.expect`. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {module:EBNF~Set} the (incremented) set, maps terminal names to true. @memberof module:EBNF~Node @instance */ shallow (increment) { if (increment instanceof Set) this.#expect.import(increment); // setter return this.#expect; // getter } /** Manage `.expect` during grammar checking: ** `shallow()` acts as getter; override to compute `.expect` from left to right as far as necessary. ** `shallow(` increment `)` acts as setter; adds to `.expect`. ** `deep()` also acts as getter, override to completely compute `.expect`. @returns {module:EBNF~Set} the set, maps terminal names to true. @memberof module:EBNF~Node @instance */ deep () { return this.#expect; } /** Manage `.follow` during grammar checking, creates initial set. ** `follow()` getter, may return `null`. ** `follow(` increment `)` setter, adds to `.follow`, creates if necessary, override to compute from right to left. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {?module:EBNF~Set} getter: the set, maps terminal names to true, setter: undefined. @memberof module:EBNF~Node @instance */ follow (increment) { // getter if (!increment) return this.#follow; // setter if (this.#follow) this.#follow.import(increment); else this.#follow = new Set().import(increment); } /** Check for ambiguity, override to report an error. @param {function} error - should be bound to {@linkcode module:Base~Factory#error grammar.error()}. @param {string} name - current rule, to label errors. @returns {undefined|string} error message, if any. @memberof module:EBNF~Node @instance */ check (error, name) { } /** Consume the current input symbol (because it is expected). This method should be redefined in all but the classes representing terminal symbols. @param {module:EBNF~Parser} parser - context. @returns {string} the input string. @throws {string} if recognition fails. @memberof module:EBNF~Node @instance */ parse (parser) { const result = parser.current.value; parser.next(this.toString()); return result; } /** Displays the same as `toString()`. @memberof module:EBNF~Node @instance */ dump () { return this.toString(); } }; /** Represents a literal symbol for EBNF. @mixes module:EBNF~Node @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Node#follow node.follow()}. @extends module:Base~Lit @property {string} name - representation for a literal. Empty string is reserved for `$eof`, the end of input. @property {boolean} used - true if used in a grammar. @property {Object} prec - precedence, only for translation to BNF. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {string} value - (unquoted) value for the literal; empty string for `$eof`. @property {boolean} [screened] - set true only during scanner construction if literal value matches a token pattern. */ class Lit extends Node(Base.Lit) { /** Creates a literal symbol for EBNF; see factory method {@linkcode module:EBNF~Grammar#lit grammar.lit()}. Sets `.expect` to contain `this`. @param {string} [literal] - a (quoted) representation for the literal. */ constructor (literal) { super(literal); this.shallow(new Set(literal)); } } /** Represents a token symbol for EBNF. @mixes module:EBNF~Node @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Node#follow node.follow()}. @extends module:Base~Token @property {string} name - name for the token. Empty string is reserved for `$error`, can be something unexpected; only for translation to BNF. @property {boolean} used - true if used in a grammar. @property {Object} prec - precedence. @property {string} [prec.assoc] - associativity, `'%left'`, `'%right'`, or `'%nonassoc'`, if any. @property {number} [prec.level] - precedence level, from 0, if any. @property {RegExp} pat - pattern for token; empty `RegExp` for `$error`. @property {Array&lt;Lit&gt;} [screen] - contains literals with values matching the pattern, if any. */ class Token extends Node(Base.Token) { /** Creates a token symbol for BNF; see factory method {@linkcode module:BNF~Grammar#token grammar.token()}. Sets `.expect` to contain `this`. @param {string} name - token name. @param {RegExp} pat - for a token. */ constructor (name, pat) { super(name, pat); this.shallow(new Set(name)); } } /** Represents a non-terminal symbol for EBNF. @property {?module:EBNF~Rule} rule - defines `this`, initially `null`. @mixes module:EBNF~Node @property {module:EBNF~Set} expect - delegated to `.rule`. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~NT#follow node.follow()}. @extends module:Base~NT @property {string} name - name for the non-terminal. */ class NT extends Node(Base.NT) { #rule = null; get rule () { return this.#rule; } set rule (rule) { this.#rule = rule; } get expect () { return this.rule.expect; } /** Creates a non-terminal symbol for BNF; see factory method {@linkcode module:EBNF~Grammar#nt grammar.nt()}. @param {string} name - non-terminal's name. */ constructor (name) { super(name); } /** Override getter: delegates to the referenced rule if any. @see {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {module:EBNF~Set} the (incremented) set, maps terminal names to true. */ shallow (increment) { return increment ? super.shallow(increment) : this.rule.shallow(); } /** Override getter: delegates to the referenced rule. @see {linkcode module:EBNF~Node#deep Node.deep(increment)}. @returns {module:EBNF~Set} the set, maps terminal names to true. */ deep () { return this.rule.deep(); } /** Override setter: sets `.rule` only if it makes a difference; i.e., recursion stops here once there is no more change. @see {linkcode module:EBNF~Node#follow Node.fallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {?module:EBNF~Set} the set, maps terminal names to true. */ follow (increment) { const old = this.rule.follow(); // getter if (!increment) return old; // setter, any change? if (!old || !old.includes(increment)) this.rule.follow(increment); } /** Delegates to the referenced rule.. @param {module:EBNF~Parser} parser - context. @returns the result produce by the referenced rule, see {@linkcode module:EBNF~Parser#parse parser.parse()}. @throws {string} if recognition fails. */ parse (parser) { return this.rule.parse(parser); } /** Displays name and contents of all sets. @returns {string} */ dump () { const result = [ ' ' + this.toString() ]; if (this.rule &amp;&amp; this.expect.length) result.push(' expect: ' + this.expect.toString()); if (this.rule &amp;&amp; this.follow() &amp;&amp; this.follow().length) result.push(' follow: ' + this.follow().toString()); return result.join('\\n'); } } /** Represents a sequence of nodes, i.e., one alternative. @property {Array&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt;} nodes - descendants, not empty, not all {@linkcode module:EBNF~Opt Opt}. @property {?module:Base~T} [terminal] - can define precedence; only for translation to BNF. @mixes module:EBNF~Node @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Seq#follow node.follow()}. */ class Seq extends Node(Object) { #nodes; get nodes () { return this.#nodes; } #terminal; get terminal () { return this.#terminal; } /** Creates a sequence of nodes, i.e., one alternative; see factory method {@linkcode module:EBNF~Grammar#seq grammar.seq()}. @param {Array&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt;} nodes - descendants, not empty, not all {@linkcode module:EBNF~Opt Opt}. @param {?module:Base~T} [terminal] - can define precedence; only for translation to BNF. */ constructor (nodes, terminal) { super(); this.#nodes = nodes; this.#terminal = terminal; } /** Override getter: computes `.expect` from left to right as far as necessary. @see {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {module:EBNF~Set} the (incremented) set, maps terminal names to true. @throws {Error} `Seq: all elements are optional` (cannot happen) */ shallow (increment) { let result = super.shallow(increment); // try to inherit getter and setter if (increment instanceof Set || // setter result.length) // getter if set before return result; // getter if not set before if (! this.nodes.some(node =&gt; { result = super.shallow(node.shallow()); // add descendant to sequence return !(node instanceof Opt); // quit on non-Opt })) throw Error('Seq: all elements are optional'); return result; } /** Override getter: computes the set from right to left, implements *optional*. @see {linkcode module:EBNF~Node#deep Node.deep(increment)}. @returns {module:EBNF~Set} the set, maps terminal names to true. */ deep () { return super.shallow( this.nodes.reduceRight((right, node) =&gt; node instanceof Opt ? right.import(node.deep()) : // add right's expect to Opt's expect new Set().import(node.deep()) // expect is! descendant's , new Set()) ); // set this expect } /** Override setter: sets me, and sets descendants, pushing from right to left; implements *optional*. @see {linkcode module:EBNF~Node#follow Node.fallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {?module:EBNF~Set} the set, maps terminal names to true. */ follow (increment) { // getter if (!increment) return super.follow(); // setter super.follow(increment); // set me this.nodes.reduceRight((follow, node) =&gt; { node.follow(follow); // set descendant const result = new Set().import(node.expect); // previous receives descendant's expect if (node instanceof Opt) result.import(follow); // and maybe follow return result; }, increment); } /** Check for ambiguity: delegate to descendants. @param {function} error - should be bound to {@linkcode module:Base~Factory#error grammar.error()}. @param {string} name - current rule. @returns {undefined|string} error message, if any. */ check (error, name) { let anyError = false; this.nodes.forEach(node =&gt; { const e = node.check(error, name); if (e) anyError = e; }); if (anyError) return anyError; } /** Recognizes a sequence of descendants; implements {@linkcode module:EBNF~Opt Opt} with a result of `null` or the collected array. @param {module:EBNF~Parser} parser - context. @returns {Array} list of results produced by the descendants, cannot be empty, see {@linkcode module:EBNF~Parser#parse parser.parse()}. @throws {string} if recognition fails. */ parse (parser) { return this.nodes.reduce((result, node) =&gt; { if (node.expect.match(parser.current)) // match? result.push(node.parse(parser)); // descend and collect result else if (node instanceof Opt) // else: optional phrase? result.push(null); // collect null else throw 'in sequence, ' + node.constructor.name + '.parse(): expects ' + node.expect.toString(); return result; // move on }, []); } /** Displays all descendants and precedence terminal, if any. @returns {string} */ toString () { return this.nodes.join(' ') + (this.terminal ? ' %prec ' + this.terminal : ''); } } /** Represents a list of one or more alternatives. Each entry is a {@linkcode Seq} representing one alternative. @property {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. @mixes module:EBNF~Node @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Alt#follow node.follow()}. */ class Alt extends Node(Object) { #seqs; get seqs () { return this.#seqs; } /** Creates a list of one or more alternatives; should only be used by subclass. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. */ constructor (seqs) { super(); this.#seqs = seqs; } /** Override getter: computes the set as sum over all descendants. @see {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {module:EBNF~Set} the (incremented) set, maps terminal names to true. */ shallow (increment) { let result = super.shallow(increment); if (increment instanceof Set || // setter result.length) // getter if set before return result; return super.shallow( // getter this.seqs.reduce((result, seq) =&gt; result.import(seq.shallow()), new Set()) ); // and set me } /** Override getter: computes the set as sum over all descendants. @see {linkcode module:EBNF~Node#deep Node.deep(increment)}. @returns {module:EBNF~Set} the set, maps terminal names to true. */ deep () { return super.shallow( // getter this.seqs.reduce((result, seq) =&gt; result.import(seq.deep()), new Set()) ); // and set me } /** Override setter: sets me and all descendants. @see {linkcode module:EBNF~Node#follow Node.fallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {?module:EBNF~Set} the set, maps terminal names to true. */ follow (increment) { // getter if (!increment) return super.follow(); // setter super.follow(increment); // set me -- could be rule involved in descendants this.seqs.forEach(seq =&gt; seq.follow(increment)); // set descendants } /** Check for ambiguity: descendants' `expect` must be disjoint. @param {function} error - should be bound to {@linkcode module:Base~Factory#error grammar.error()}. @param {string} name - current rule. @returns {undefined|string} error message, if any. */ check (error, name) { let anyError = false; const len = this.seqs.reduce((sum, seq) =&gt; { const e = seq.check(error, name); if (e) anyError = e; return sum + seq.expect.length; }, 0); if (this.expect.length != len) return error(name + ':', 'ambiguous, lookahead can select more than one alternative'); if (anyError) return anyError; } /** Recognizes one of several alternatives. @param {module:EBNF~Parser} parser - context. @returns {Array} the list produced by the selected descendant {@linkcode module:EBNF~Seq Seq}, see {@linkcode module:EBNF~Parser#parse parser.parse()}. @throws {string} if recognition fails. */ parse (parser) { const seq = this.seqs.find(seq =&gt; seq.expect.match(parser.current)); parser.grammar.assert(seq, 'Alt parse(): only expects ' + this.expect.toString()); return seq.parse(parser); } /** Displays all alternatives. @returns {string} */ toString () { return this.seqs.join(' | '); } } /** Represents an EBNF rule. @property {module:EBNF~NT} nt - rule's non-terminal (left-hand side). @property {number} recursed - counts nesting during shallow lookahead computation for all rules. @property {boolean} reached - true if rule is reached during deep lookahead computation from the start rule; avoids multiple computations. @extends module:EBNF~Alt @property {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Alt#follow node.follow()}. */ class Rule extends Alt { #nt; get nt () { return this.#nt; } #recursed = 0; get recursed () { return this.#recursed; } #reached = false; get reached () { return this.#reached; } /** Creates an EBNF rule; see {@linkcode module:EBNF~Grammar#rule rule()} factory method. @param {module:EBNF~NT} nt - left-hand side, non-terminal. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives on the right-hand side. */ constructor (nt, seqs) { super(seqs); this.#nt = nt; } /** Override getter: if left recursion returns empty set (which cannot happen...); otherwise inherits: computes the set as sum over all descendants. @see {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {module:EBNF~Set} the (incremented) set, maps terminal names to true. */ shallow (increment) { // setter if (increment instanceof Set) return super.shallow(increment); // getter, left recursive? if (this.#recursed ++) return new Set(); try { return this.shallow( // delegate to Alt super.shallow() ); // and set me } finally { -- this.#recursed; } } /** Override getter: sets `.reached`, inherits: computes the set as sum over all descendants. @see {linkcode module:EBNF~Node#deep Node.deep(increment)}. @returns {module:EBNF~Set} the set, maps terminal names to true. */ deep () { if (this.reached) return super.shallow(); // traversed before, computed by shallow this.#reached = true; // delegate to Alt return super.deep(); } /** Delegates to superclass to recognize the descendants and processes the result with the corresponding {@link module:Base~Action action} if any. The rule name selects either a `function`-valued property or a method of the `actions` object. @param {module:EBNF~Parser} parser - context. @returns the result produced by the selected descendant and modified by the action, if any, see {@linkcode module:EBNF~Parser#parse parser.parse()}. @throws {string} if recognition fails or if the action throws. */ parse (parser) { try { parser.ruleStack = this; // maintain return parser.act(this.nt.name, super.parse(parser)); // process alternatives on right-hand side } finally { parser.ruleStack = false; } } /** Displays a rule in EBNF notation. @returns {string} */ toString () { return this.nt + ': ' + super.toString() + ';'; } } /** Represents an optional list of alternatives. Note that {@linkcode module:EBNF~Seq Seq} implements *optional*. @extends module:EBNF~Alt @property {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Alt#follow node.follow()}. */ class Opt extends Alt { /** Creates an optional list of alternatives; see {@linkcode module:EBNF~Grammar#opt opt()} factory method. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. */ constructor (seqs) { super(seqs); } /** Check for ambiguity: `expect` and `follow` must be disjoint; delegate to superclass. @param {function} error - should be bound to {@linkcode module:Base~Factory#error grammar.error()}. @param {string} name - current rule. @returns {undefined|string} error message, if any. */ check (error, name) { let anyError = super.check(error, name); const overlap = this.expect.overlap(this.follow()); if (overlap.length) return error(name + ':', 'ambiguous, need not select optional part: ' + overlap.toString()); if (anyError) return anyError; } /** Displays alternatives in brackets. @returns {string} */ toString () { return '[ ' + super.toString() + ' ]'; } } /** Represents a repeatable list of alternatives. @extends module:EBNF~Alt @property {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. @property {module:EBNF~Set} expect - set of terminals which a node expects to see as {@linkcode module:EBNF~Parser parser.current.t}, maps terminal names to true; `expect` is not empty. @property {?module:EBNF~Set} follow - see {@linkcode module:EBNF~Alt#follow node.follow()}. */ class Some extends Alt { /** Creates a repeatable list of alternatives; see {@linkcode module:EBNF~Grammar#some some()} factory method. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives. */ constructor (seqs) { super(seqs); } /** Override setter: sets me, and sets descendants to my `.expect` plus `increment`. @see {linkcode module:EBNF~Node#follow Node.fallow(increment)}. @param {?module:EBNF~Set} [increment] - controls getter/setter behavior, setter adds. @returns {?module:EBNF~Set} the set, maps terminal names to true. */ follow (increment) { // getter if (!increment) return super.follow(); // setter super.follow(increment); // set me const descendants = new Set().import(increment).import(this.expect); this.seqs.forEach(seq =&gt; seq.follow(descendants)); // set descendants } /** Check for ambiguity: `expect` and `follow` must be disjoint; delegate to superclass. @param {function} error - should be bound to {@linkcode module:Base~Factory#error grammar.error()}. @param {string} name - current rule. @returns {undefined|string} error message, if any. */ check (error, name) { let anyError = super.check(error, name); const overlap = this.expect.overlap(this.follow()); if (overlap.length) return error(name + ':', 'ambiguous, need not select repeatable part: ' + overlap.toString()); if (anyError) return anyError; } /** Recognizes the descendants one or more times. @param {module:EBNF~Parser} parser - context. @returns {Array&lt;Array&gt;} list of at least one list created by a descendant {@linkcode module:EBNF~Alt Alt}, see {@linkcode module:EBNF~Parser#parse parser.parse()}. The descendants are @throws {string} if recognition fails. */ parse (parser) { const result = [ super.parse(parser) ]; while (parser.current &amp;&amp; this.expect.match(parser.current)) result.push(super.parse(parser)); return result; } /** Displays a alternatives in braces. @returns {string} */ toString () { return '{ ' + super.toString() + ' }'; } } /** Class representing a set of unique, non-empty names. @property {Object&lt;string,boolean&gt;} set - maps names to true. @property {number} length - the number of names in the set. */ class Set { #set = {}; get set () { return this.#set; } get length () { return Object.keys(this.set).length; } /** Create a set containing some unique names. @param {string[]} names - to be in the set, implied to be unique. */ constructor (...names) { names.forEach(name =&gt; this.set[name] = true); } /** Import another set. @param {module:EBNF~Set} other - to import. @returns {module:EBNF~Set} this set, changed. */ import (other) { Object.assign(this.set, other.set); return this; } /** Check if next input matches. @param {?module:Base~Tuple} tuple - next available input symbol. @returns {boolean} true if matched, false otherwise. */ match (tuple) { if (!tuple) return false; // end of input, never expected in the tree return tuple.t.name in this.set; } /** Check if this set includes another set. @param {module:EBNF~Set} other - the other set. @return {boolean} true if the other set is a subset of this set. */ includes (other) { return Object.keys(other.set).every(key =&gt; key in this.set); } /** Check if two sets overlap. @param {module:EBNF~Set} other - the other set. @return {module:EBNF~Set} the overlap, a new set, may be empty. */ overlap (other) { return Object.keys(this.set).reduce((overlap, key) =&gt; { if (key in other.set) overlap.set[key] = true; return overlap; }, new Set()); } /** Displays the elements. */ toString () { return Object.keys(this.set).join(', '); } } /** Wraps a method {@linkcode module:EBNF~Parser#parse parser.parse()} which recognizes input and builds a tree of nested lists, calls {@link module:Base~Action action functions}, if any. @property {?module:Base~Scanner} scanner - tokenizes input. @property {Array.&lt;?module:Base~Tuple&gt;} tuples - tokenized input during recognition. @property {number} index - index of next tuple during recognition. @property {?module:Base~Tuple} current - current input tuple or `null` for end of input during recognition. @property {Array&lt;?module:EBNF:Rule&gt;} ruleStack - currently activated rules during recognition. @extends module:Base~Parser @property {module:EBNF~Grammar} grammar - represents the grammar, counts errors; concurrent recognition will trash error counting. @property {?Object&lt;string, module:Base~Action&gt;} actions - maps rule names to action functions or methods during recognition. @property {?Object} data - context for all actions during recognition. @property {module:Base~Parser} data.parser - set to `this` unless already defined by caller. @property {boolean} oop - true if `.actions` is set to a singleton with {@linkcode module:Base~ClassAction ClassAction} methods. */ class Parser extends Base.Parser { #scanner; get scanner () { return this.#scanner; } #tuples = [ ]; get tuples () { return this.#tuples; } #index = 0; get index () { return this.#index; } get current () { return this.tuples[this.index]; } // can be trailing null #ruleStack = []; get ruleStack () { return this.#ruleStack; } set ruleStack (value) { if (value instanceof Rule) this.#ruleStack.push(value); else this.#ruleStack.pop(); } /** Creates a parser; see {@linkcode module:EBNF~Grammar#parser parser()} factory method. @param {module:EBNF~Grammar} grammar - represents grammar and states. @param {RegExp} [skip] - a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )`rather than `( )` for grouping. */ constructor (grammar, skip) { super(grammar); this.#scanner = grammar.scanner(skip); } /** Advances `.index` and, therefore, `.current` to the next element of `.tuples`, if any. Finds or creates `null` as `.current` to indicate end of input. Ignores illegal characters but only reports the first in a sequence. Implements lookahead trace. @param {string} caller - for trace. */ next (caller) { for (let report = true; ; report = false) { // report first illegal character only switch (this.index) { default: this.grammar.assert(this.index &lt;= this.tuples.length, 'next():', this.index, 'index out of bounds'); break; // some tuples left case this.tuples.length: // no tuples, maybe? this.tuples.push(null); // point to null as end of input throw 'no more input'; case this.tuples.length - 1: if (this.current) // at last tuple this.tuples.push(null); // add null as end of input else // at null as end of input throw 'no more input'; } ++ this.#index; // advance // trace lookahead if (this.grammar.config.lookahead) this.grammar.message(caller, 'lookahead:', this.current ? this.current.toString() : 'end of input'); // end of input or terminal symbol? if (!this.current || this.current.t) return; // illegal character if (report) this.error('illegal input character'); } } /** Recognizes an input sentence. Requires {@linkcode module:EBNF~Grammar#expect grammar.expect()}. Resets and reports `.errors` for the grammar. @param {string} input - to process. @param {Function|Object} [actions] - a function is assumed to be a class and a singleton is created with `this` as constructor argument. The object maps rule names to action methods. @param {Object} arg - used as further constructor arguments. @returns {Array|Object} the collected sequence of values or the value produced by the action of the {@link module:EBNF~Rule start rule}. The parsing methods return the following types, where `object` refers to the result produced by the {@link module:Base~Action action} of a {@link module:EBNF~Rule rule}. | class | returns | | --- | --- | | {@linkcode module:EBNF~Lit Lit} | `string` | | {@linkcode module:EBNF~Token Token} | `string` | | {@linkcode module:EBNF~Alt Alt} | `Array` | | {@linkcode module:EBNF~Opt Opt} | `null`\\|`Array` | | {@linkcode module:EBNF~Seq Seq} | `Array` | | {@linkcode module:EBNF~Some Some} | `Array`\\&lt;`Array`\\&gt; | | {@linkcode module:EBNF~Rule Rule} | `Array`\\|`object` | | {@linkcode module:EBNF~NT NT} | `Array`\\|`object` | @throws {string} error message, also reported by {@linkcode module:EBNF~Parser#error parser.error()}. */ parse (input, actions = null, ...arg) { super.parse(actions, ...arg); this.#tuples = this.scanner.scan(input); this.#index = -1; this.#ruleStack = []; // checked? if (!this.grammar.rules[0].expect.length) throw this.grammar.error('parse():', 'requires expect()'); try { if (this.grammar.config.parse) this.grammar.trace('parse'); this.next('parser'); const start = this.grammar.rules[0]; if (!start.expect.match(this.current)) // match before enter throw start.nt.name + ': expects ' + start.expect.toString(); const result = start.parse(this); // start rule if (this.current) // end of input? throw start.nt.name + ': too much input'; if (this.grammar.errors) // from actions, maybe this.grammar.message('parse():', this.grammar.errors, this.grammar.errors &gt; 1 ? 'errors' : 'error'); return result; // success } catch (e) { throw this.error(e); } finally { if (this.grammar.config.parse) this.grammar.trace('parse'); } } /** Displays a message and the rule stack, if any; lets grammar count it as an error. @param {object[]} s - message, to be displayed; prefixed by `.current` and joined by blanks. @return {string} the message. */ error (...s) { return this.grammar.error(this.index &gt;= 0 ? 'at' + ' ' + (this.current ? this.current.toString() : 'end of input') + ':' : '', s.join(' ') + (this.ruleStack.length ? ', active rules: ' + this.ruleStack.map(rule =&gt; rule.nt.name).join(' ') : '')); } } /** Represents a context-free LL(1) grammar to create recursive descent parsers. Contains factory methods to create objects to represent the grammar as a tree. &lt;p&gt;A `Grammar` object can be asked to generate [scanners](#scanner), and [parsers](#parser) to process input sentences conforming to the grammar. If a parser is called with suitable {@link module:Base~Action actions} it can transform input. @property {module:EBNF~Rule[]} rules - list of rules; rule zero is start rule. @property {string} prefix - prefix for log; assign string to push, else pop. @extends module:Base~Factory @property {Object.&lt;string, Object&gt;} config - maps names to configurable values. @property {function(string[])} config.log - function to print strings, by default `console.log`. @property {RegExp} config.lits - restricts literal representation, by default single-quoted; must be anchored. @property {RegExp} config.tokens - restricts token names, by default alphanumeric; must be anchored. @property {RegExp} config.nts - restricts non-terminal names, by default alphanumeric; must be anchored. @property {string} config.uniq - prefix for unique non-terminal names, by default `$-`. @property {boolean} config.shallow - trace lookahead during `shallow`. @property {boolean} config.deep - trace lookahead during `deep`. @property {boolean} config.follow - trace follow during `follow`. @property {boolean} config.parse - trace {@linkcode module:EBNF~Parser#parse parse()}. @property {boolean} config.lookahead - trace lookahead during {@linkcode module:EBNF~Parser#parse parse()}. @property {boolean} config.actions - trace actions, if any, during {@linkcode module:EBNF~Parser#parse parse()}. @property {Array&lt;module:Base~Lit&gt;} lits - list of unique literals, can be pushed. @property {Object.&lt;string, module:Base~Lit&gt;} litsByName - maps `'x'` to unique literal. @property {Array&lt;module:Base~Token&gt;} tokens - list of unique tokens, can be pushed. @property {Object.&lt;string, module:Base~Token&gt;} tokensByName - maps name to unique token. @property {Array&lt;module:Base~Precedence&gt;} levels - list of precedence levels, can be pushed. @property {Array&lt;module:Base~NT&gt;} nts - list of unique non-terminals, can be pushed. @property {Object.&lt;string, module:Base~NT&gt;} ntsByName - maps name to unique non-terminal. @property {number} errors - incremented by {@linkcode module:Base~Factory#error error()} method. */ class Grammar extends Base.Factory { #rules = []; get rules () { return this.#rules; } #prefix = []; get prefix () { return this.#prefix.length &lt; 2 ? (this.#prefix.length ? this.#prefix[0] : '') : ' '.padEnd(2 * (this.#prefix.length - 1), ' ') + this.#prefix.at(-1); } set prefix (prefix) { if (typeof prefix == 'string') this.#prefix.push(prefix); else this.#prefix.pop(); } /** Creates a grammar representation. Defines tokens, if any. @param {?string} [grammar] - the grammar to represent, using the {@link module:EBNF~Grammar.ebnf EBNF grammar} and {@link module:EBNF~Grammar.terminals EBNF token and literal notation}. This can be omitted to construct the rules directly using the factory methods. @param {?Object.&lt;string, RegExp&gt;} [tokens] - maps token names, if any, in the new grammar to their patterns which must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, and should use `(:? )`rather than `( )` for grouping. `tokens` can map the empty string to a skip pattern which will be used to interpret the grammar string. @param {Object.&lt;string, Object&gt;} [config] - overwrites configurable values' defaults; loaded first but can only be third parameter. */ constructor (grammar = '', tokens = {}, config = {}) { super(); // load configuration, if any if (typeof config == 'object' &amp;&amp; config !== null) Object.assign(this.config, config); // compile grammar into this? if (typeof grammar == 'string') { // default skip pattern let skip = /\\s+/; // load tokens, [''] is skip if (typeof tokens == 'object' &amp;&amp; tokens !== null) { if ('' in tokens) { skip = tokens['']; this.assert(skip instanceof RegExp, 'new Grammar():', skip, 'not a pattern'); delete tokens['']; } this.add(tokens); } // need to send output to the new config Grammar.grammar.config.log = this.config.log; // compile grammar Grammar.grammar.parser(skip).parse(grammar, new Actions(this)); // only load tokens (from grammar) } else if (typeof grammar == 'object' &amp;&amp; grammar !== null) { delete grammar['']; // if any this.add(grammar); // i.e., the token definitions if any } } /** Computes the `expect` sets; only call once. ** Does not permit precedences. ** There has to be at least one rule. ** All non-terminals must be defined, each by a unique rule. ** Detects left recursion as an error. ** Computes `expect` for each node; a non-terminal obtains it from the rule. ** All rules must be necessary, i.e., reachable from the first rule. @returns {undefined|string} an error message on failure. */ expect () { // already computed? if (this.rules[0].expect.length) return this.error('expect():', 'already called'); // precedences? if (this.levels.length) return this.error('check():', 'no precedences for recursive descent'); // all non-terminals defined? if (!this.rules.length) return this.error('expect():', 'no rules'); if (this.rules.length &gt; this.nts.length) return this.error('expect():', 'duplicate rule definition(s)'); if (this.rules.length &lt; this.nts.length) return this.error('expect():', this.nts.filter(nt =&gt; !nt.rule).map(nt =&gt; nt.name).join(', ') + ': undefined'); // set expect in each rule -- finds left recursion try { if (this.config.shallow) this.trace('shallow'); this.rules.forEach(rule =&gt; rule.shallow()); const bad = this.rules.filter(rule =&gt; rule.recursed).map(rule =&gt; rule.nt.name); if (bad.length) return this.error('expect():', bad.join(', ') + ': left recursive'); } finally { if (this.config.shallow) this.trace('shallow'); } // set expect everywhere -- finds non-reachable rules try { if (this.config.deep) this.trace('deep'); this.rules[0].deep(); const bad = this.rules.filter(rule =&gt; !rule.reached).map(rule =&gt; rule.nt.name); if (bad.length) return this.error('expect():', bad.join(', ') + ': not reached'); } finally { if (this.config.deep) this.trace('deep'); } } /** Checks the grammar to be LL(1). ** Calls {@linkcode module:EBNF~Grammar#expect expect()} if necessary. ** Computes `follow` for each node; a non-terminal obtains it from the rule. ** Detects ambiguities. @returns {udefined|string} an error message on failure. */ check () { // expect computed? if (!this.rules[0].expect.length) { const e = this.expect(); if (e) return e; } // need to compute follow? if (this.rules[0].follow() === null) // set follow everywhere try { if (this.config.follow) this.trace('follow'); this.rules[0].follow(new Set()); } finally { if (this.config.follow) this.trace('follow'); } // errors? if (this.errors) return; // check each rule for ambiguities const error = this.constructor.prototype.error.bind(this); if (this.rules.reduce((errors, rule) =&gt; rule.check(error, rule.nt.name) ? ++ errors : errors, 0)) return this.message('check():', 'found ambiguities'); } /** Installs and removes trace wrappers for grammar checking and `parse` methods; controlled by the configuration flags `shallow`, `deep`, `follow`, and `parse`, should only be called by {@linkcode module:EBNF~Grammar#expect expect()} and {@linkcode module:EBNF~Parser#parse parser.parse()}. &lt;p&gt;The tracing wrappers use `.config.log` and `.prefix`. &lt;p&gt;Grammar checking and `parse` methods are cached in {@linkcode module:EBNF~Grammar.tracing Grammar.tracing} globally per method and class. @param {string} what - one of `shallow`, `deep`, `follow`, or `parse` to trace that algorithm. */ trace (what) { const self = this; // closure const classes = [ Rule, Some, Opt, Alt, Seq, NT, Lit, Token ]; if (!/^(?:parse|shallow|deep|follow)$/.test(what)) return; if (what in Grammar.tracing) { // turn method tracing off classes.reverse().forEach(cls =&gt; { // for each class... if (cls.name in Grammar.tracing[what]) // ...which was traced // restore method cls.prototype[what] = Grammar.tracing[what][cls.name]; }); classes.reverse(); // undo reverse order delete Grammar.tracing[what]; // delete cache } else { // turn method tracing on Grammar.tracing[what] = {}; // create cache classes.forEach(cls =&gt; { // for each class... if (what in cls.prototype) { // ...which has the method Grammar.tracing[what][cls.name] = cls.prototype[what]; // cache switch (what) { case 'shallow': // trace getter case 'deep': cls.prototype[what] = // replace method function (set) { try { const label = (this.constructor.name == cls.name ? cls.name : 'super') + (cls == Rule ? '' : '(' + this.toString() + ')'); if (cls == Rule) self.prefix = this.nt.name; // prefix for messages if (!(set instanceof Set)) // trace getter only self.config.log(self.prefix + '|', label, what, '{'); const result = Grammar.tracing[what][cls.name].call(this, set); if (!(set instanceof Set)) self.config.log(self.prefix + '|', label, what, '}:', result.toString()); return result; } finally { if (cls == Rule) self.prefix = false; } }; break; case 'follow': // trace setter cls.prototype[what] = // setter replace method function (set) { try { const label = (this.constructor.name == cls.name ? cls.name : 'super') + (cls == Rule ? '' : '(' + this.toString() + ')'); if (cls == Rule) self.prefix = this.nt.name; // prefix for messages if (set instanceof Set) // trace setter only self.config.log(self.prefix + '|', label, what + '(' + set.toString() + ')', '{'); const result = Grammar.tracing[what][cls.name].call(this, set); if (set instanceof Set) // call getter for display self.config.log(self.prefix + '|', label, what, '}:', Grammar.tracing[what][cls.name].call(this).toString()); return result; } finally { if (cls == Rule) self.prefix = false; } }; break; case 'parse': // trace call and result cls.prototype[what] = // replace method function (context) { try { const label = (this.constructor.name == cls.name ? cls.name : 'super') + (cls == Rule ? '' : '(' + this.toString() + ')'); if (cls == Rule) self.prefix = this.nt.name; // prefix for messages self.config.log(self.prefix + '|', label, what, '{'); const result = Grammar.tracing[what][cls.name].call(this, context); self.config.log(self.prefix + '|', label, what, '}:', self.dump(result)); return result; } finally { if (cls == Rule) self.prefix = false; } }; break; } } }); } } /** Factory method to create a unique literal symbol, maintains `.lits` and `.litsByName` @param {string} literal - literal's representation conforming to `.config.lits`. @param {boolean} [used] - if `true` mark literal as used. @returns {module:EBNF~Lit} a unique literal. */ lit (literal, used) { // return existing literal? let lit = this.litsByName[literal]; if (! lit) { // create new literal lit = new Lit(literal); this.add(lit); } if (used) lit.used = true; return lit; } /** Factory method to create a unique token symbol, maintains `.tokens` and `.tokensByName`. @param {string} [name] - token's name conforming to `.config.tokens`; error if a non-terminal. If omitted represents the `$error` token with an empty `RegExp` (intended for BNF translation). @param {RegExp} [pat] - pattern to match values representing the token in input; used only when the token is created, must not accept empty input, must not use `d`, `g`, or `y` flag, should not be anchored, should use `(:? )`rather than `( )` for grouping. @param {boolean} [used] - if `true` mark token as used. @returns {module:EBNF~Token} a unique token. */ token (name = '', pat, used) { // return existing token? let token = this.tokensByName[name]; if (! token) { // don't allow non-terminal if (name != '' &amp;&amp; name in this.ntsByName) this.error(name, 'is already defined as a non-terminal'); // create new token token = new Token(name, name.length ? pat : new RegExp()); this.add(token); } if (used) token.used = true; return token; }; /** Factory method to create a unique non-terminal symbol, maintains `.nts` and `.ntsByName`. @param {string} [name] - non-terminal's name conforming to `config.nts`; error if a token. If not a string creates a unique name (intended for grammar extension). @returns {module:EBNF~NT} a unique non-terminal. */ nt (name) { // unique name? if (typeof name != 'string') name = this.config.uniq + this.nts.length; // return existing non-terminal? let nt = this.ntsByName[name]; if (! nt) { // don't allow token if (name != '' &amp;&amp; name in this.tokensByName) this.error(name, 'is already defined as a token'); // create new non-terminal nt = new NT(name); this.add(nt); } return nt; } /** Factory method to create a rule representation for EBNF. Maintains rule's non-terminal's `.rule` and `this.rules`. @param {module:EBNF~NT} nt - left-hand side, non-terminal. @param {module:EBNF~Seq[]} seqs - right-hand side, list of alternative sequences. @returns {module:EBNF~Rule} a new rule representation. */ rule (nt, ...seqs) { this.assert(nt instanceof NT, 'rule():', nt, 'not a non-terminal'); this.assert(seqs instanceof Array &amp;&amp; seqs.length &amp;&amp; seqs.every(s =&gt; s instanceof Seq), 'rule():', seqs, 'not a non-empty list of Seq'); if (nt.rule) this.error(nt.toString(), ': duplicate definition'); // create new rule const rule = new Rule(nt, seqs); // add new rule to rule's nt's rules and this.rules rule.nt.rule = rule; this.rules.push(rule); return rule; } /** Factory method to represent a sequence of nodes for EBNF. Precedence levels have to be defined prior to using this method. @param {Array&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt;} nodes - descendants, not empty, not all {@linkcode module:EBNF~Opt Opt}. @param {?module:Base~T} [terminal] - can define precedence for translation to BNF. @returns {module:EBNF~Seq} a new sequence. */ seq (nodes, terminal = null) { this.assert(nodes instanceof Array &amp;&amp; nodes.length &amp;&amp; nodes.every(n =&gt; n instanceof Base.Symbol || n instanceof Opt || n instanceof Some), 'seq():', nodes, 'not a non-empty list of symbols, Opt, or Some'); this.assert(nodes.some(n =&gt; !(n instanceof Opt)), 'seq():', nodes, 'list only contains Opt'); this.assert(terminal === null || terminal instanceof Base.T, 'seq():', terminal, 'not a terminal'); // create new sequence return new Seq(nodes, terminal); } /** Factory method to represent a list of alternatives for EBNF. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives, not empty. @returns {module:EBNF~Alt} a new list of alternatives. */ alt (...seqs) { this.assert(seqs instanceof Array &amp;&amp; seqs.length &amp;&amp; seqs.every(s =&gt; s instanceof Seq), 'alt():', seqs, 'not a non-empty list of Seq'); return new Alt(seqs); } /** Factory method to represent an optional list of alternatives for EBNF. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives, not empty. @returns {module:EBNF~Opt} a new optional list of alternatives. */ opt (...seqs) { this.assert(seqs instanceof Array &amp;&amp; seqs.length &amp;&amp; seqs.every(s =&gt; s instanceof Seq), 'opt():', seqs, 'not a non-empty list of Seq'); return new Opt(seqs); } /** Factory method to represent a repeatable list of alternatives for EBNF. @param {Array&lt;module:EBNF~Seq&gt;} seqs - the alternatives, not empty. @returns {module:EBNF~Opt} a new repeatable list of alternatives. */ some (...seqs) { this.assert(seqs instanceof Array &amp;&amp; seqs.length &amp;&amp; seqs.every(s =&gt; s instanceof Seq), 'some():', seqs, 'not a non-empty list of Seq'); return new Some(seqs); } /** Factory method to create a parser to recognize and process input. Requires that the {@link module:EBNF~Grammar#expect expect sets} for this grammar have been prepared. @param {RegEx} [skip] - a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use flags, must not be anchored, should use `(:? )`rather than `( )` for grouping. @returns {module:EBNF~Parser} the parser. */ parser (skip = new RegExp('\\\\s+')) { // /\\s+/ crashes jsdoc this.assert(this.rules[0].expect.length, 'parser():', this, 'has not been checked'); this.assert(skip instanceof RegExp, 'parser():', skip, 'not a regular expression'); return new Parser(this, skip); } /** Displays a description of the grammar. @returns {string} */ toString () { const result = []; if (this.levels.length) result.push(... this.levels.map(level =&gt; ' ' + level.toString()), ''); if (this.rules.length) result.push(... this.rules.map((rule, n) =&gt; (' ' + n).substr(-3) + ' ' + rule.toString()), ''); result.push('literals: ' + this.lits.filter(lit =&gt; lit.used).join(', ')); result.push('tokens: ' + this.tokens.filter(token =&gt; token.used).join(', ')); if (this.errors) result.push('', 'errors: ' + this.errors); return result.join('\\n'); } /** Displays the grammar and all symbols with name and contents of all sets. With argument (kludge!) acts as a static method and converts nested arrays to a string – useful because `console.debug` only reaches 3 levels. @param {?Object} [a] - the object to convert to a string. @returns {string} */ dump (a) { // kludge part if (arguments.length) return super.dump(a); const result = []; if (this.levels.length) result.push(... this.levels.map(level =&gt; ' ' + level.toString()), ''); if (this.rules.length) result.push(... this.rules.map((rule, n) =&gt; (' ' + n).substr(-3) + ' ' + rule.toString()), ''); result.push('literals: ' + this.lits.join(', ')); result.push('tokens: ' + this.tokens.map(token =&gt; token + ' ' + token.pat).join(', ')); result.push('non-terminals:', ...this.nts.map(nt =&gt; nt.dump())); if (this.errors) result.push('', 'errors: ' + this.errors); return result.join('\\n'); } } /** * Common method cache for tracing grammar checking and parsing. * `cls.prototype.method` is cached as `Grammar.tracing[method][cls.name]`. * If `Grammar.tracing[method]` exists, tracing can only be turned off * and vice versa. * &lt;p&gt;Tracing grammar checking and parsing is static, * i.e., common to all grammars that might be created, * because the methods themselves are common to all grammars. * @static * @type {Object&lt;string,Object&lt;string, function&gt;&gt;} */ Grammar.tracing = { }; /** * Grammar describing the EBNF notation accepted by {@linkcode module:EBNF~Grammar new Grammar()}: * &lt;p&gt; A *grammar* consists of one or more rules. * &lt;p&gt; Each *rule* has a unique name on the left-hand side and alternatives * on the right-hand side * * &lt;p&gt; *Alternatives* are one or more symbol sequences, separated by `|`. * &lt;p&gt; A *symbol sequence* contains one or more items, such as a rule name, * a self-defining {@link module:EBNF~Grammar.terminals literal}, * the name of a {@link module:EBNF~Grammar.terminals token}, * or alternatives enclosed by braces or brackets. * &lt;p&gt; Braces denote that the enclosed alternatives appear * one or more times in a sentence. * &lt;p&gt; Brackets denote that the enclosed alternatives are optional, * i.e., they may or may not appear (once) in a sentence. * A symbol sequence must not only contain optional alternatives. * @example &lt;caption&gt; EBNF grammars' grammar &lt;/caption&gt; * grammar: [{ level }] { rule }; * level: '%left' { term } ';' | * '%right' { term } ';' | * '%nonassoc' { term } ';'; * rule: Token ':' alt ';'; * alt: seq [{ '|' seq }]; * seq: { lit | ref | opt | some } [ '%prec' term ]; * term: lit | ref; * lit: Lit; * ref: Token; * opt: '[' alt ']'; * some: '{' alt '}'; * @constant {string} */ Grammar.ebnf = [ \"grammar: [{ level }] { rule };\", \"level: '%left' { term } ';' |\", \" '%right' { term } ';' |\", \" '%nonassoc' { term } ';';\", \"rule: Token ':' alt ';';\", \"alt: seq [{ '|' seq }];\", \"seq: { lit | ref | opt | some } [ '%prec' term ];\", \"term: lit | ref;\", \"lit: Lit;\", \"ref: Token;\", \"opt: '[' alt ']';\", \"some: '{' alt '}';\" ].join('\\n'); /** * Token definitions for `Lit` and `Token` * in {@linkcode module:EBNF~Grammar.ebnf Grammar.ebnf}. * &lt;p&gt; *Literals* represent themselves and are single-quoted strings * using `\\` only to escape single quotes and `\\` itself. * &lt;p&gt; *Tokens* represent sets of inputs, such as names or numbers, * and are alphanumeric names which must start with a letter * and may include underscores. * &lt;p&gt;A `Name` can include `$error` for {@link module:BNF~Grammar.fromEBNF translation to BNF}. * @example &lt;caption&gt; EBNF grammars' tokens &lt;/caption&gt; * { * Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, * Token: /[A-Za-z][A-Za-z0-9_]*|\\$error/ * } * @see {@linkcode module:EBNF~Grammar.grammar Grammar.grammar} * @constant {Object&lt;string,RegExp&gt;} */ Grammar.terminals = { Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, Token: /[A-Za-z][A-Za-z0-9_]*|\\$error/ }; /** * The EBNF grammars' grammar; created when the module is loaded * and used internally in {@linkcode module:EBNF~Grammar new Grammar()}. * @see {@linkcode module:EBNF~Actions Actions} * @constant {module:EBNF~Grammar} * @private */ Grammar.grammar = new Grammar(Grammar.terminals); { // grammar: [{ level }] { rule }; Grammar.grammar.rule(Grammar.grammar.nt('grammar'), Grammar.grammar.seq([ Grammar.grammar.opt( Grammar.grammar.seq([ Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('level') ], null) ) ], null) ), Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('rule') ], null) ) ], null) ); // level: '%left' { term } ';' | '%right' { term } ';' | '%nonassoc' { term } ';'; Grammar.grammar.rule(Grammar.grammar.nt('level'), Grammar.grammar.seq([ Grammar.grammar.lit(\"'%left'\"), Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('term') ], null) ), Grammar.grammar.lit(\"';'\") ], null), Grammar.grammar.seq([ Grammar.grammar.lit(\"'%right'\"), Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('term') ], null) ), Grammar.grammar.lit(\"';'\") ], null), Grammar.grammar.seq([ Grammar.grammar.lit(\"'%nonassoc'\"), Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('term') ], null) ), Grammar.grammar.lit(\"';'\") ], null) ); // rule: Token ':' alt ';'; Grammar.grammar.rule(Grammar.grammar.nt('rule'), Grammar.grammar.seq([ Grammar.grammar.token('Token'), Grammar.grammar.lit(\"':'\"), Grammar.grammar.nt('alt'), Grammar.grammar.lit(\"';'\") ], null) ); // alt: seq [{ '|' seq }]; Grammar.grammar.rule(Grammar.grammar.nt('alt'), Grammar.grammar.seq([ Grammar.grammar.nt('seq'), Grammar.grammar.opt( Grammar.grammar.seq([ Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.lit(\"'|'\"), Grammar.grammar.nt('seq') ], null) ) ], null) ) ], null) ); // seq: { lit | ref | opt | some } [ '%prec' term ]; Grammar.grammar.rule(Grammar.grammar.nt('seq'), Grammar.grammar.seq([ Grammar.grammar.some( Grammar.grammar.seq([ Grammar.grammar.nt('lit') ], null), Grammar.grammar.seq([ Grammar.grammar.nt('ref') ], null), Grammar.grammar.seq([ Grammar.grammar.nt('opt') ], null), Grammar.grammar.seq([ Grammar.grammar.nt('some') ], null) ), Grammar.grammar.opt( Grammar.grammar.seq([ Grammar.grammar.lit(\"'%prec'\"), Grammar.grammar.nt('term') ], null) ) ], null) ); // term: lit | ref; Grammar.grammar.rule(Grammar.grammar.nt('term'), Grammar.grammar.seq([ Grammar.grammar.nt('lit') ], null), Grammar.grammar.seq([ Grammar.grammar.nt('ref') ], null) ); // lit: Lit; Grammar.grammar.rule(Grammar.grammar.nt('lit'), Grammar.grammar.seq([ Grammar.grammar.token('Lit') ], null) ); // ref: Token; Grammar.grammar.rule(Grammar.grammar.nt('ref'), Grammar.grammar.seq([ Grammar.grammar.token('Token') ], null) ); // opt: '[' alt ']'; Grammar.grammar.rule(Grammar.grammar.nt('opt'), Grammar.grammar.seq([ Grammar.grammar.lit(\"'['\"), Grammar.grammar.nt('alt'), Grammar.grammar.lit(\"']'\") ], null) ); // some: '{' alt '}'; Grammar.grammar.rule(Grammar.grammar.nt('some'), Grammar.grammar.seq([ Grammar.grammar.lit(\"'{'\"), Grammar.grammar.nt('alt'), Grammar.grammar.lit(\"'}'\") ], null) ); // all but $error are used Grammar.grammar.lits.forEach(lit =&gt; lit.used = true); Grammar.grammar.tokens.forEach(token =&gt; { if (token.name.length) token.used = true; }); Grammar.grammar.check(); } /** The EBNF grammar parser's actions, used internally in {@linkcode module:EBNF~Grammar new Grammar()}. @property {module:EBNF~Grammar} g - the grammar to add precedences and rules to. @private */ class Actions { #g; get g () { return this.#g; } /** Creates the singleton with the {@link module:Base~Action action methods}. @param {module:EBNF~Grammar} g - to hold the rule representations. */ constructor (g) { this.#g = g; } /** `grammar: [{ level }] { rule };` @returns {module:EBNF~Grammar} represents the grammar, not yet checked. */ grammar (l, r) { return this.g; } /** `level: '%left' { term } ';' | '%right' { term } ';' | '%nonassoc' { term } ';';` @returns {module:Base~Precedence} represents a precedence level. */ level (assoc, some, _) { return this.g.precedence(assoc, some.flat()); } /** `rule: Token ':' alt ';';` @returns {module:EBNF~Rule} represents a rule. */ rule (name, _, alt, s) { return this.g.rule(this.g.nt(name), ...alt.seqs); } /** `alt: seq [{ '|' seq }];` @returns {module:EBNF~Alt} represents a list of one or more alternatives. */ alt (seq, many) { return many ? this.g.alt(seq, ... many.flat(1).map(elt =&gt; elt[1])) : this.g.alt(seq); } /** `seq: { lit | ref | opt | some } [ '%prec' term ];` @returns {module:EBNF~Seq} represents a list of one or more items. */ seq (some, opt) { if (some.flat().every(node =&gt; node instanceof Opt)) throw this.g.error(some.flat().join(', ') + ': all sequence elements are optional'); if (opt) { if (opt[1] instanceof Base.T) return this.g.seq(some.flat(), opt[1]); this.g.error(this.g.dump(opt[1]) + ': not a terminal'); } return this.g.seq(some.flat(), null); } /** `term: lit | ref;` @returns {module:EBNF~Lit|module:EBNF~Token|module:EBNF~NT} represents a symbol. */ term (term) { return term; } /** `lit: Lit;` @returns {module:EBNF~Lit} represents a used literal. */ lit (literal) { return this.g.lit(literal, true); } /** `ref: Token;` @returns {module:EBNF~Token|module:EBNF~NT} represents a used token or a non-terminal. */ ref (name) { if (name == '$error') return this.g.token('', new RegExp(), true); if (name in this.g.tokensByName) return this.g.token(name, undefined, true); return this.g.nt(name); } /** `opt: '[' alt ']';` @returns {module:EBNF~Opt} represents an optional list of one or more alternatives. */ opt (lb, alt, rb) { return this.g.opt(...alt.seqs); } /** `some: '{' alt '}';` @returns {module:EBNF~Some} represents a list of one or more alternatives. */ some (lb, alt, rb) { return this.g.some(...alt.seqs); } } /** Might publish inner classes for tests fudge: function (ebnf) { ebnf.Alt = Alt; ebnf.Lit = Lit; ebnf.NT = NT; ebnf.Opt = Opt; ebnf.Parser = Parser; ebnf.Rule = Rule; ebnf.Seq = Seq; ebnf.Set = Set; ebnf.Some = Some; ebnf.Token = Token; } */ export { Grammar, Actions, }; × Search results Close "},"08.js.html":{"id":"08.js.html","title":"Source: 08.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 08.js /** This module contains the classes for all examples in chapter eight. @module Eight @author © 2024 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-06-24 */ import * as Seven from './07.js'; /** [Example 8/01](../?eg=08/01): adds support for global higher-order functions. @mixin */ const Machine01 = superclass =&gt; class extends superclass { /** `stack: ... addr -&gt; ... old-pc | pc: addr` @instance @memberof module:Eight~Machine01 */ CallValue (memory) { memory.pc = memory.splice(-1, 1, memory.pc)[0]; } /** `stack: ... x-len n*val -&gt; ... n*val x-len` @instance @memberof module:Eight~Machine01 */ Rotate (n, len = 1) { return memory =&gt; memory.push(... memory.splice(- n - len, len)); } }; /** [Example 8/01](../?eg=08/01): adds actions and infrastructure to compile global higher-order functions. @mixin */ const Global01 = superclass =&gt; class extends superclass { /** Describes a type. @class @extends super.Symbol @instance @memberof module:Eight~Global01 @property {?Array&lt;String|Type&gt;} parms - null for scalar, else list of parameter types. @property {String|Type} returns - null or result type. @property {Boolean} isFun - `true` if function type. @property {function} toString() - represents as text. */ get Type () { return this.#Type ??= class extends super.Symbol { parms = []; // list of parameter types, `null` for 'number' returns; // result type if any get isFun () { return this.parms !== null; } constructor (owner, name, parms, returns) { super(owner, name); this.parms = parms; this.returns = returns; } toString () { const name = t =&gt; typeof t == 'string' ? t : t.name; return `type ${this.name}` + (!this.isFun ? '' : `(${this.parms.map(name).join(', ')})` + (this.returns ? `: ${name(this.returns)}` : '')); } }; } #Type; /** Type table, maps names to descriptions. @instance @memberof module:Eight~Global01 */ get typeSymbols () { return this.#typeSymbols; } #typeSymbols = new Map(); /** Predefined type descriptor for `number`. @constant {Type} @instance @memberof module:Eight~Global01 */ get numberType () { return this.#numberType; } #numberType; /** Predefined type descriptor for `main (): number`. @constant {Type} @instance @memberof module:Eight~Global01 */ get mainType () { return this.#mainType; } #mainType; /** Describes a function in {@linkcode module:Eight~Global01 Global01}. @class @extends super.Fun @instance @memberof module:Eight~Global01 @property {Type} type - function's type. @property {number[]} loads - slots to insert `Push start`. @property {function} setParms() - [replace] set/check types. @property {function} load() - generates `Push(start)`. @property {function} storeOk() - [extend] check type. @property {function} end() - [extend] fixes `loads` @property {function} toString() - [extend] shows type, if any. */ get Fun () { return this.#Fun ??= class extends super.Fun { type; // function's type loads = []; // forward references to push setParms (name) { // [replace] sets parameter types this.parms = this.locals.size; // may be wrong, see below this.size += 2; // leave room for old pc and old fp this.addr = this.size ++; // leave slot for result try { const type = this.owner.typeSymbols.get(name); if (!type) throw `${name}: not a type`; if (!type.isFun) throw `${name}: not a function type`; if (this.type &amp;&amp; this.type != type) throw `${name} ${this.name}: ` + `previously declared as ${this.type.name}`; if (type.parms.length != this.locals.size) throw `${name} ${this.name} arguments: expects ` + `${type.parms.length}, receives ${this.locals.size}`; this.type = type; let n = 0; // Map.forEach does not provide n this.locals.forEach(parm =&gt; parm.type = type.parms[n ++]); } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(e); // report an error } } load () { // generates 'Push start' if (typeof this.start == 'number') this.owner.machine.gen('Push', this.start); else this.loads.push(this.owner.machine.code.push(null) - 1); } storeOk (type) { // [extend] checks type try { if (this.type.returns) { // return value expected? if (!type) // no return value? throw `must return ${this.type.returns}`; else if (this.type.returns != type) // wrong type? throw `expects ${this.type.returns}, not ${type}`; } else if (type) // return value not expected? throw `doesn't return a value`; return super.storeOk(); // inside function? } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(`${this.name}: ${e}`); return false; } } end () { // [extend] resolves loads const push = this.owner.machine.ins('Push', this.start); this.loads.forEach(p =&gt; this.owner.machine.code[p] = push); this.loads.length = 0; super.end(); } toString () { // [extend] shows type, if any return this.type ? `${this.type.name} ${super.toString()}` : super.toString(); } }; } #Fun; /** Describes a variable in {@linkcode module:Eight~Global01 Global01}. @class @extends super.Var @instance @memberof module:Eight~Global01 @property {Type} type - variable's type. @property {function} storeOk() - [replace] check type. @property {function} call() - code call to value @property {function} toString() - [extend] show type, if any. */ get Var () { return this.#Var ??= class extends super.Var { type; // variable's type storeOk (type) { // [replace] check type if (this.type == type) return true; this.owner.parser.error(`${this.name}: ` + `expects ${this.type}, not ${type}`); return false; } call () { this.load(); this.owner.machine.gen('CallValue'); } toString () { // [extend] show type, if any return this.type ? `${this.type.name} ${super.toString()}` : super.toString(); } }; } #Var; constructor (parser, machine) { super(parser, machine ?? new (Machine01(Seven.Machine06))()); this.typeSymbols.set('number', this.#numberType = new this.Type(this, 'number', null, null)); this.typeSymbols.set('main', this.#mainType = new this.Type(this, 'main', [ ], this.numberType)); } /** `prog: [ typedcls ] [ vars ] funs;` @instance @memberof module:Eight~Global01 */ prog (t, v, f) { return this.parser.call(this, super.prog, t, f); } /** `typedcls: { 'type' typedcl [{ ',' typedcl }] ';' };` checks and translates the types @instance @memberof module:Eight~Global01 */ typedcls (some) { this.typeSymbols.forEach(sym =&gt; { // check and translate types if (sym.isFun) { // avoid non-functions const check = name =&gt; { // return type description for name const type = this.typeSymbols.get(name); if (type) return type; this.parser.error(`${name}: not a type`); return this.numberType; // patch }; sym.parms = sym.parms.map(check); // convert to symbols if (typeof sym.returns == 'string') sym.returns = check(sym.returns); } }); } /** `typedcl: Name '(' [ types ] ')' [ ':' typename ];` declares @instance @memberof module:Eight~Global01 */ typedcl (name, lp, types, rp, returns) { if (this.typeSymbols.get(name)) this.parser.error(`${name}: duplicate type`); else this.typeSymbols.set(name, new this.Type(this, name, types ? types[0] : [], returns ? returns[1] : null)); } /** `types: typename [{ ',' typename }];` returns list @instance @memberof module:Eight~Global01 */ types (typename, many) { return [ typename ]. concat(many ? many[0].map(list =&gt; list[1]) : []); } /** `typename: Name | 'number';` returns name or 'number' @instance @memberof module:Eight~Global01 */ typename (name) { return name; } // vars: 'var' varname [{ ',' varname }] ';'; /** `varname: Name [ ':' type ];` declares the name. Can be used with one or two arguments, defaults to `number`. @instance @memberof module:Eight~Global01 */ varname (...arg) { let [ name, type ] = arg; type = type ? type[1] : this.numberType; this._dcl(this._alloc(name), true).type = type; } /** `type: Name | 'number';` returns type symbol @instance @memberof module:Eight~Global01 */ type (name) { const type = this.typeSymbols.get(name); if (type) return type; this.parser.error(`${name}: not a type`); return this.numberType; } // names: Name [{ ',' Name }]; // funs: { fun }; // fun: head parms [ block ] ';'; // head: 'function' Name; /** `parms: '(' [ names ] ')' [ ':' Name ];` declares @instance @memberof module:Eight~Global01 */ parms (lp, names, rp, name) { // funtion's name is default type this.funct.setParms(name ? name[1] : this.funct.name); } // block: begin [ vars ] stmts 'end'; // begin: 'begin'; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | block | loop | select; // assign: symbol action; // action: store | call; /** `store: '=' sum;` expects context, codes assignment @instance @memberof module:Eight~Global01 */ store (_, sum) { if (this.context.symbol.storeOk(sum)) this.context.symbol.store(); } // call: { args }; /** `args: '(' [ sums ] ')';` codes call, chains context @instance @memberof module:Eight~Global01 */ args (lp, sums, rp) { const args = sums === null ? [ ] : sums[0]; // list of types const type = 'type' in this.context ? // chained call if true this.context.type : this.context.symbol.type; try { if (!type) throw 'too many argument lists'; if (!type.isFun) throw 'not a function'; if (type.parms.length != args.length) throw `arguments: ${type.parms.length} expected, ` + `${args.length} specified`; const errors = []; type.parms.forEach( (parm, n) =&gt; { if (parm != args[n]) errors.push( `argument ${n+1} is ${args[n].toString()}, ` + `not ${parm.toString()}` ); }); if (errors.length) throw errors.join('; '); if ('type' in this.context) { // chained call this._lift(args); // move function address past arguments this.machine.gen('CallValue'); // call address on stack } else this.context.symbol.call(); // call function/variable } catch (e) { if (e instanceof Error) throw e; // should not happen this.parser.error(`call to ${this.context.symbol.name}: ${e}`); } this.context.type = type ? type.returns : null; // result type } /** Move function address past arguments to the top of the stack. @param {Type[]} args - list of argument types. @instance @memberof module:Eight~Global01 */ _lift (args) { if (args.length) this.machine.gen('Rotate', args.length); } /** `print: 'print' sums;` checks types @instance @memberof module:Eight~Global01 */ print (p, sums) { if (!sums.every(sum =&gt; sum == this.numberType)) this.parser.error('can only print numbers'); this.parser.call(this, super.print, p, sums.length); } /** `sums: sum [{ ',' sum }];` returns list of types @instance @memberof module:Eight~Global01 */ sums (sum, many) { return [ sum ]. concat(many ? many[0].map(list =&gt; list[1]) : []); } /** `return: 'return' [ sum ];` @instance @memberof module:Eight~Global01 */ return (_, sum) { if (this.funct.storeOk(sum ? sum[0] : null)) if (sum) (this.funct.store(), this.machine.gen('Pop')); this.funct.return(); } // loop: While cmp Do [ vars ] stmts 'od'; // While: 'while'; // Do: 'do'; // select: 'if' cmp then [ else ] 'fi'; // then: Then [ [ vars ] stmts ]; // else: Else [ vars ] stmts; // Then: 'then'; // Else: 'else'; /** `cmp: sum rel;` checks for number @instance @memberof module:Eight~Global01 */ cmp (sum, _) { if (sum != this.numberType) this.parser.error(`cannot compare ${sum.toString()}`); } // rel: eq | ne | gt | ge | lt | le; /** `eq: '=' sum;` checks for number @instance @memberof module:Eight~Global01 */ eq (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '=' to ${sum.toString()}`); else this.parser.call(this, super.eq); } /** `ne: '&lt;&gt;' sum;` checks for number @instance @memberof module:Eight~Global01 */ ne (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '&lt;&gt;' to ${sum.toString()}`); else this.parser.call(this, super.ne); } /** `gt: '&gt;' sum;` checks for number @instance @memberof module:Eight~Global01 */ gt (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '&gt;' to ${sum.toString()}`); else this.parser.call(this, super.gt); } /** `ge: '&gt;=' sum;` checks for number @instance @memberof module:Eight~Global01 */ ge (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '&gt;=' to ${sum.toString()}`); else this.parser.call(this, super.ge); } /** `lt: '&lt;' sum;` checks for number @instance @memberof module:Eight~Global01 */ lt (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '&lt;' to ${sum.toString()}`); else this.parser.call(this, super.lt); } /** `le: '&lt;=' sum;` checks for number @instance @memberof module:Eight~Global01 */ le (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '&lt;=' to ${sum.toString()}`); else this.parser.call(this, super.le); } /** `sum: product [{ add | subtract }];` returns product @instance @memberof module:Eight~Global01 */ sum (product, many) { if (many &amp;&amp; product != this.numberType) this.parser.error(`cannot apply '+' or '-' ` + `to ${product.toString()}`); return product; } /** `add: '+' product;` checks for number @instance @memberof module:Eight~Global01 */ add (_, product) { if (product != this.numberType) this.parser.error(`cannot apply '+' to ${product.toString()}`); else this.parser.call(this, super.add); } /** `subtract: '-' product;` checks for number @instance @memberof module:Eight~Global01 */ subtract (_, product) { if (product != this.numberType) this.parser.error(`cannot apply '-' to ${product.toString()}`); else this.parser.call(this, super.subtract); } /** `product: signed [{ multiply | divide }];` returns signed @instance @memberof module:Eight~Global01 */ product (signed, many) { if (many &amp;&amp; signed != this.numberType) this.parser.error(`cannot apply '*' or '/' ` + `to ${signed.toString()}`); return signed; } /** `multiply: '*' signed;` checks for number @instance @memberof module:Eight~Global01 */ multiply (_, signed) { if (signed != this.numberType) this.parser.error(`cannot apply '*' to ${signed.toString()}`); else this.parser.call(this, super.multiply); } /** `divide: '/' signed;` checks for number @instance @memberof module:Eight~Global01 */ divide (_, signed) { if (signed != this.numberType) this.parser.error(`cannot apply '/' to ${product.toString()}`); else this.parser.call(this, super.divide); } /** `signed: [ '-' ] term;` checks for number, returns term @instance @memberof module:Eight~Global01 */ signed (minus, term) { if (minus &amp;&amp; term != this.numberType) this.parser.error(`cannot apply '-' to ${term.toString()}`); else this.parser.call(this, super.signed, minus, term); return term; } /** `term: input | number | name | '(' sum ')';` returns type @instance @memberof module:Eight~Global01 */ term (...val) { return val.length &gt; 1 ? val[1] : val[0]; } /** `input: 'input' [ Number ];` returns `this.numberType @instance @memberof module:Eight~Global01 */ input (i, number) { this.parser.call(this, super.input, i, number); return this.numberType; } /** `number: Number;` returns `this.numberType` @instance @memberof module:Eight~Global01 */ number (number) { this.parser.call(this, super.number, number); return this.numberType; } /** `name: symbol [{ args }];` @instance @memberof module:Eight~Global01 */ name (sym, args) { const context = this.context; this.context = null; if (args) return context.type; sym.load(); return sym.type; } // symbol: Name; }; /** [Example 8/08](../?eg=08/08): adds support for nested functions as arguments. @mixin */ const Machine08 = superclass =&gt; class extends superclass { /** `stack: ... arguments dp old-pc -&gt; ... arguments old-pc old-fp old-dp result display locals` @param {number} args - size of argument values. @param {number} depth - number of display entries. @param {number} vars - size of local variables. @instance @memberof module:Eight~Machine08 */ Entry (args, depth, vars) { return memory =&gt; { const fp = memory.length - args - 2, // next memory.fp dp = memory.splice(-1, 1, memory.pop(), // retain old-pc memory.fp, memory.dp, 0 // push fp, dp, result slot )[0]; // extract incoming display memory.fp = fp; // new frame's base memory.dp = memory.length - 1; // new display's base // copy incoming display up to depth-1 memory.push(... memory.slice(dp + 1, dp + depth), memory.fp, // append new frame ... Array(vars).fill(0)); // initialize local variables }; } /** `stack: ... arguments old-pc old-fp old-dp result display locals -&gt; ... result old-pc` @param {number} args - size of argument values. @instance @memberof module:Eight~Machine08 */ Exit (args) { return memory =&gt; { const fp = memory.fp; // current frame memory.splice(fp, args, // remove argument values memory[fp + args + 3]); // insert result // restore old fp dp, free rest of frame [ memory.fp, memory.dp ] = memory.splice(fp + 2, Infinity); }; } /** `stack: ... -&gt; ... dp` @instance @memberof module:Eight~Machine08 */ PushDP (memory) { memory.push(memory.dp); } }; /** [Example 8/08](../?eg=08/08): adds actions and infrastructure to compile nested functions as arguments. Requires {@linkcode module:Seven~Nest13 Nest13} and {@linkcode module:Eight~Global01 Global01}. @mixin */ const Pass08 = superclass =&gt; class extends superclass { /** Describes a variable in {@linkcode module:Eight~Pass08 Pass08} @class @extends super.Var @instance @memberof module:Eight~Pass08 @property {function} load() - [replace] for function slots. @property {function} storeOk(type) - [extend] false for function value. */ get Var () { return this.#Var ??= class extends super.Var { load () { // [replace] load two slots for function type const load = addr =&gt; { if (!this.depth) // global this.owner.machine.gen('Load', addr); else if (this.depth+1 != this.owner.functs.length) // nested this.owner.machine.gen('LoadDP', addr, this.depth); else this.owner.machine.gen('LoadFP', addr); // local }; load(this.addr); // top:value or below:display if (this.type.isFun) load(this.addr + 1); // + top:address } storeOk (type) { // [extend] read-only function parameters if (this.type?.isFun) { this.owner.parser.error(`${this.name}: read only parameter`); return false; } return super.storeOk(type); } }; } #Var; /** Describes a function in {@linkcode module:Eight~Pass08 Pass08}. @class @extends super.Fun @instance @memberof module:Eight~Pass08 @property {number} parms - [replace] memory slots for arguments. @property {function} setParms() - [replace] function values take 2 slots. @property {function} call() - [extend] `PushDP`, `Call(addr)`. @property {function} load() - [extend] `PushDP`, `Push(start)`. @property {function} exit() - [replace] `Entry`, `Exit`. */ get Fun () { return this.#Fun ??= class extends super.Fun { setParms (name) { // [replace] sets parameter types try { const type = this.owner.typeSymbols.get(name); if (!type) throw `${name}: not a type`; if (!type.isFun) throw `${name}: not a function type`; if (this.type &amp;&amp; this.type != type) throw `${name} ${this.name}: ` + `previously declared as ${this.type.name}`; if (type.parms.length != this.locals.size) throw `${name} ${this.name} arguments: expects ` + `${type.parms.length}, receives ${this.locals.size}`; this.type = type; this.size = 0; // parameter addresses start at 0 let n = 0; // Map.forEach does not provide n this.locals.forEach(parm =&gt; { parm.addr = this.size ++; // set parameter address parm.type = type.parms[n ++]; // set parameter type if (parm.type.isFun) ++ this.size; // function argument }); this.parms = this.size; // argument slots this.size += 3; // room for old pc, old fp, old dp this.addr = this.size; // address of result this.size += 1 + this.depth; // room for result, display } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(e); // report an error } } call () { // [extend] generate 'PushDP' this.owner.machine.gen('PushDP'); super.call(); } load () { // [extend] generate 'PushDP' this.owner.machine.gen('PushDP'); super.load(); } exit () { // [replace] new 'Entry', 'Exit' this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, // arguments this.depth, // display, variable slots this.frameSize - (this.parms + 4 + this.depth)); this.owner.machine.gen('Exit', this.parms); const end = this.owner.machine.gen('Return'); if (this.scope) // need to repair bypass this.owner.machine.code[this.scope.bypass] = this.owner.machine.ins('Branch', end); } }; } #Fun; constructor (parser, machine) { super(parser, machine ?? new (Machine08(Machine01(Seven.Machine13)))()); } /** [Replace] Need `PushDP` for `main`. @param {Fun} main - describes `main()`. @instance @memberof module:Eight~Pass08 */ _startup (main) { for (let p = 0; p &lt; main.parms; ++ p) // push arguments if any this.machine.gen('Push', 0); this.machine.gen('PushDP'); // push display pointer this.machine.gen('Call', main.start); // call main function this.machine.gen('Print', 1); // print and pop } // prog: [ typedcls ] [ vars ] funs; // typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; // typedcl: Name '(' [ types ] ')' [ ':' 'number' ]; // types: typename [{ ',' typename }]; // typename: Name | 'number'; // vars: 'var' varname [{ ',' varname }] ';'; // varname: Name; // funs: { fun }; // fun: head parms [ block ] ';'; // head: 'function' Name; // parms: '(' [ names ] ')' [ ':' Name ]; // names: Name [{ ',' Name }]; // block: begin body 'end'; // body: [ vars ] [ funs ] stmts; // begin: 'begin'; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | block | loop | select; // assign: symbol action; // action: store | call; // store: '=' sum; // call: args; // args: '(' [ sums ] ')'; // print: 'print' sums; // sums: sum [{ ',' sum }]; // return: 'return' [ sum ]; // loop: While cmp Do body 'od'; // While: 'while'; // Do: 'do'; // select: 'if' cmp then [ else ] 'fi'; // then: Then [ body ]; // else: Else body; // Then: 'then'; // Else: 'else'; // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: symbol [ args ]; // symbol: Name; }; /** [Example 8/14](../?eg=08/14): adds support for garbage-collected frames, cannot be mixed with {@linkcode module:Eight~Machine08 Machine08}. @mixin */ const Machine14 = superclass =&gt; class extends superclass { /** Data memory for nested functions as arguments @class @extends super.Memory @instance @memberof module:Eight~Machine14 @property {?Array} fp - current frame @property {number} dp - no longer used @property {number} id - current tag for frames (trace) @property {number} newId - new tag for frames (trace) @property {?Array} dirty - changed frame (trace) @property {function} toString() - [replace] interpret `dirty` frame */ get Memory () { return this.#Memory ??= class extends super.Memory { get newId () { ++ this.#id; return this.id; } get id () { // returns a letter or a sequence number return this.#id &lt;= 26 ? String.fromCharCode(96 + this.#id) : this.#id &lt;= 52 ? String.fromCharCode(64 + this.#id - 26) : String(this.#id - 52); } #id = 0; // current uniqe id dirty = null; // frame to be displayed // no frame yet constructor (...args) { super(...args); this.fp = null; } toString () { // [replace] global memory and dirty frame const dump = slot =&gt; slot === null ? 'null' : slot instanceof Array ? 'id' in slot ? `${slot.id}:[]` : '[?]' : slot; let result = 'mem:[ ' + this.map(dump).join(' ') + ' ] ' + `fp: ${dump(this.fp)}`; if (this.dirty) { result += ` ${this.dirty.id}:[ ` + this.dirty.map(dump).join(' ') + ' ]'; this.dirty = null; } return result; } }; } #Memory; /** `stack: ... arguments fp old-pc -&gt; ... | frame: old-pc old-fp display result arguments locals` @param {number} args - size of argument values. @param {number} depth - number of display entries. @param {number} result - size of result value. @param {number} vars - size of local variables. @instance @memberof module:Eight~Machine14 */ Entry (args, depth, result, vars) { return memory =&gt; { const frame = [ memory.pop(), memory.fp ]; // old-pc, old-fp frame.id = memory.newId; // label new frame if (depth &gt; 1) // push (part of) incoming display, if any frame.push(... memory.pop().slice(1 + 1, 1 + depth)); else memory.pop(); // pop frame frame.push(frame); // push new frame's base frame.push(... Array(result).fill(0)); // push result value if (args) // move arguments to frame frame.push(... memory.splice(- args, Infinity)); if (vars) // create local variables frame.push(... Array(vars).fill(0)); memory.dirty = memory.fp = frame; // new fp }; } /** `stack: ... | frame: old-pc old-fp display result ... -&gt; ... result old-pc | fp: old-fp | frame unchanged` @param {number} depth - number of display entries. @param {number} result - size of result value. @instance @memberof module:Eight~Machine14 */ Exit (depth, result) { return memory =&gt; { memory.push( // push result ... memory.fp.slice(2 + depth, 2 + depth + result), memory.fp[0]); // push old pc memory.fp = memory.fp[1]; // set previous frame }; } /** `stack: ... -&gt; ... frame[depth][addr]` @instance @memberof module:Eight~Machine14 */ LoadGC (addr, depth) { return memory =&gt; memory.push(memory.fp[1 + depth][addr]); } /** `stack: ... val -&gt; ... val | frame[depth][addr]: val` @instance @memberof module:Eight~Machine14 */ StoreGC (addr, depth) { return memory =&gt; (memory.dirty = memory.fp[1 + depth])[addr] = memory.at(-1); } /** `stack: ... -&gt; ... fp` @instance @memberof module:Eight~Machine14 */ PushFP (memory) { memory.push(memory.fp); } }; /** [Example 8/14](../?eg=08/14): adds actions and infrastructure to compile nested functions as first-order values. Requires {@linkcode module:Seven~Nest13 Nest13} and {@linkcode module:Eight~Global01 Global01}, cannot be mixed with {@linkcode module:Eight~Pass08 Pass08}. @mixin */ const First14 = superclass =&gt; class extends superclass { /** Describes a variable in {@linkcode module:Eight~First14 First14}. @class @extends super.Var @instance @memberof module:Eight~First14 @property {function} load() - [replace] local/global and function slots @property {function} store() - [replace] local/global and function slots */ get Var () { return this.#Var ??= class extends super.Var { load () { // [replace] garbage-collected frames const load = addr =&gt; { if (this.depth) // local this.owner.machine.gen('LoadGC', addr, this.depth); else // global this.owner.machine.gen('Load', addr); }; load(this.addr); // top:value or below:display if (this.type.isFun) load(this.addr + 1); // + top:address } store () { // [replace] garbage-collected frames const store = addr =&gt; { if (this.depth) // local this.owner.machine.gen('StoreGC', addr, this.depth); else // global this.owner.machine.gen('Store', addr); }; if (this.type.isFun) { store(this.addr + 1); // top:address this.owner.machine.gen('Rotate', 1); store(this.addr); // below:display this.owner.machine.gen('Rotate', 1); } else store(this.addr); // top:value } }; } #Var; /** Describes a function in {@linkcode module:Eight~First14 First14}. @class @extends super.Fun @instance @memberof module:Eight~First14 @property {number} parms - [replace] memory slots for arguments. @property {function} setParms() - [replace] function values take 2 slots similar to {@linkcode module:Eight~Pass08#Fun Pass08.Fun.setParms()}. @property {function} call() - [extend] `PushFP`, `Call(addr)`. @property {function} load() - [extend] `PushFP`, `Push(start)`. @property {function} store() - [replace] `StoreGC`. @property {function} exit() - [replace] `Entry`, `Exit`. */ get Fun () { return this.#Fun ??= class extends super.Fun { setParms (name) { // [replace] sets parameter types try { const type = this.owner.typeSymbols.get(name); if (!type) throw `${name}: not a type`; if (!type.isFun) throw `${name}: not a function type`; if (this.type &amp;&amp; this.type != type) throw `${name} ${this.name}: ` + `previously declared as ${this.type.name}`; if (type.parms.length != this.locals.size) throw `${name} ${this.name} arguments: expects ` + `${type.parms.length}, receives ${this.locals.size}`; this.type = type; this.size = 2 + this.depth; // old-pc old-fp display this.addr = this.size ++; // result if (this.type.returns &amp;&amp; this.type.returns.isFun) ++ this.size; // function result this.parms = this.size; // begin of arguments let n = 0; // Map.forEach does not provide n this.locals.forEach(parm =&gt; { parm.addr = this.size ++; // set parameter address parm.type = type.parms[n ++]; // set parameter type if (parm.type.isFun) ++ this.size; // function argument }); this.parms = this.size - this.parms; // argument slots } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(e); // report an error } } call () { // [extend] generate 'PushFP' this.owner.machine.gen('PushFP'); super.call(); } load () { // [extend] generate 'PushFP' this.owner.machine.gen('PushFP'); super.load(); } store () { // [replace] garbage-collected frames const store = addr =&gt; this.owner.machine.gen('StoreGC', addr, this.depth); if (this.type.returns &amp;&amp; this.type.returns.isFun) { store(this.addr + 1); // top:address this.owner.machine.gen('Rotate', 1); store(this.addr); // below:display this.owner.machine.gen('Rotate', 1); } else store(this.addr); // top:value } exit () { // [replace] new 'Entry', 'Exit' const result = this.type.returns &amp;&amp; this.type.returns.isFun ? 2 : 1; this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, // arguments this.depth, result, // display, result, locals this.frameSize - (2 + this.depth + result + this.parms)); this.owner.machine.gen('Exit', this.depth, result); const end = this.owner.machine.gen('Return'); if (this.scope) // need to repair bypass this.owner.machine.code[this.scope.bypass] = this.owner.machine.ins('Branch', end); } }; } #Fun; constructor (parser, machine) { super(parser, machine ?? new (Machine14(Machine01(Seven.Machine13)))()); } /** [Replace] Need `PushFP` for `main`. @param {Fun} main - describes `main()`. @instance @memberof module:Eight~First14 */ _startup (main) { for (let p = 0; p &lt; main.parms; ++ p) // push arguments if any this.machine.gen('Push', 0); this.machine.gen('PushFP'); // push frame pointer this.machine.gen('Call', main.start); // call main function if (!main.type.returns?.isFun) // only print number result this.machine.gen('Print', 1); // print and pop } // prog: [ typedcls ] [ vars ] funs; // typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; // typedcl: Name '(' [ types ] ')' [ ':' typename ]; // types: typename [{ ',' typename }]; // typename: Name | 'number'; // vars: 'var' varname [{ ',' varname }] ';'; /** `varname: Name [ ':' type ];` [extend] two slots for function value. @instance @memberof module:Eight~First14 */ varname (name, type) { super.varname(name, type); // create single slot variable if (type?.[1].isFun) // add slot for function value if (this.funct) this.funct.size ++; // local else this.size ++; // global } // type: Name | 'number'; // funs: { fun }; // fun: head parms [ block ] ';'; // head: 'function' Name; // parms: '(' [ names ] ')' [ ':' Name ]; // names: Name [{ ',' Name }]; // block: begin body 'end'; // body: [ vars ] [ funs ] stmts; // begin: 'begin'; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | block | loop | select; // assign: symbol action; // action: store | call; /** `store: '=' sum;` [extend] pops extra slot for function value. @instance @memberof module:Eight~First14 */ store (_, sum) { super.store(_, sum); if (sum.isFun) this.machine.gen('Pop'); } /** `call: { args };` pops extra slot for function value. @instance @memberof module:Eight~First14 */ call (_) { if (this.context.type &amp;&amp; this.context.type.isFun) this.machine.gen('Pop'); } // args: '(' [ sums ] ')'; /** [replace] need two slots for function argument and value. @param {Type[]} args - list of argument types. @instance @memberof module:Eight~First14 */ _lift (args) { if (args.length) this.machine.gen('Rotate', args.reduce( (length, type) =&gt; length + (type.isFun ? 2 : 1), 0), 2); } // print: 'print' sums; // sums: sum [{ ',' sum }]; /** `return: 'return' [ sum ];` [extend] pops extra slot for function value. @instance @memberof module:Eight~First14 */ return (_, sum) { if (this.funct.storeOk(sum ? sum[0] : null)) if (sum) { this.funct.store(); this.machine.gen('Pop'); if (sum[0].isFun) this.machine.gen('Pop'); } this.funct.return(); } // loop: While cmp Do body 'od'; // While: 'while'; // Do: 'do'; // select: 'if' cmp then [ else ] 'fi'; // then: Then [ body ]; // else: Else body; // Then: 'then'; // Else: 'else'; // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: symbol [{ args }]; // symbol: Name; }; export { Machine01, Global01, Machine08, Pass08, Machine14, First14 }; × Search results Close "},"05.js.html":{"id":"05.js.html","title":"Source: 05.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 05.js /** This module contains the classes for the last three examples in chapter five. @module Five @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-06 */ /** [Example 5/14](../?eg=05/14): actions to process a list of semicolon-terminated items. */ class Actions14 { /** `dec: 'dec' Decimal ';';` returns value */ dec (_, decimal) { return parseInt(decimal, 10); } /** `hex: 'hex' ref ';';` returns value */ hex (_, ref) { return parseInt(ref[0], 16); } /** `item: dec | hex;` returns `[ value ]` `list: { item ';' };` displays value ... */ list (some) { puts(... some.map(list =&gt; list[0][0])); } } /** [Example 5/15](../?eg=05/15): action to display a list of comma-separated items. @extends module:Five~Actions14 */ class Actions15 extends Actions14 { /** `item: dec | hex;` returns `[ value ]` `list: { item ';' };` returns `[ value ... ]` */ list (item, many) { return item.concat(many ? many[0].map(list =&gt; list[1][0]) : []); } // alternative solution // list (item, many) { // return (many ? many[0] : []).reduce( // (result, list) =&gt; (result.push(list[1][0]), result), item); // } } /** [Example 5/16](../?eg=05/16): action to process a list of comma-separated items. @extends module:Five~Actions14 */ class Actions16 extends Actions14 { // convoluted solution // list (item, many) { // return item.concat(many ? many[0].map(list =&gt; list[1][0]) : []). // reduce((sum, value) =&gt; sum + value, 0); // } /** `item: dec | hex;` returns `[ value ]` `list: [{ ',' item }];` returns `value +...` */ list (item, many) { return (many ? many[0] : []).reduce( (result, list) =&gt; result += list[1][0], item[0]); } } export { Actions14, Actions15, Actions16 }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: index.js /** This module implements the _document ready_ event handler for [jQuery](https://en.wikipedia.org/wiki/JQuery) to control the {@link module:Practice~Model practice page model}, i.e., to edit and run examples. @module GUI @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-13 */ import * as Practice from './practice.js'; /** The _document ready_ event handler. */ function browse () { // redirect if there is no search if (!location.search.length) { location = 'doc/index.html'; return; } // reference: code to detect how the page was entered // const entries = performance.getEntriesByType(\"navigation\"); // entries.forEach((entry) =&gt; { // switch (entry.type) { // case \"navigate\": console.log(`${entry.name} was reached from address!`); break; // case \"reload\": console.log(`${entry.name} was reloaded!`); break; // case \"back_forward\": console.log(`${entry.name} was reached from history!`); break; // default: console.log(`${entry.name} was reached by ${entry.type}!`); // } // }); // HTML structure state variable(s) // form class='ebnf|stack|bnf' // id-grammar model.grammar nested into .frame with .label // id-tokens model.tokens nested into .frame with .label // id-program model.program nested into .frame with .label // id-actions model.actions nested into .frame with .label // id-output nested into .frame with id-book label // id-mode model.mode toggles ebnf|stack|bnf // id-greedy id-error model.greedy model.error // id-tShallow id-dSets model.tShallow model.dSets // id-tDeep id-dStates model.tDeep model.dStates // id-tFollow model.tFollow // id-new model.doNew() // actions model.actionsArea nested into .frame with .label // id-scan model.doScan() // id-tLookahead model.tLookahead // id-tParser model.tParser // id-tActions model.tActions // id-tNoargs model.tNoargs // id-build model.build // id-parse model.doParse() // id-run model.doRun() // id-1 model.doStep(1) // id-10 model.doStep(10) // id-100 model.doStep(100) // set book button { let m, book = 'doc/tutorial-a-webpage.html'; if (m = /eg=[01][0-9]\\/[012][0-9]/.exec(location.search)) book = 'doc/tutorial-' + { '02': '02-grammars', '03': '03-scanner', '04': '04-parser', '05': '05-lists', '06': '06-compile', '07': '07-features', '08': '08-functions', '09': '09-bootstrap', '10': '10-bottom-up', '11': '11-trees' }[m[0].substring(3, 5)] + '.html?' + m[0]; else if (m = /eg=[a-z_]+/.exec(location.search)) book = { interpret: \"doc/tutorial-06-compile.html#immediate-evaluation\", compile: \"doc/tutorial-06-compile.html#functional-evaluation\", postfix: \"doc/tutorial-06-compile.html#stack-evaluation\", stack: \"doc/tutorial-06-compile.html#stack-evaluation\", little: \"doc/tutorial-06-compile.html#control-structures\", little_fn: \"doc/tutorial-06-compile.html#functional-programming\", typing: \"doc/tutorial-07-features.html#type-checking-by-interpretation\", recursion: \"doc/tutorial-07-features.html#functions\", functions: \"doc/tutorial-07-features.html#local-variables\", scopes: \"doc/tutorial-07-features.html#block-scopes\", nesting: \"doc/tutorial-07-features.html#nested-functions\", first_glob: \"doc/tutorial-08-functions.html#global-first-order-functions\", fn_parameter: \"doc/tutorial-08-functions.html#functions-as-argument-values\", first: \"doc/tutorial-08-functions.html#nested-first-order-functions\", curry: \"doc/tutorial-08-functions.html#nested-first-order-functions\", compose: \"doc/tutorial-08-functions.html#nested-first-order-functions\", bootstrap: \"doc/tutorial-09-bootstrap.html#bootstrap-example\", extend: \"doc/tutorial-09-bootstrap.html#extending-the-grammars'-grammar\" }[m[0].substring(3)]; $('#id-book').attr('href', book); } // create model, creates and sets global variables const model = new Practice.Model(window); // set window.newOutput: (re)start output newOutput = (...s) =&gt; $('#id-output').val(s.join(' ')); // set window.puts: append to output puts = (...s) =&gt; { const output = $('#id-output'), head = output.val(), nl = head.length &amp;&amp; ! head.endsWith('\\n') ? '\\n' : ''; output.val(head + nl + s.join(' ')); output.scrollTop(output.prop(\"scrollHeight\")); }; // manage local storage, if possible $(document).on('visibilitychange', () =&gt; { try { localStorage.setItem('EBNF/state', [ '%% grammar\\n' + model.grammar.trim() + '\\n', '%% tokens\\n' + model.tokens.trim() + '\\n', '%% actions\\n' + model.actions.trim() + '\\n', '%% program\\n' + model.program.trim() + '\\n' ].join('') ); } catch (e) { console.error('localStorage.setItem failed: ', e.message); } }); const getState = () =&gt; { try { return localStorage.getItem('EBNF/state'); } catch (e) { console.error('localStorage.getItem failed: ', e.message); return null; } }; const removeState = () =&gt; { try { localStorage.removeItem('EBNF/state'); } catch (e) { console.error('localStorage.removeItem failed: ', e.message); } }; // run user interface from text, if any const ui = function (text) { // no text? use or clear local storage if (typeof text != 'string' || !text.length) { // failed search? if (document.location.search.length &gt; 1) removeState(); else text = getState(); } // load from text, if any if (typeof text == 'string' &amp;&amp; text.length) { document.title = 'Example ' + stem.replace(/^0/, ''); // clear and load all text areas, tell model $('textarea').val(''); text.split(/%%/).forEach(part =&gt; { try { const id = part.match(/\\s+(grammar|tokens|program|actions|output)\\s+/)[1]; part = part.replace(/^[^\\n]*\\n/, '').replace(/\\n*$/, ''); switch (id) { case 'grammar': $('#id-grammar').val(model.grammar = part); break; case 'tokens': $('#id-tokens').val(model.tokens = part); break; case 'program': $('#id-program').val(model.program = part); break; case 'actions': $('#id-actions').val(model.actions = part); break; case 'output': $('#id-output').val(part); } } catch (e) { } }); } // capture initial heights (?? not good if window is resized) const vh = { }; $('.frame textarea').each(function () { vh[$(this).attr('id')] = $(this).height(); }) // stack machine test const isStackMachine = () =&gt; typeof run == 'function' &amp;&amp; run.length == 2; // maintain text area contents and set buttons to reflect contents const setButtons = function () { // deactivate all buttons $('.button').removeClass('ok'); $('#id-1, #id-10, #id-100').addClass('hidden'); // toggle-button clicks - toggle 'on' and flag in model $('.button.toggle').each(function () { const name = $(this).attr('id').substring(3); console.assert(typeof model[name] == 'boolean', name, 'is not boolean'); if (model[name]) $(this).addClass('on'); else $(this).removeClass('on'); }); // mode - always ok $('#id-mode').addClass('ok'); // new - requires text in grammar if (model.grammar.length) $('#id-new').addClass('ok'); switch (model.mode) { case 'ebnf': // greedy shallow deep follow - require text in grammar if (model.grammar.length) $('#id-greedy, #id-tShallow, #id-tDeep, #id-tFollow').addClass('ok'); break; case 'stack': // error sets states - require text in grammar if (model.grammar.length) $('#id-error').addClass('ok'); case 'bnf': // sets states - require text in grammar if (model.grammar.length) $('#id-dSets, #id-dStates').addClass('ok'); } // scan lookahead parser actions noargs build parse - require represented grammar if (g != null) { $('#id-scan, #id-tLookahead, #id-tParser, #id-tActions, #id-tNoargs, #id-parse').addClass('ok'); if (model.mode == 'bnf') $('#id-build').addClass('ok'); } // run 1 10 100 - require represented grammar, run, and possibly stack machine if (g != null &amp;&amp; typeof run == 'function') { $('#id-run').addClass('ok'); if (isStackMachine()) $('#id-1, #id-10, #id-100').addClass('ok').removeClass('hidden'); } } setButtons(); // deactivate all buttons if textarea gets edited $('textarea').on('focus', () =&gt; { $('.button').removeClass('ok'); // $('#id-1, #id-10, #id-100').addClass('hidden'); }); // (re-)activate once focus is out of textarea $('textarea').on('blur', setButtons); // mode click - next mode, need to recreate window.g and window.run $('#id-mode').click(() =&gt; { $('form').removeClass(model.mode); model.mode = model.mode == 'ebnf' ? 'stack' : model.mode == 'stack' ? 'bnf' : 'ebnf'; $('form').addClass(model.mode); newOutput(''); setButtons(); }); // act on change $('#id-grammar').change(function () { model.grammar = $(this).val().trim(); newOutput(''); setButtons(); }); // need to recreate g and run $('#id-tokens').change(function () { model.tokens = $(this).val().trim(); newOutput(''); setButtons(); }); // need to recreate g and run $('#id-actions').change(function () { model.actions = $(this).val().trim(); newOutput(''); setButtons(); }); // need to recreate run $('#id-program').change(function () { model.program = $(this).val().trim(); newOutput(''); setButtons(); }); // need to recreate run // click/shift-click on label to emphasize or default textarea layout $('#id-grammar, #id-tokens, #id-actions, #id-program').prev('.label'). click(function (event) { if (event.shiftKey) $('.frame textarea').each(function () { $(this).height(vh[$(this).attr('id')]); }); else if (!(event.metaKey || event.altKey)) { const area = $(this).next('textarea'), id = area.attr('id'); let height = 0; $('#id-grammar, #id-tokens, #id-actions, #id-program').each(function () { height += $(this).height() - 30; $(this).height(30); }); area.height(height + 30); } }); // alt-click handler to open popup with highlighted (non-empty) text location const highlighter = (name, js) =&gt; function (event) { if (!(event.metaKey || event.altKey)) return; const text = $(this).next('textarea').val(); if (!text.length) return; const prefix = location.href.replace(/EBNF.*/, 'EBNF/doc/'); const html = `&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt; ${name} &lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"${prefix}styles/sunlight.default.css\"&gt; &lt;script src=\"${prefix}sunlight-all-min.js\"&gt;&lt;/script&gt;` + (js ? `&lt;script src=\"${prefix}sunlight.javascript.js\"&gt;&lt;/script&gt;` : ``) + `&lt;/head&gt; &lt;body&gt; &lt;h3&gt; ${name} &lt;/h3&gt; &lt;pre id=\"code\" class=\"sunlight-highlight-${js ? 'javascript' : 'plaintext'}\"&gt;${text}&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; new Sunlight.Highlighter({ lineNumbers: true, tabWidth: 2 }).highlightNode(document.getElementById(\"code\")) &lt;/script&gt; &lt;body&gt; &lt;/html&gt;`; const winUrl = URL.createObjectURL(new Blob([html], { type: \"text/html\" })); window.open(winUrl, 'source', 'popup,width=800,height=400,screenX=200,screenY=200'); }; // alt-click on label to syntax-color in popup $('#id-grammar').prev('.label').click(highlighter('grammar', false)); $('#id-program').prev('.label').click(highlighter('program', false)); $('#id-tokens').prev('.label').click(highlighter('tokens', true)); $('#id-actions').prev('.label').click(highlighter('actions', true)); $('#id-output').prev('.label').click(highlighter('output', false)); // toggle-button clicks - toggle 'on' and flag in model $('.button.toggle').click(function () { if ($(this).hasClass('ok')) { const name = $(this).attr('id').substring(3); console.assert(typeof model[name] == 'boolean', name, 'is not boolean'); model[name] = !model[name]; $(this).toggleClass('on'); } }); // new Grammar $('#id-new').click(function () { if ($(this).hasClass('ok')) { model.doNew(); setButtons(); } }); // scanner $('#id-scan').click(function () { if ($(this).hasClass('ok')) model.doScan(); }); // parser/compiler $('#id-parse').click(function () { if ($(this).hasClass('ok')) { model.doParse(); setButtons(); } }); // run $('#id-run').click(function () { if ($(this).hasClass('ok')) model.doRun(); }); // 1 10 100 $('#id-1, #id-10, #id-100').click(function () { if ($(this).hasClass('ok')) model.doStep(parseInt($(this).attr('id').substring(3), 10)); }); } // determine search parameters, if any const params = new URLSearchParams(document.location.search), stem = params.get('eg'); // set form class=' ebnf|stack|bnf ' from mode switch (model.mode = params.get('mode')) { default: model.mode = 'ebnf'; case 'stack': case 'bnf': $('form').removeClass('ebnf stack bnf').addClass(model.mode); } // delegate to user interface if (stem &amp;&amp; /^[/0-9a-zA-Z_]+$/.test(stem)) $.get('eg/' + stem + '.eg', ui, 'text').fail(ui); else ui(); } $(browse); export { browse }; × Search results Close "},"practice.js.html":{"id":"practice.js.html","title":"Source: practice.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: practice.js /** This module implements the model for the practice page which is shared by [batch](script.js.html) and [graphical user interface](index.js.html) scripting. @module Practice @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-6-20 */ import * as iBase from './base.js'; import * as iEBNF from './ebnf.js'; import * as iBNF from './bnf.js'; import * as iFive from './05.js'; import * as iSix from './06.js'; import * as iSeven from './07.js'; import * as iEight from './08.js'; import * as iTen from './10.js'; import * as iEleven from './11.js'; /** Model of the practice page. * The following global variables and global modules * will exist once the model has been constructed. * Pre-existing global variables `newOutput`, `prompt`, and `puts` will not be overwritten. | name | type | content | | ------ | ---- | ------- | | `actions` | `string` | Defines the class and {@link module:Base~Action action methods} to be called by a parser. | | `g` | `Grammar` | Represents `grammar`. | | `grammar` | `string` | Rules of a grammar, argument for the construction of `g`. | | `newOutput` | `function` | Displays it's arguments, blank-separated and marked as a new section. | | `program` | `string` | Should be a sentence conforming to `grammar`, argument for recognition. | | `prompt` | `function` | Displays a prompt string, returns input or a default string, else error. | | `puts` | `function` | Displays it's arguments, blank-separated. | | `run` | `function` | `null` or an executable compiled from `program` by the `actions`.&lt;br&gt;A stack machine has two arguments, other executables have none. | | `tokens` | `string` | Defines an object with pattern properties defining the tokens used in `grammar`. | | module | purpose | | ------ | ------- | | {@linkcode module:Base Base} | Base classes shared by the parser generators | | {@linkcode module:EBNF EBNF} | LL(1) parser generator | | {@linkcode module:BNF BNF} | SLR(1) parser generator | | {@linkcode module:Six Six} | Classes for the examples in chapter six | | {@linkcode module:Seven Seven} | Classes for the examples in chapter seven | | {@linkcode module:Eight Eight} | Classes for the examples in chapter eight | | {@linkcode module:Ten Ten} | Classes for the examples in chapter ten | | {@linkcode module:Eleven Eleven} | Classes for the examples in chapter eleven | * @property {string} grammar - global `grammar`; setter clears global `g` and global `run`. * @property {string} tokens - global `tokens`; setter clears global `g` and global `run`. * @property {RegExp} skip - set by `doNew` from an empty key in `tokens`; * overwrites default for scanner and parser. * @property {string} actions - global `actions`; setter clears global `run`. * @property {string} program - global `program`; setter clears global `run`. * @property {string} mode - `ebnf`|`stack`|`bnf`; setter clears global `g` and global `run`. * @property {boolean} greedy - use `expect()` rather than `check()`. * @property {boolean} error - insert `$error` when translating EBNF. * @property {boolean} tShallow - trace algorithm and display sets. * @property {boolean} tDeep - trace algorithm and display sets. * @property {boolean} tFollow - trace algorithm and display sets. * @property {boolean} dSets - display sets. * @property {boolean} dStates - display states. * @property {boolean} tLookahead - trace lookahead during parse. * @property {boolean} tParser - trace parse. * @property {boolean} tActions - trace actions. * @property {boolean} tNoargs - do not check argument count for actions. * @property {boolean} build - build lists. * * @property {?Array} memory - for stepping a stack machine. * @example // Use in scripting in a Windows environment new Model(windows); @example // Use in scripting in a node.js environment new Model(globalThis); */ class Model { get grammar () { return grammar; } // global set grammar (value) { if (value == grammar) return; grammar = value.trim(); g = run = null; } // global, if different clears g and run get tokens () { return tokens; } // global set tokens (value) { if (value == tokens) return; tokens = value.trim(); g = run = null; } // global, if different clears g and run get skip () { return this.#skip; } #skip = undefined; get actions () { return actions; } // global set actions (value) { if (value == actions) return; actions = value.trim(); run = null; } // global, if different clears run get program () { return program; } // global set program (value) { if (value == program) return; program = value.trim(); run = null; } // global, if different clears run #mode = 'ebnf'; get mode () { return this.#mode; } set mode (value) { if (value == this.#mode) return; this.greedy = this.error = this.tShallow = this.tDeep = this.tFollow = this.dSets = this.dStates = this.tLookAhead = this.tParser = this.tActions = this.tNoargs = this.build = false; g = run = null; this.#mode = value; } // if different clears all flags, g, run greedy = false; error = false; tShallow = false; tDeep = false; tFollow = false; dSets = false; dStates = false; tLookahead = false; tParser = false; tActions = false; tNoargs = false; build = false; #memory = null; get memory () { return this.#memory; } /** Create a model. @param {object} global - either `windows` or `globalThis`. */ constructor (global) { // create and initialize \"global\" variables global.actions = ''; global.g = null; global.grammar = ''; global.program = ''; global.run = null; global.tokens = ''; if (!('newOutput' in global)) global.newOutput = (...arg) =&gt; { console.log('&gt; newOutput'); if (arg.length &gt; 1 || arg[0].length) console.log(...arg); }; if (!('prompt' in global)) global.prompt = (text, dflt) =&gt; { console.log(text + ' &gt; ' + dflt); return dflt; }; if (!('puts' in global)) global.puts = console.log.bind(console); global.Base = iBase; global.EBNF = iEBNF; global.BNF = iBNF; global.Five = iFive; global.Six = iSix; global.Seven = iSeven; global.Eight = iEight; global.Ten = iTen; global.Eleven = iEleven; } /** Event: `eval?.(tokens)`, if any, and represent and check the grammar; modifies `g`, clears `run`, and removes `memory`. */ doNew () { // clear globals and remove memory const clearAll = () =&gt; g = run = this.#memory = null; clearAll(); // compile this.tokens into tokens, set this.skip let tokens = null; try { this.#skip = undefined; if (this.tokens.length) { tokens = eval?.('(' + this.tokens + '\\n)'); if (tokens[''] instanceof RegExp) this.#skip = tokens['']; } } catch (e) { clearAll(); newOutput('Error in tokens: ' + (e instanceof Error ? e.message : e)); return; } // represent this.grammar as g try { let cmd; switch (this.mode) { case 'ebnf': const flags = []; if (this.tShallow) flags.push('shallow: true'); if (this.tDeep) flags.push('deep: true'); if (this.tFollow) flags.push('follow: true'); cmd = '&gt; g = new EBNF.Grammar(grammar, tokens'; if (flags.length) cmd += ', { ' + flags.join(', ') + ' }'; newOutput(cmd + ')'); g = new EBNF.Grammar(this.grammar, tokens, { shallow: this.tShallow, deep: this.tDeep, follow: this.tFollow, log: puts }); if (g &amp;&amp; !g.errors) { if (this.greedy) puts('&gt; g.expect()'), g.expect(); else puts('&gt; g.check()'), g.check(); puts(this.tShallow|this.tDeep|this.tFollow ? g.dump() : g.toString()); } break; case 'stack': cmd = '&gt; g = BNF.Grammar.fromEBNF(new EBNF.Grammar(grammar, tokens)'; if (this.error) cmd += ', { error: true }'; newOutput(cmd + ')'); g = BNF.Grammar.fromEBNF( new EBNF.Grammar(this.grammar, tokens, { log: puts }), { error: this.error, log: puts }); if (g &amp;&amp; !g.errors) puts(this.dSets ? g.dump(undefined, this.dStates) : g.toString(this.dStates)); break; case 'bnf': newOutput('&gt; g = new BNF.Grammar(grammar, tokens)'); g = new BNF.Grammar(this.grammar, tokens, { log: puts }); if (g &amp;&amp; !g.errors) puts(this.dSets ? g.dump() : g.toString(this.dStates)); } } catch (e) { newOutput('Error in new grammar: ' + (e instanceof Error ? e.message : e)); clearAll(); } if (g &amp;&amp; g.errors) clearAll(); } /** Event: create a scanner and apply it to this.program. */ doScan () { puts('do scan', g == null) if (!g) return; const s = g.scanner(this.skip); newOutput(`&gt; g.scanner(${this.skip ?? ''}).pattern =`, s.pattern.toString()); puts(`&gt; g.scanner(${this.skip ?? ''}).scan(program)`); puts(s.scan(this.program.trim()).join('\\n')); } /** Event: `eval?.(this.actions)`, if any, create a parser, and parse the program; modifies `run` and removes `memory`. */ doParse () { if (!g) return; // clear run and remove memory run = this.#memory = null; // compile actions, if any let actions = null; if (this.actions.length) try { actions = eval?.('(' + this.actions + '\\n)'); if (typeof actions != 'function' &amp;&amp; typeof actions != 'object') throw 'actions must define a class or an object'; } catch (e) { newOutput('Error in actions: ' + (e instanceof Error ? e.message : e)); return; } // parse/compile this.program newOutput(''); switch (this.mode) { case 'ebnf': if (g.config.lookahead = this.tLookahead) puts('&gt; g.config.lookahead = true'); if (g.config.parse = this.tParser) puts('&gt; g.config.parse = true'); if (g.config.actions = this.tActions) puts('&gt; g.config.actions = true'); if (g.config.noargs = this.tNoargs) puts('&gt; g.config.noargs = true'); break; case 'stack': if (g.config.error = this.error) puts('&gt; g.config.error = true'); if (g.config.lookahead = this.tLookahead) puts('&gt; g.config.lookahead = true'); if (this.tParser) puts(`&gt; g.config.trace = ${g.config.trace = /./}`); else if (this.tActions) puts(`&gt; g.config.trace = ${g.config.trace = /reduce/}`); else g.config.trace = null; if (g.config.noargs = this.tNoargs) puts('&gt; g.config.noargs = true'); break; case 'bnf': if (g.config.build = this.build) puts('&gt; g.config.build = true'); if (this.tParser) puts(`&gt; g.config.trace = ${g.config.trace = /./}`); else if (this.tActions) puts(`&gt; g.config.trace = ${g.config.trace = /reduce/}`); else g.config.trace = null; if (g.config.noargs = this.tNoargs) puts('&gt; g.config.noargs = true'); } try { if (actions) puts(`&gt; run = g.parser(${this.skip ?? ''}).parse(program, actions)`); else puts(`&gt; g.parser(${this.skip ?? ''}).parse(program)`); puts(g.dump(run = g.parser(this.skip).parse(this.program, actions))); if (g.errors) run = null; // don't allow execution } catch (e) { if (this.mode != 'ebnf') puts(e instanceof Error ? e.message : e); run = null; // don't allow execution } finally { if (typeof run != 'function') run = null; // don't allow execution } } /** Event: run the executable, if any. */ doRun () { if (typeof run != 'function') return; try { this.#memory = null; // no stepping newOutput('&gt; run()'); const result = run(); puts(run.length == 2 ? result.toString() : g.dump(result)); } catch (e) { puts(e instanceof Error ? e.message : e); } } /** Event: step the stack machine, if any. @param {number} n - number of steps to execute. */ doStep (n) { if (!typeof run == 'function' || run.length != 2) return; try { if (!this.memory || !this.memory.continue) { newOutput(`&gt; memory = run(null, ${n})`); this.#memory = run(null, n); } else { puts(`&gt; memory = run(memory, ${n})`); this.#memory = run(this.memory, n); } if (!this.memory.continue) { puts(this.memory.toString()); this.#memory = null; } } catch (e) { puts(e instanceof Error ? e.message : e); this.#memory = null; } } } export { Model }; × Search results Close "},"script.js.html":{"id":"script.js.html","title":"Source: script.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: script.js /** This module implements a server function for [node.js](https://en.wikipedia.org/wiki/Node.js) to script the {@link module:Practice~Model practice page model}, i.e., to run the examples from the command line. @module Script @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-13 */ import * as readline from 'readline'; import * as fs from 'fs'; import * as Practice from './practice.js'; /** The server function. Blank-separated words, read from standard input, have the effects described below. Any other word is interpreted as a path from which an example is merged into the global strings. | word | effect | | ---- | ------ | | `model` | resets all flags and variables. | | `load` | resets global strings. | | `ebnf`, `stack`, `bnf` | clear all flags and set a mode. | | `actions`, `build`, `deep`, `error`, `follow`, `greedy`,&lt;br&gt;`noargs`, `lookahead`, `parser`, `sets`, `shallow`, `states` | toggle flags. | | `new` | calls {@linkcode module:Practice~Model#doNew model.doNew()}. | | `scan` | calls {@linkcode module:Practice~Model#doScan model.doScan()}. | | `parse` | calls {@linkcode module:Practice~Model#doParse model.doParse()}. | | `run` | calls {@linkcode module:Practice~Model#doRun model.doRun()}. | | `1` | calls {@linkcode module:Practice~Model#doStep model.doStep(1)}. | | `10` | calls {@linkcode module:Practice~Model#doStep model.doStep(10)}. | | `100` | calls {@linkcode module:Practice~Model#doStep model.doStep(100)}. | | exit | terminates the script | @example &lt;caption&gt; Load an example, compile and run with each parser, overwrite parts, and repeat. &lt;/caption&gt; $ node script.js &lt;&lt; 'end' model eg/06/06.eg new parse run stack new parse run ebnf test/06-06a.eg new parse run stack new parse run end */ async function script () { let model; const newModel = () =&gt; model = new Practice.Model(globalThis); newModel(); for await (const line of readline.createInterface({ input: process.stdin })) { const words = line.split(/\\s+/); words.forEach(word =&gt; { if (!word.length) return; console.log('&gt;', word); switch (word) { case 'model': // model -- reset all newModel(); return; case 'load': // load -- reset text areas model.grammar = ''; // %% grammar model.tokens = ''; // %% tokens model.actions = ''; // %% actions model.program = ''; // %% program return; default: // path (cannot contain blanks) try { const text = fs.readFileSync(word, 'utf8'); if (!text.length) { console.log('no text:', word); return; } text.split(/%%/).forEach(part =&gt; { try { const id = part.match(/\\s+(grammar|tokens|actions|program)\\s+/)[1], value = part.replace(/^[^\\n]*\\n/, '').replace(/\\n*$/, ''); switch (id) { case 'grammar': model.grammar = value; return; case 'tokens': model.tokens = value; return; case 'actions': model.actions = value; return; case 'program': model.program = value; return; } } catch (e) { } }); return; } catch (e) { console.log(word + ':', e instanceof Error ? e.message : e); process.exit(1); } case 'ebnf': // ebnf -- set mode, clear all flags case 'stack': // stack -- set mode, clear all flags case 'bnf': // bnf -- set mode, clear all flags model.mode = word; console.log('&gt; model.mode =', model.mode); return; case 'greedy': // greedy -- toggle flag case 'error': // error -- toggle flag case 'build': // build -- toggle flag model[word] = !model[word]; console.log(`&gt; model.${word} = ${model[word]}`); return; case 'shallow': // shallow -- toggle flag case 'deep': // deep -- toggle flag case 'follow': // follow -- toggle flag case 'lookahead': // lookahead -- toggle flag case 'parser': // parser -- toggle flag case 'actions': // actions -- toggle flag case 'noargs': // noargs -- toggle flag { const name = 't' + word[0].toUpperCase() + word.substr(1); model[name] = !model[name]; console.log(`&gt; model.${name} = ${model[name]}`); return; } case 'sets': // sets -- toggle flag case 'states': // states -- toggle flag { const name = 'd' + word[0].toUpperCase() + word.substr(1); model[name] = !model[name]; console.log(`&gt; model.${name} = ${model[name]}`); return; } case 'new': model.doNew(); return; case 'scan': model.doScan(); return; case 'parse': model.doParse(); return; case 'run': model.doRun(); return; case '1': case '10': case '100': model.doStep(parseInt(word, 10)); return; case 'exit': process.exit(0); } }); } } script() export { script }; × Search results Close "},"07.js.html":{"id":"07.js.html","title":"Source: 07.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 07.js /** This module contains the classes for all examples in chapter seven. @module Seven @author © 2024 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-04-05 */ import * as Six from './06.js'; /** [Example 7/01](../?eg=07/01): actions to compile string values and conversions into functions. @extends module:Six~Functions12 */ class TCheck01 extends Six.Functions12 { /** Removes quotes and backslash */ _unq (s) { return s.slice(1,-1).replace(/\\\\([\\\\'])/g, \"$1\"); } // prog: stmts; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | loop | select; // assign: Name '=' stringSum; // print: 'print' sums; // sums: stringSum [{ ',' stringSum }]; // loop: 'while' cmp 'do' stmts 'od'; // select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi'; // cmp: sum rel | stringSum stringRel; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed:[ '-' ] term; /** `term: number | '(' sum ')' | 'number' stringTerm;` returns `fct:term` */ // term: number | '(' sum ')' | 'number' stringTerm; // [0] [1] [1] term (...val) { switch (val.length) { case 1: return val[0]; case 3: return val[1]; case 2: return memory =&gt; parseInt(val[1](memory), 10); } } // number: Number; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; /** `stringSum: stringTerm [{ stringTerm }];` returns fct */ stringSum (term, many) { const c = (a, b) =&gt; memory =&gt; a(memory) + b(memory); return (many ? many[0] : []). reduce((sum, list) =&gt; c(sum, list[0]), term); } /** `stringTerm: string | name | input | 'string' term;` */ // [0] [0] [0] [1] stringTerm (...val) { return val.length == 1 ? val[0] : memory =&gt; String(val[1](memory)); } /** `string: String;` returns fct */ string (s) { return () =&gt; this._unq(s); } // name: Name; /** `input: 'input' String String;` [replace] returns fct */ input (i, prmpt, dflt) { return () =&gt; prompt(this._unq(prmpt), this._unq(dflt)); } // stringRel: stringEq | stringNe | stringGt | stringGe | stringLt | stringLe; /** `stringEq: '=' stringSum;` returns fct for composition */ stringEq (_, right) { return this.parser.call(this, super.eq, _, right); } /** `stringNe: '&lt;&gt;' stringSum;` returns fct for composition */ stringNe (_, right) { return this.parser.call(this, super.ne, _, right); } /** `stringGt: '&gt;' stringSum;` returns fct for composition */ stringGt (_, right) { return this.parser.call(this, super.gt, _, right); } /** `stringGe: '&gt;=' stringSum;` returns fct for composition */ stringGe (_, right) { return this.parser.call(this, super.ge, _, right); } /** `stringLt: '&lt;' stringSum;` returns fct for composition */ stringLt (_, right) { return this.parser.call(this, super.lt, _, right); } /** `stringLe: '&lt;=' stringSum;` returns fct for composition */ stringLe (_, right) { return this.parser.call(this, super.le, _, right); } } /** [Example 7/02](../?eg=07/02): actions to type-check and compile int|float|string into functions. @extends module:Seven~TCheck01 */ class TCheck02 extends TCheck01 { /** For error messages */ get parser () { return this.#parser; } #parser; /** Symbol table, maps names to types */ get symbols () { return this.#symbols; } #symbols; /** For symbolic computing with types */ get stack () { return this.#stack; } #stack = [ ]; constructor (parser, symbols = new Map()) { super(); this.#parser = parser; this.#symbols = symbols; } /** Returns type of name, message if undefined */ _type (name) { const type = this.symbols.get(name); if (type) return type; this.parser.error(name + ': undeclared'); // return undefined } /** Converts `fct:from` into `fct:to` if needed */ _cast (fct, from, to) { switch (`${to} &lt;- ${from}`) { default: this.parser.error('impossible cast from', from, 'to', to); case 'int &lt;- int': case 'float &lt;- float': case 'string &lt;- string': case 'float &lt;- int': return fct; case 'int &lt;- float': return memory =&gt; Math.round(fct(memory)); case 'int &lt;- string': return memory =&gt; parseInt(fct(memory), 10); case 'float &lt;- string': return memory =&gt; parseFloat(fct(memory)); case 'string &lt;- int': case 'string &lt;- float': return memory =&gt; String(fct(memory)); } } /** `prog: [{ decl ';' }] stmts;` returns executable */ prog (many, stmts) { return this.parser.call(this, super.prog, stmts); } /** `decl: type Name [{ ',' Name }];` */ decl (type, name, many) { [ name ].concat(many ? many[0].map(list =&gt; list[1]) : []). forEach(name =&gt; { if (this.symbols.has(name)) this.parser.error(`${name}: duplicate`); this.symbols.set(name, type[0]); }); } // type: 'int' | 'float' | 'string'; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | loop | select; /** `assign: Name '=' sum;` returns fct */ assign (name, _, sum) { const type = this._type(name), r = this.stack.pop(); if (type != r) this.parser.error(`assigning ${r} to ${type} ${name}`); return this.parser.call(this, super.assign, name, _, sum); } /** `print: 'print' sums;` returns fct, string arguments only */ print (p, sums) { if (! this.stack.splice(- sums.length, sums.length). every(type =&gt; type == 'string')) this.parser.error('can only print strings'); return this.parser.call(this, super.print, p, sums); } /** `printAny: 'print' sums;` returns fct */ printAny (p, sums) { // implicitly casts non-string arguments sums.reverse().map((sum, n) =&gt; { // check each argument const type = this.stack.pop(); // requires reverse order if (type != 'string') { sum = this._cast(sum, type, 'string'); // apply conversion puts(`print argument ${sums.length - n} was ${type}`); } return sum; // returns fct:string }).reverse(); return this.parser.call(this, super.print, p, sums); } // sums: sum [{ ',' sum }]; /** `cmp: sum rel;` returns fct */ cmp (sum, rel) { const [ l, r ] = this.stack.splice(-2, 2); if ((l == 'string' || r == 'string') &amp;&amp; l != r) this.parser.error('must compare strings to strings'); return this.parser.call(this, super.cmp, sum, rel); } // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; /** `add: '+' product;` returns `fct:string|int|float` */ add (_, right) { const [ l, r ] = this.stack.splice(-2, 2); this.stack.push(l == 'string' || r == 'string' ? 'string' : l == 'int' &amp;&amp; r == 'int' ? 'int' : 'float'); return this.parser.call(this, super.add, _, right); } /** `subtract: '-' product;` returns `fct:int|float` */ subtract (_, right) { const [ l, r ] = this.stack.splice(-2, 2); if (l == 'string' || r == 'string') this.parser.error(\"cannot apply '-' to string\"); this.stack.push(l == 'int' &amp;&amp; r == 'int' ? 'int' : 'float'); return this.parser.call(this, super.subtract, _, right); } // product: signed [{ multiply | divide }]; /** `multiply: '*' signed;` returns `fct:int|float` */ multiply (_, right) { const [ l, r ] = this.stack.splice(-2, 2); if (l == 'string' || r == 'string') this.parser.error(\"cannot apply '*' to string\"); this.stack.push(l == 'int' &amp;&amp; r == 'int' ? 'int' : 'float'); return this.parser.call(this, super.multiply, _, right); } /** `divide: '/' signed;` returns `fct:float` */ divide (_, right) { const [ l, r ] = this.stack.splice(-2, 2); if (l == 'string' || r == 'string') this.parser.error(\"cannot apply '/' to string\"); this.stack.push('float'); return this.parser.call(this, super.divide, _, right); } /** `signed: [ '-' ] term;` returns `fct:term` */ signed (minus, term) { if (minus &amp;&amp; this.stack.at(-1) == 'string') this.parser.error(\"cannot apply '-' to string\"); return this.parser.call(this, super.signed, minus, term); } /** `term: int | float | string | name | input | 'int' term | 'float' term | 'string' term | '(' sum ')';` returns `fct:term` */ // term: int | float | string | name | input // [0] // | 'int' term | 'float' term | 'string' term // [0] [1] // | '(' sum ')'; // [1] term (...val) { switch (val.length) { case 1: return val[0]; case 3: return val[1]; } const to = val[0], from = this.stack.pop(); this.stack.push(to); return this._cast(val[1], from, to); } /** `input: 'input' String String;` returns `fct.string` */ input (i, prmt, dflt) { this.stack.push('string'); return this.parser.call(this, super.input, i, prmt, dflt); } /** `int: Int;` returns `fct:int` */ int (int) { this.stack.push('int'); return this.parser.call(this, super.number, int); } /** `float: Float;` returns `fct:float` */ float (float) { this.stack.push('float'); return () =&gt; parseFloat(float); } /** `string: String;` returns `fct:string` */ string (string) { this.stack.push('string'); return this.parser.call(this, super.string, string); } /** `name: Name;` returns `fct:_type(name)` */ name (name) { this.stack.push(this._type(name)); return this.parser.call(this, super.name, name); } } /** [Example 7/04](../?eg=07/04): function calls. @extends module:Six~Machine11 */ class Machine04 extends Six.Machine11 { /** `stack: ... -&gt; ... old-pc | pc: addr` */ Call (addr) { return memory =&gt; (memory.push(memory.pc), memory.pc = addr); } /** `stack: ... old-pc -&gt; ,,, 0 old-pc` */ Entry (memory) { memory.splice(-1, 0, 0); } /** `stack: ... old-pc -&gt; ... | pc: old-pc` */ Return (memory) { memory.pc = memory.pop(); } /** `stack: ... x old-pc result -&gt; ... result old-pc result` */ ReturnValue (memory) { memory.splice(-3, 1, memory.at(-1)); } } /** [Example 7/04](../?eg=07/04): compile parameter-less functions into stack machine code. @extends module:Six~Control11 */ class Functions04 extends Six.Control11 { /** Manages next (global) variable address */ get size () { return this.#size; } set size (size) { this.#size = size; } #size = 0; /** Describes current function */ get funct () { return this.#funct; } set funct (sym) { this.#funct = sym; } #funct; /** (Inner) base class for symbol descriptions. @class @property {module:Seven~Functions04} owner - outer class. @property {string} name - variable or function name. */ get Symbol () { return this.#Symbol ??= class { owner; // surrounding class name; // variable/function name constructor (owner, name) { this.owner = owner; this.name = name; } }; } #Symbol; /** Describes a variable. @class @extends Symbol @property {number} addr - memory address. @property {function} load() - generates load instruction. @property {function} storeOk() - always true. @property {function} store() - generates store instruction. @property {function} toString() - represents as text. */ get Var () { return this.#Var ??= class extends this.Symbol { addr; // memory address constructor (owner, name, addr) { super(owner, name); this.addr = addr; } load () { // generate load instruction this.owner.machine.gen('Load', this.addr); } storeOk () { return true; } // always permit assignment store () { // generate store instruction this.owner.machine.gen('Store', this.addr); } toString () { return `${this.name} at ${this.addr}`; } }; } #Var; /** Describes a function. @class @extends Symbol @property {boolean|number} start - code address. @property {number[]} calls - slots to insert `Call`. @property {number[]} returns - slots to insert branch to exit. @property {function} entry() - generates preamble code. @property {function} undo() - undoes `entry()`. @property {function} call() - generates `Call` instruction. @property {function} return() - generates branch to exit. @property {function} storeOk() - true if allowed to store. @property {function} store() - generates store instruction. @property {function} end() - fixes `calls`/`returns`, `exit()`. @property {function} exit() - generates postamble code. @property {function} toString() - represents as text. */ get Fun () { return this.#Fun ??= class extends this.Symbol { start = false; // start address, not yet set calls = []; // forward references to entry returns = []; // forward references to exit entry () { // defines start address, arranges slot for result this.start = this.owner.machine.gen('Entry') - 1; } undo () { // ends a declaration, undoes entry() this.owner.machine.code.length = this.start; this.start = false; } call () { // create Call or save address for slot for Call if (typeof this.start == 'number') this.owner.machine.gen('Call', this.start); else this.calls.push(this.owner.machine.code.push(null) - 1); } return () { // create slot for Branch, save address this.returns.push(this.owner.machine.code.push(null) - 1); } storeOk () { // ok to store result value? if (this == this.owner.funct) return true; this.owner.parser.error(`${this.name}: ` + `assigned to outside function`); return false; } store () { // store top of stack as result value this.owner.machine.gen('ReturnValue'); } end () { // resolve calls and returns if any, exit() const call = this.owner.machine.ins('Call', this.start); this.calls.forEach(c =&gt; this.owner.machine.code[c] = call); this.calls.length = 0; const br = this.owner.machine.ins('Branch', this.owner.machine.code.length); this.returns.forEach(c =&gt; this.owner.machine.code[c] = br); this.returns.length = 0; this.exit(); } exit () { // generates code to return from function call this.owner.machine.gen('Return'); } toString () { return `function ${this.name} start ${this.start}`; } }; } #Fun; constructor (parser, machine = new Machine04()) { super(parser, machine); } /** Returns symbol description for name, if any */ _find (name, report) { const sym = this.symbols.get(name); if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); return sym; } /** (Re-)defines and returns `sym`, cannot be undefined */ _dcl (sym, report) { if (report &amp;&amp; this.symbols.get(sym.name)) this.parser.error(`${sym.name}: duplicate`); this.symbols.set(sym.name, sym); return sym; } /** Returns new `Var` at next global address. */ _alloc (name) { return new this.Var(this, name, this.size ++); } /** Flags undefined functions, returns main if defined */ _check_defs (map) { let main = undefined; map.forEach(sym =&gt; { if (sym instanceof this.Fun) if (typeof sym.start != 'number') this.parser.error(`${sym.name}: undefined function`); else if (sym.name == 'main') main = sym; }); return main; } /** Generates `Call` to `main.start` and `Print` result @param {Fun} main - describes `main()`. */ _startup (main) { this.machine.gen('Call', main.start); // call main function this.machine.gen('Print', 1); // print and pop } /** `prog: [ vars ] funs;` returns executable */ prog (v, f) { const main = this._check_defs(this.symbols), // flag undefined startAddr = this.machine.code.length, // at startup code trace = this._find('trace'), // does variable 'trace' exist? traceAddr = trace instanceof this.Var ? trace.addr : false; if (main) this._startup(main); // generate call to main else this.parser.error('main: undefined'); if (traceAddr !== false) { // if 'trace' exists puts(this.machine.toString()); // show code, this.symbols.forEach(s =&gt; puts(s.toString())); // symbols, puts('stack starts at', this.size); // variable memory size if (main) puts('execution starts at', startAddr); } return this.machine.run(this.size, startAddr, traceAddr); } // vars: 'var' names ';'; /** `names: Name [{ ',' Name }];` defines new variables, returns number of names */ names (name, some) { const dcl = name =&gt; this._dcl(this._alloc(name), true); dcl(name); if (some) some[0].forEach(list =&gt; dcl(list[1])); return 1 + (some ? some[0].length : 0); } // funs: { fun }; /** `fun: head [ 'begin' stmts 'end' ] ';';` */ fun (head, opt, _) { if (opt) head.end(); // function definition: wrap up else head.undo(); // function declaration: discard entry code this.funct = null; // not in function } /** `head: 'function' Name;` returns function symbol */ head (f, name) { let sym = this._find(name); if (! (sym instanceof this.Fun)) { if (sym instanceof this.Var) this.parser.error(`${name}: used as variable and function`); sym = this._dcl(new this.Fun(this, name)); } if (typeof sym.start == 'number') { this.parser.error(`${name}: duplicate`); sym = this._dcl(new this.Fun(this, name)); // patch } sym.entry(); // generate code for function entry return this.funct = sym; // in function } // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | loop | select; /** `assign: Name [ '=' sum ];` */ assign (name, sum) { const sym = this._find(name, true); if (sym) { if (sym instanceof this.Var) if (sum &amp;&amp; sym.storeOk()) sym.store(); // variable = sum else this.parser.error(`${name}: cannot call a variable`); else if (!sum) sym.call(); // function call else if (sym.storeOk()) sym.store(); // function = sum this.machine.gen('Pop'); // clear stack } } // print: 'print' sums; // sums: sum [{ ',' sum }]; /** `return: 'return' [ sum ];` */ return (r, sum) { if (sum &amp;&amp; this.funct.storeOk()) (this.funct.store(), this.machine.gen('Pop')); this.funct.return(); } // loop: While cmp Do stmts 'od'; // While: 'while'; // Do: 'do'; // select: 'if' cmp Then stmts [ Else stmts ] 'fi'; // Then: 'then'; // Else: 'else'; // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; /** `name: Name;` */ name (name) { const sym = this._find(name, true); if (sym instanceof this.Fun) sym.call(); else if (sym) sym.load(); } } /** [Example 7/06](../?eg=07/06): parameters and local variables. @extends module:Seven~Machine04 */ class Machine06 extends Machine04 { /** Data memory for frames. @class @extends super.Memory @property {number} fp - frame pointer. @property {number[]} frames - list of number of parameters, in reverse order of dynamic link. @property {function} mapSlot() - shows one slot @property {function} toString() - [replace] shows frames. */ get Memory () { return this.#Memory ??= class extends super.Memory { fp = 0; // global frame starts at 0 frames = [ 0 ]; // toString(): list of number of parameters toString () { let fp = this.fp, // begin of (top) frame to = this.length; // end of (top) frame return this.frames.map((parms, n) =&gt; { try { return `${fp}:[ ${this.slice(fp, to). map(slot =&gt; this.mapSlot(slot)).join(' ')} ]`; } catch (e) { throw e; // shouldn't happen } finally { to = fp; // end and begin of previous frame if (n == this.frames.length-1) fp = 0; // globals else fp = this[fp + parms + 1]; // previous frame } }).reverse().join(' '); } mapSlot (slot) { // hook to interpret slots return typeof slot == 'undefined' ? 'undefined' : slot; } }; } #Memory; /** `stack: ... arguments old-pc -&gt; ... arguments old-pc old-fp result locals` */ Entry (parms, size) { return memory =&gt; { const locals = size - parms - 3, // local variables fp = memory.length - parms - 1; // new frame's base memory.push(memory.fp, 0); // push old-fp, result if (locals) // push local variables, if any memory.push(... Array(locals).fill(0)); memory.fp = fp; // new dynamic link memory.frames.unshift(parms); // push frames stack for trace }; } /** `stack: ... arguments old-pc old-fp result locals -&gt; ... result old-pc` */ Exit (parms) { return memory =&gt; { const fp = memory.fp; // current frame memory.fp = memory[fp + parms + 1]; // restore dynamic link memory.splice(fp, Infinity, // pop frame, push result old-pc memory[fp + parms + 2], memory[fp + parms]); memory.frames.shift(); // pop frames stack (trace) }; } /** `stack: ... -&gt; ... frame[addr]` */ LoadFP (addr) { return memory =&gt; memory.push(memory[memory.fp + addr]); } /** `stack: ... val -&gt; ... val | frame[addr]: val` */ StoreFP (addr) { return memory =&gt; memory[memory.fp + addr] = memory.at(-1); } } /** [Example 7/06](../?eg=07/06): compile functions with parameters and local variables. @extends module:Seven~Functions04 */ class Parameters06 extends Functions04 { /** Describes a global or local variable. @class @extends super.Var @property {number} depth - 0: global, 1: local. @property {function} load() - [replace] global/local. @property {function} store() - [replace] global/local. */ get Var () { return this.#Var ??= class extends super.Var { depth; // 0: global, else local constructor (owner, name, addr, depth) { super(owner, name, addr); this.depth = depth; } load () { // generate load instruction if (this.depth) // local this.owner.machine.gen('LoadFP', this.addr); else // global this.owner.machine.gen('Load', this.addr); } store () { // generate store instruction if (this.depth) // local this.owner.machine.gen('StoreFP', this.addr); else // global this.owner.machine.gen('Store', this.addr); } toString () { return `${this.name} at ${this.depth ? '+' : ''}${this.addr}`; } }; } #Var; /** Describes a function with parameters and local variables. @class @extends super.Fun @property {number} parms - number of parameters. @property {number} addr - offset of function result slot in frame. @property {Map} locals - maps names to local variables. @property {number} size - size of frame. @property {function} entry() - [replace] slot for `Entry`. @property {function} setParms() - captures number of parameters, starts frame. @property {function} undo() - [extend] also reset locals. @property {function} store() - [replace] use `StoreFP`. @property {function} exit() - [replace] fill `Entry`, `Exit`. */ get Fun () { return this.#Fun ??= class extends super.Fun { parms; // number of parameters addr; // offset of function result slot in frame #locals = new Map(); // maps local names to descriptions get locals () { return this.#locals; } set locals (locals) { this.#locals = locals; } #size = 0; // next address, frame size get size () { return this.#size; } set size (size) { this.#size = size; } entry () { // defines start address, arranges slot for Entry this.start = this.owner.machine.code.push(null) - 1; } setParms () { // frame: parms, old-pc, old-fp, result if (typeof this.parms != 'undefined' &amp;&amp; this.parms != this.size) this.owner.parser.error(`${this.name} parameters: ` + `previously ${this.parms}, now ${this.size}`); this.parms = this.size; // set number of parameters this.size += 2; // leave room for old pc and old fp this.addr = this.size ++; // leave slot for result } undo () { this.locals = new Map(); // undefine parameters this.size = 0; // reset next address, frame size super.undo(); } store () { // use `StoreFP` this.owner.machine.gen('StoreFP', this.addr); } exit () { // fills Entry, generates Exit and Return this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, this.size); this.owner.machine.gen('Exit', this.parms); this.owner.machine.gen('Return'); } toString () { const names = []; this.locals.forEach(sym =&gt; names.push(sym.name)); return `function ${this.name} start ${this.start} ` + `parms ${this.parms} size ${this.size} ` + `[ ${names.join(' ')} ]`; } }; } #Fun; /** Manages a stack of contexts for assign or call to a name */ get context () { if (this.#contexts.length) return this.#contexts.at(-1); throw 'no context'; //can't happen } set context (context) { // push a value, pop with null if (context) this.#contexts.push(context); else this.#contexts.pop(); } #contexts = []; constructor (parser, machine = new Machine06()) { super(parser, machine); } /** Replace: returns new `Var` at next local/global address. */ _alloc (name) { if (this.funct) // create local variable return new this.Var(this, name, this.funct.size ++, 1); else // create global variable return new this.Var(this, name, this.size ++, 0); } /** Extend: checks local then global map, returns `sym` */ _find (name, report) { let sym; if (this.funct &amp;&amp; (sym = this.funct.locals.get(name))) return sym; // local return super._find(name, report); // global } /** Replace: sets innermost map, returns `sym` */ _dcl (sym, report) { const map = this.funct ? this.funct.locals : this.symbols; if (report &amp;&amp; map.get(sym.name)) this.parser.error(`${sym.name}: duplicate`); map.set(sym.name, sym); return sym; } /** [Extend] Push 0 for `main` parameters. @param {Fun} main - describes `main()`. */ _startup (main) { for (let p = 0; p &lt; main.parms; ++ p) this.machine.gen('Push', 0); super._startup(main); } // prog: [ vars ] funs; // vars: 'var' names ';'; // names: Name [{ ',' Name }]; // funs: { fun }; /** `fun: head parms [ block ] ';';` */ fun (head, parms, opt, _) { super.fun(head, opt); } // head: 'function' Name; /** `parms: '(' [ names ] ')';` */ parms (lp, names, rp) { this.funct.setParms(); } // block: 'begin' [ vars ] stmts 'end'; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | loop | select; /** `assign: symbol action;` codes `Pop`, pops context */ assign (symbol, action) { this.machine.gen('Pop'); this.context = null; // pop context } // action: store | call; /** `store: '=' sum;` expects context, codes assignment */ store (_, sum) { if (this.context.symbol.storeOk()) this.context.symbol.store(); } // call: args; /** `args: '(' [ sums ] ')';` expects context, codes call */ args (lp, sums, rp) { const sym = this.context.symbol, // to apply args to nargs = sums ? sums[0] : 0; // # of arguments if (!(sym instanceof this.Fun)) this.parser.error(`${sym.name}: not a function`); else if (nargs != sym.parms) this.parser.error(`${sym.name} arguments: ` + `expected ${sym.parms}, specified ${nargs}`); else sym.call(); // call function } // print: 'print' sums; // sums: sum [{ ',' sum }]; // return: 'return' [ sum ]; // loop: While cmp Do stmts 'od'; // While: 'while'; // Do: 'do'; // select: 'if' cmp Then stmts [ Else stmts ] 'fi'; // Then: 'then'; // Else: 'else'; // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; /** `name: symbol [ args ];` codes variable load, pops context */ name (sym, args) { if (!args) if (sym instanceof this.Fun) this.parser.error(`${sym.name}: no argument list`); else sym.load(); // variable reference this.context = null; // pop context } /** `symbol: Name;` pushes context, returns symbol */ symbol (name) { let sym = this._find(name, true); if (!sym) sym = this._dcl(this._alloc(name)); // patch this.context = { symbol: sym }; // push symbol description return sym; } } /** [Example 7/09](../?eg=07/09): compile global functions with block structure. @extends module:Seven~Parameters06 */ class Blocks09 extends Parameters06 { /** Describes a function with block structure. @class @extends super.Fun @property {Block[]} blocks - block stack, [0] is innermost @property {number} frameSize - must replace `size` @property {Map} locals - [replace] delegate to blocks @property {number} size - [replace] delegate to blocks @property {function} push() - add a block @property {function} pop() - end a block, maintain size @property {function} end() - [extend] pop last block @property {function} exit() - [replace] use `frameSize` */ get Fun () { return this.#Fun ??= class extends super.Fun { frameSize = 0; // because this.size is local to blocks blocks; // block stack, [0] is innermost block get locals () { return this.blocks[0].locals; } set locals (locals) { try { return this.blocks[0].locals = locals; } catch (e) { console.trace(e); throw e; } } get size () { return this.blocks[0].size; } set size (size) { return this.blocks[0].size = size; } constructor (owner, name) { // creates outermost block super(owner, name); this.blocks = [ new this.owner.Block(0) ]; } push () { // add block, start in encompassing block this.blocks.unshift( new this.owner.Block(this.blocks[0].size) ); } pop () { // remove block, maintain maximum frame size this.frameSize = Math.max(this.frameSize, this.blocks[0].size); if (this.owner.symbols.get('trace') // trace? instanceof this.owner.Var) puts(this.blocks[0].toString()); this.blocks.shift(); } end () { // [extend] pop outermost block this.pop(); super.end(); } exit () { // [replace] uses frameSize this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, this.frameSize); this.owner.machine.gen('Exit', this.parms); this.owner.machine.gen('Return'); } toString () { // [replace] no symbols, show frameSize return `function ${this.name} start ${this.start} ` + `parms ${this.parms} frame size ${this.frameSize}`; } }; } #Fun; /** Describes a block of nested symbols. @class @property {Map} locals - maps names to descriptions. @property {number} size - next variable address in block. @property {function} toString() - describes as text. */ get Block () { return this.#Block ??= class { locals = new Map(); // maps names in block to descriptions size; // next variable address in block constructor (size) { this.size = size; } toString () { const names = []; this.locals.forEach(sym =&gt; names.push(sym.toString())); return `block [ ${names.join(', ')} ]`; } }; } #Block; /** Replace: searches innermost to outermost blocks and global */ _find (name, report) { let sym; try { if (this.funct) // loop inner to outer block this.funct.blocks.forEach(block =&gt; { sym = block.locals.get(name); if (typeof sym != 'undefined') throw sym; }); return sym = this.symbols.get(name); // global } catch (sym) { // found in a block if (sym instanceof Error) throw sym; // shouldn't happen return sym; } finally { if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); } } // prog: [ vars ] funs; // vars: 'var' names ';'; // names: Name [{ ',' Name }]; // funs: { fun }; // fun: head parms [ block ] ';'; // head: 'function' Name; // parms: '(' [ names ] ')'; /** `block: begin [ vars ] stmts 'end';` */ block (b, v, s, e) { this.funct.pop(); } /** `begin: 'begin';` */ begin (b) { this.funct.push(); } // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | block | loop | select; // assign: symbol action; // action: store | call; // store: '=' sum; // call: args; // args: '(' [ sums ] ')'; // print: 'print' sums; // sums: sum [{ ',' sum }]; // return: 'return' [ sum ]; /** `loop: While cmp Do [ vars ] stmts 'od';` */ loop (While, c, Do, v, s, o) { this.funct.pop(); super.loop(While, c, Do); } // While: 'while'; /** `Do: 'do';` */ Do () { this.funct.push(); return super.Do(); } /** `select: 'if' cmp then [ else ] 'fi';` */ select(i, c, t, e, f) { // select: 'if' cmp Then stmts [ Else stmts ] 'fi'; super.select(i, c, t, false, e); } /** `then: Then [ [ vars ] stmts ];` */ then (t, opt) { this.funct.pop(); return t; } /** `else: Else [ vars ] stmts;` */ else (e, v, s) { this.funct.pop(); return e; } /** `Then: 'then';` */ Then (t) { this.funct.push(); return super.Then(); } /** `Else: 'else';` */ Else (e) { this.funct.push(); return super.Else(); } // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: symbol [ args ]; // symbol: Name; } /** [Example 7/13](../?eg=07/13): nested functions @extends module:Seven~Machine06 */ class Machine13 extends Machine06 { /** Data memory for nested functions. @class @extends super.Memory @property {number} dp - display (static link) pointer. @property {number[]} frames - [remove]: unused. @property {function} toString() - [replace]: uses `dp`. */ get Memory () { return this.#Memory ??= class extends super.Memory { dp = 0; // display (static link) pointer // frames[] is no longer used toString () { let fp = this.fp, // begin of (top) frame to = this.length, // end of (top) frame dp = this.dp, // static link output = []; do { if (!dp) fp = 0; // global frame output.unshift(`${fp}:[ ${this.slice(fp, to). map(slot =&gt; this.mapSlot(slot)).join(' ')} ]`); to = fp; // end and begin of previous frame fp = this[dp - 2]; // previous frame pointer dp = this[dp - 1]; // previous static link } while (to); return output.join(' '); } }; } #Memory; /** `stack: ... arguments old-pc -&gt; ... arguments old-pc old-fp old-dp result display locals` */ Entry (parms, depth, size) { return memory =&gt; { const locals = size - parms - 4 - depth, // local variables fp = memory.length - parms - 1, // new frame's base dp = memory.length + 2; // new display's bottom // push old-fp, old-dp, result memory.push(memory.fp, memory.dp, 0); if (depth &gt; 1) memory.push( // push part of display ... memory.slice(memory.dp + 1, memory.dp + depth) ); memory.push(fp); // push new frame's base if (locals) // push local variables if any memory.push(... Array(locals).fill(0)); memory.fp = fp; // new dynamic link memory.dp = dp; // new display's bottom }; } /** `stack: ... arguments old-pc old-fp old-dp result display locals -&gt; ... result old-pc` */ Exit (memory) { const fp = memory.fp, // current frame, i.e., @arguments dp = memory.dp; // current display, i.e., @result memory.fp = memory[dp - 2]; // restore old-fp memory.dp = memory[dp - 1]; // restore old-dp // pop frame, push old-pc result memory.splice(fp, Infinity, memory[dp], memory[dp - 3]); } /** `stack: ... -&gt; ... frame[depth][addr]` */ LoadDP (addr, depth) { return memory =&gt; memory.push(memory[memory[memory.dp + depth] + addr]); } /** `stack: ... val -&gt; ... val | frame[depth][addr]: val` */ StoreDP (addr, depth) { return memory =&gt; memory[memory[memory.dp+depth] + addr] = memory.at(-1); } } /** [Example 7/13](../?eg=07/13): add actions and infrastructure to compile nested functions. @mixin */ const Nest13 = superclass =&gt; class extends superclass { /** List of inner to outer nested frames, `null` at end. @instance @memberof module:Seven~Nest13 */ get functs () { return this.#functs; } // current function stack #functs = [ null ]; /** Replace: manage stack of functions @instance @memberof module:Seven~Nest13 */ get funct () { return this.functs[0]; } set funct (sym) { if (sym) this.functs.unshift(sym); // push function else this.functs.shift(); // pop function } constructor (parser, machine = new Machine13()) { super(parser, machine); } /** Describes a global or nested variable in {@linkcode module:Seven-Nest13 Nest13}. @instance @memberof module:Seven~Nest13 @class @extends super.Var @property {number} depth - [extend] `&gt;=1`: nested. @property {function} load() - [replace] use `depth`. @property {function} store() - [replace] use `depth` @property {function} toString() - [replace] show `depth`. */ get Var () { return this.#Var ??= class extends super.Var { load () { // [replace] load by depth if (!this.depth) // global this.owner.machine.gen('Load', this.addr); else if (this.depth+1 != this.owner.functs.length)// nested this.owner.machine.gen('LoadDP', this.addr, this.depth); else // local this.owner.machine.gen('LoadFP', this.addr); } store () { // [replace] store by depth if (!this.depth) // global this.owner.machine.gen('Store', this.addr); else if (this.depth+1 != this.owner.functs.length)// nested this.owner.machine.gen('StoreDP', this.addr, this.depth); else // local this.owner.machine.gen('StoreFP', this.addr); } toString () { if (!this.depth) return `${this.name} at ${this.addr}`; else return `${this.name} at ${this.addr}d${this.depth}`; } }; } #Var; /** Returns new `Var` at next local/global address. @instance @memberof module:Seven~Nest13 */ _alloc (name) { if (this.funct) // create local variable return new this.Var(this, name, this.funct.size ++, this.funct.depth); else // create global variable return new this.Var(this, name, this.size ++, 0); } /** Describes a nested function with block structure in {@linkcode module:Seven-Nest13 Nest13}. @instance @memberof module:Seven~Nest13 @class @extends super.Fun @property {number} depth - length of static link @property {undefined|Block} scope - `.locals` contains `this` @property {function} entry() - [extend] create bypass @property {function} setParms() - [extend] room for display @property {function} storeOk() - [replace] consider outer functions @property {function} store() - [replace] consider `depth` @property {function} pop() - [extend] check for undefined functions @property {function} exit() - [replace] use `depth`, fix bypass @property {function} toString () - [extend] display depth */ get Fun () { return this.#Fun ??= class extends super.Fun { depth; // length of static link, 1 for global function constructor (owner, name) { // sets depth from owner.functs super(owner, name); this.depth = owner.functs.length; // functs[.. null] } entry () { // [extend] make room for bypass if (this.depth &gt; 1) { // nested function // remember where this is defined this.scope = this.owner.funct.blocks[0]; if (typeof this.scope.bypass == 'undefined') this.scope.bypass = // make room for bypass branch this.owner.machine.code.push(null) - 1; } super.entry(); } setParms () { // frame: parms, old-pc, old-fp, old-dp, result super.setParms(); this.addr = this.size ++; // insert slot for old-dp this.size += this.depth; // leave slots for display } storeOk () { // [replace] consider outer functions if (this.owner.functs.some(f =&gt; f == this)) return true; this.owner.parser.error(`${this.name}: ` + `assigned to outside function`); return false; } store () { // [replace] consider depth if (this == this.owner.funct) // local this.owner.machine.gen('StoreFP', this.addr); else // outer function this.owner.machine.gen('StoreDP', this.addr, this.depth); } pop () { // [extend] check for undefined functions this.owner._check_defs(this.locals); super.pop(); } exit () { // [replace] uses depth, fixes bypass this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, this.depth, this.frameSize); this.owner.machine.gen('Exit'); // needs no parms info const end = this.owner.machine.gen('Return'); if (this.scope) // need to repair bypass this.owner.machine.code[this.scope.bypass] = this.owner.machine.ins('Branch', end); } toString () { // [extend] display depth return super.toString() + ` depth ${this.depth}`; } }; } #Fun; /** Describes a block of nested symbols. @instance @memberof module:Seven~Nest13 @class Block extends super.Block @property {undefined|number} bypass - address of branch to bypass nested function definitions */ /** Replace: searches blocks, functions, and global. @instance @memberof module:Seven~Nest13 */ _find (name, report) { let sym; try { this.functs.forEach(funct =&gt; { // loop inner to outer funct if (funct) // loop inner to outer block funct.blocks.forEach(block =&gt; { sym = block.locals.get(name); if (typeof sym != 'undefined') throw sym; }); }); return sym = this.symbols.get(name); // global } catch (sym) { // found in a block if (sym instanceof Error) throw sym; // shouldn't happen return sym; } finally { if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); } } // prog: [ vars ] funs; // vars: 'var' names ';'; // names: Name [{ ',' Name }]; // funs: { fun }; // fun: head parms [ block ] ';'; /** `head: 'function' Name;` returns function symbol. @instance @memberof module:Seven~Nest13 */ head (_, name) { let sym = this._find(name); try { if (sym instanceof this.Fun) { if (sym.depth &gt;= this.functs.length) { // same nesting level if (typeof sym.start != 'number') throw true; // forward this.parser.error(`${name}: duplicate`); } // else define at deeper nesting level } else if (sym instanceof this.Var &amp;&amp; // same nesting level sym.depth &gt;= this.functs.length - 1) this.parser.error(`${name}: used as variable and function`); sym = this._dcl(new this.Fun(this, name)); // (re-)define } catch (e) { throw e; // shouldn't happen } finally { sym.entry(); // generate code for function entry return this.funct = sym; // in function } } // parms: '(' [ names ] ')'; /** `block: begin body 'end';` [inherit]. @instance @memberof module:Seven~Nest13 */ block (b, body, e) { super.block(b, undefined, undefined, e); } // begin: 'begin'; // body: [ vars ] [ funs ] stmts; // stmts: stmt [{ ';' stmt }]; // stmt: assign | print | return | block | loop | select; // assign: symbol action; // action: store | call; // store: '=' sum; // call: args; // args: '(' [ sums ] ')'; // print: 'print' sums; // sums: sum [{ ',' sum }]; // return: 'return' [ sum ]; /** `loop: While cmp Do body 'od';` [inherit] @instance @memberof module:Seven~Nest13 */ loop (While, cmp, Do, body, od) { super.loop(While, cmp, Do, undefined, undefined, od); } // While: 'while'; // Do: 'do'; // select: 'if' cmp then [ else ] 'fi'; // then: Then [ body ]; /** `else: Else body;` [inherit] @instance @memberof module:Seven~Nest13 */ else (e, b) { return super.else(e, undefined, undefined); } // Then: 'then'; // Else: 'else'; // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; // ne: '&lt;&gt;' sum; // gt: '&gt;' sum; // ge: '&gt;=' sum; // lt: '&lt;' sum; // le: '&lt;=' sum; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: symbol [ args ]; // symbol: Name; }; export { TCheck01, TCheck02, Machine04, Functions04, Machine06, Parameters06, Blocks09, Machine13, Nest13 }; × Search results Close "},"06.js.html":{"id":"06.js.html","title":"Source: 06.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 06.js /** This module contains the classes for all examples in chapter six. @module Six @author © 2023 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; @version 2024-02-27 */ /** [Example 6/02](../?eg=06/02): actions to support signed numbers. */ class Eval02 { // list: sum [{ ',' sum }]; /** `sum: product [{ add | subtract }];` */ sum (product, many) { puts(g.dump(product)); } // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; /** `signed: [ '-' ] term;` */ signed (minus, term) { return minus ? - term : term; } /** `term: number | '(' sum ')';` */ term (...val) { return val.length == 1 ? val[0] : val[1]; } /** `number: Number;` */ number (number) { return parseInt(number, 10); } } /** [Example 6/03](../?eg=06/03): adds actions to support multiplication and division. @extends module:Six~Eval02 */ class Eval03 extends Eval02 { // list: sum [{ ',' sum }]; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; /** `product: signed [{ multiply | divide }];` */ product (signed, many) { return (many ? many[0] : [ ]). reduce((product, list) =&gt; list[0](product), signed); } /** `multiply: '*' signed;` */ multiply (_, right) { return left =&gt; left * right; } /** `divide: '/' signed;` */ divide (_, right) { return left =&gt; left / right; } // signed: [ '-' ] term; // term: number | '(' sum ')'; // number: Number; } /** [Example 6/04](../?eg=06/04): adds actions to support lists of numerical expressions. @extends module:Six~Eval03 */ class Eval04 extends Eval03 { /** `list: sum [{ ',' sum }];` */ list (sum, many) { puts(sum); if (many) many[0].forEach(seq =&gt; puts(seq[1])); } /** `sum: product [{ add | subtract }];` */ sum (product, many) { return this.product(product, many); } /** `add: '+' product;` */ add (_, right) { return left =&gt; left + right; } /** `subtract: '-' product;` */ subtract (_, right) { return left =&gt; left - right; } // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: number | '(' sum ')'; // number: Number; } /** [Example 6/05](../?eg=06/05): adds actions to support variable names. @extends module:Six~Eval04 */ class Functions05 extends Eval04 { #parser; // for error messages get parser () { return this.#parser; } constructor (parser) { super(); this.#parser = parser; } // list: sum [{ ',' sum }]; /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ // arg [1] [3] [0] [1] sum (... arg) { if (arg.length &lt; 4) return this.parser.call(this, super.sum, arg[0], arg[1]); if (!this.memory) this.memory = { }; return this.memory[arg[1]] = arg[3]; } // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: number | name | '(' sum ')'; // number: Number; /** `name: Name;` returns value or `0` */ name (name) { if (!this.memory) this.memory = { }; return name in this.memory ? this.memory[name] : 0; } } /** [Example 6/06](../?eg=06/06): changes actions to support returning names, numbers, and input as functions. @extends module:Six~Functions05 */ class Functions06 extends Functions05 { // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` returns fct */ input (_, number) { const dflt = String(number !== null ? number[0] : 0); return () =&gt; parseInt(prompt('input', dflt), 10); } /** `number: Number;` returns fct */ number (number) { const result = parseInt(number, 10); return () =&gt; result; } /** `name: Name;` returns fct */ name (name) { return memory =&gt; name in memory ? memory[name] : 0; } } /** [Example 6/07](../?eg=06/07): changes remaining actions to support returning arithmetic expressions as functions. @extends module:Six~Functions06 */ class Functions07 extends Functions06 { /** `list: sum [{ ',' sum }];` returns executable */ list (sum, many) { const list = [ sum ]. concat(many ? many[0].map(seq =&gt; seq[1]) : [ ]); return () =&gt; { const memory = { }; puts(... list.map(fct =&gt; fct(memory))); } } /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ // [1] [3] [0] [1] sum (... arg) { if (arg.length == 4) return memory =&gt; memory[arg[1]] = arg[3](memory); else return this.product(arg[0], arg[1]); } /** `add: '+' product;` returns fct for composition */ add (_, right) { return left =&gt; memory =&gt; left(memory) + right(memory); } /** `subtract: '-' product;` returns fct for composition */ subtract (_, right) { return left =&gt; memory =&gt; left(memory) - right(memory); } /** `product: signed [{ multiply | divide }];` returns fct */ product (signed, many) { const c = (a, b) =&gt; b(a); // function composition return (many ? many[0] : []). reduce((product, list) =&gt; c(product, list[0]), signed); } /** `multiply: '*' signed;` returns fct for composition */ multiply (_, right) { return left =&gt; memory =&gt; left(memory) * right(memory); } /** `divide: '/' signed;` returns fct for composition */ divide (_, right) { return left =&gt; memory =&gt; left(memory) / right(memory); } /** `signed: [ '-' ] term;` returns fct */ signed (minus, term) { return minus ? memory =&gt; - term(memory) : term; } // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: Name; } /** [Example 6/08](../?eg=06/08): actions to convert to postfix. */ class Postfix08 { // sum: product [{ add | subtract }]; /** `add: '+' right;` */ add (_, r) { puts('add'); } /** `subtract: '-' right;` */ subtract (_, r) { puts('subtract'); } // product: signed [{ multiply | divide }]; /** `multiply: '*' right;` */ multiply (_, r) { puts('multiply'); } /** `divide: '/' signed;` */ divide (_, r) { puts('divide'); } /** `signed: [ '-' ] term;` */ signed (minus, t) { if (minus) puts('minus'); } // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` */ input (i, n) { puts('input'); } /** `number: Number;` */ number (number) { puts(number); } /** `name: Name;` */ name (name) { puts(name); } } /** [Example 6/09](../?eg=06/09): stack machine. */ class Machine09 { code = [ ]; // holds the instructions /** Represents `code` as text */ toString () { return this.code.map((f, n) =&gt; n + ': ' + f).join('\\n'); } /** Creates stack machine */ run (memorySize) { return () =&gt; { const memory = Array(memorySize).fill(0); // create memory this.code.forEach(code =&gt; code(memory)); // execute return memory; }; } } /** [Example 6/09](../?eg=06/09): actions to generate stack machine code. */ class Arithmetic09 { #parser; // for error messages get parser () { return this.#parser; } #machine; // handles execution get machine () { return this.#machine; } #symbols = new Map(); // symbol table, maps names to addresses get symbols () { return this.#symbols; } constructor (parser, machine = new Machine09 ()) { this.#parser = parser; this.#machine = machine; } /** Returns memory address for name */ _alloc (name) { let addr = this.symbols.get(name); // known name? if (typeof addr == 'undefined') this.symbols.set(name, // new name addr = this.symbols.size); // allocate, starting at 0 return addr; } /** `list: stmt [{ ';' stmt }];` */ list (s, many) { puts(this.machine.toString()); // show code this.symbols.forEach( // show variables (value, name) =&gt; puts(name, 'at', value)); const size = this.symbols.size; // number of variables puts('stack starts at', size); return this.machine.run(size); // stack machine } /** `stmt: sum;` */ stmt (s) { // print and clear stack this.machine.code.push(memory =&gt; puts(memory.pop())); } /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ sum (...val) { if (val.length &lt; 4) return; const addr = this._alloc(val[1]); this.machine.code.push(memory =&gt; memory[addr] = memory.at(-1)); } /** `add: '+' right;` */ add (_, r) { this.machine.code.push( memory =&gt; memory.splice(-2, 2, memory.at(-2) + memory.at(-1)) ); } /** `subtract: '-' right;` */ subtract (_, r) { this.machine.code.push( memory =&gt; memory.splice(-2, 2, memory.at(-2) - memory.at(-1)) ); } // product: signed [{ multiply | divide }]; /** `multiply: '*' right;` */ multiply (_, r) { this.machine.code.push( memory =&gt; memory.splice(-2, 2, memory.at(-2) * memory.at(-1)) ); } /** `divide: '/' signed;` */ divide (_, r) { this.machine.code.push( memory =&gt; memory.splice(-2, 2, memory.at(-2) / memory.at(-1)) ); } /** `signed: [ '-' ] term;` */ signed (minus, t) { if (minus) this.machine.code.push( memory =&gt; memory.splice(-1, 1, -memory.at(-1)) ); } // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` */ input (_, number) { const dflt = String(number !== null ? number[0] : 0); this.machine.code.push( memory =&gt; memory.push(parseInt(prompt('input', dflt), 10)) ); } /** `number: Number;` */ number (number) { const result = parseInt(number, 10); this.machine.code.push(memory =&gt; memory.push(result)); } /** `name: Name;` */ name (name) { const addr = this._alloc(name); this.machine.code.push(memory =&gt; memory.push(memory[addr])); } } /** [Example 6/10](../?eg=06/10): stack machine with mnemonics. @extends module:Six~Machine09 */ class Machine10 extends Machine09 { /** returns `code.length` */ gen (name, ... args) { return this.code.push(this.ins(name, ... args)); } /** returns instruction function */ ins (name, ... args) { return args.length ? eval(`memory =&gt; this.${name}(${args.join(', ')})(memory)`) : eval(`memory =&gt; this.${name}(memory)`); } /** `stack: ... a b -&gt; ... a+b` */ Add (memory) { memory.splice(-2, 2, memory.at(-2) + memory.at(-1)); } /** `stack: ... a b -&gt; ... a/b` */ Divide (memory) { memory.splice(-2, 2, memory.at(-2) / memory.at(-1)); } /** `stack: ... -&gt; ... input` */ Input (dflt) { dflt = String(dflt); return memory =&gt; memory.push(parseInt(prompt('input', dflt), 10)); } /** `stack: ... -&gt; ... memory[addr]` */ Load (addr) { return memory =&gt; memory.push(memory[addr]); } /** `stack: ... a -&gt; ... -a` */ Minus (memory) { memory.splice(-1, 1, -memory.at(-1)); } /** `stack: ... a b -&gt; ... a*b` */ Multiply (memory) { memory.splice(-2, 2, memory.at(-2) * memory.at(-1)); } /** `stack: ... val -&gt; ...` */ Pop (memory) { memory.pop(); } /** `stack: ... -&gt; ... result` */ Push (result) { return memory =&gt; memory.push(result); } /** `stack: ... val -&gt; ... | puts(val)` */ Puts (memory) { puts(memory.at(-1)); } /** `stack: ... val -&gt; ... val | memory[a]: val` */ Store (a) { return memory =&gt; memory[a] = memory.at(-1); } /** `stack: ... a b -&gt; ... a-b` */ Subtract (memory) { memory.splice(-2, 2, memory.at(-2) - memory.at(-1)); } } /** [Example 6/10](../?eg=06/10): actions to generate mnemonic stack machine code. @extends module:Six~Machine09 */ class Arithmetic10 extends Arithmetic09 { constructor (parser, machine = new Machine10()) { super(parser, machine); } // list: stmt [{ ';' stmt }]; /** `stmt: sum;` */ stmt (s) { // print and clear stack this.machine.gen('Puts'); this.machine.gen('Pop'); } /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ sum (...val) { if (val.length &lt; 4) return; this.machine.gen('Store', this._alloc(val[1])); } /** `add: '+' product;` */ add () { this.machine.gen('Add'); } /** `subtract: '-' product;` */ subtract () { this.machine.gen('Subtract'); } // product: signed [{ multiply | divide }]; /** `multiply: '*' signed;` */ multiply () { this.machine.gen('Multiply'); } /** `divide: '/' signed;` */ divide () { this.machine.gen('Divide'); } // /** `signed: [ '-' ] term;` */ signed (minus, t) { if (minus) this.machine.gen('Minus'); } // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` */ input (i, number) { this.machine.gen('Input', number !== null ? number[0] : 0); } /** `number: Number;` */ number (number) { const result = parseInt(number, 10); this.machine.gen('Push', result); } /** `name: Name;` */ name (name) { this.machine.gen('Load', this._alloc(name)); } } /** [Example 6/11](../?eg=06/11): branches, stepping, and tracing. @extends module:Six~Machine10 */ class Machine11 extends Machine10 { /** Returns trace function, if any */ trace (address) { if (address === true) // unconditional trace return (memory, pc) =&gt; // traces instruction at pc puts(memory.toString(), pc+':', this.code[pc].toString()); if (typeof address == 'number') // address of control variable? return (memory, pc) =&gt; { // traces instruction at pc if (memory[address] &gt;= 0) // variable at addr non-negative? puts(memory.toString(), pc+':', this.code[pc].toString()); }; } /** Data memory. @class extends Array @property {number} pc - program counter. @property {boolean} continue - true if execution can be continued. @property {function} toString() - represents as text. */ get Memory () { return this.#Memory ??= class extends Array { toString () { return '[ ' + this.join(' ') + ' ]'; } }; } #Memory; /** Returns stack machine executable */ run (size, startAddr = 0, traceAddr) { let t; // [closure] trace function, if any const StackMachine = (memory, steps) =&gt; { if (!memory) { // initialize? if (steps) t = this.trace(true); // steps? permanent trace else { // no steps: don't suspend t = this.trace(traceAddr); steps = Infinity; } memory = new this.Memory(size).fill(0); // create memory memory.pc = startAddr; // initialize program counter t &amp;&amp; puts(memory.toString()); // initial memory } while (steps -- &amp;&amp; memory.pc &lt; this.code.length) { // steps? const pc = memory.pc ++; // advance program counter this.code[pc](memory); // execute at previous pc t &amp;&amp; t(memory, pc); // trace executed instruction } memory.continue = memory.pc &lt; this.code.length; // again? return memory; }; return (memory, steps) =&gt; StackMachine(memory, steps); } /** `stack: ... -&gt; ... | pc: a` */ Branch (a) { return memory =&gt; memory.pc = a; } /** `stack: ... bool -&gt; ... | pc: !bool? a` */ Bzero (a) { return memory =&gt; { if (!memory.pop()) memory.pc = a; } } /** `stack: ... a b -&gt; ... a == b` */ Eq (memory) { memory.splice(-2, 2, memory.at(-2) == memory.at(-1)); } /** `stack: ... a b -&gt; ... a &gt;= b` */ Ge (memory) { memory.splice(-2, 2, memory.at(-2) &gt;= memory.at(-1)); } /** `stack: ... a b -&gt; ... a &gt; b` */ Gt (memory) { memory.splice(-2, 2, memory.at(-2) &gt; memory.at(-1)); } /** `stack: ... a b -&gt; ... a &lt;= b` */ Le (memory) { memory.splice(-2, 2, memory.at(-2) &lt;= memory.at(-1)); } /** `stack: ... a b -&gt; ... a &lt; b` */ Lt (memory) { memory.splice(-2, 2, memory.at(-2) &lt; memory.at(-1)); } /** `stack: ... a b -&gt; ... a != b` */ Ne (memory) { memory.splice(-2, 2, memory.at(-2) != memory.at(-1)); } /** `stack: ... n*val -&gt; ...` */ Print (n) { return memory =&gt; puts(... memory.splice(- n)); } } /** [Example 6/11](../?eg=06/11): compile a little language into stack machine code. @extends module:Six~Arithmetic10 */ class Control11 extends Arithmetic10 { constructor (parser, machine = new Machine11()) { super(parser, machine); } /** `prog: stmts;` returns executable */ prog (_) { const size = this.symbols.size, // number of variables traceAddr = this.symbols.get('trace'); // if a variable named if (typeof traceAddr != 'undefined') { // ...'trace' exists puts(this.machine.toString()); // show code this.symbols.forEach( // show variable addresses (addr, name) =&gt; puts(`${name} at ${addr}`) ); puts('stack starts at', size); } return this.machine.run(size, 0, traceAddr); // stack machine } // stmts: stmt [{ ';' stmt }]; /** `stmt: assign | print | loop | select;` [replace] no op */ stmt (stmt) { } /** `assign: Name '=' sum;` stores and pops stack */ assign (name, e, s) { this.machine.gen('Store', this._alloc(name)); this.machine.gen('Pop'); } /** `print: 'print' sums;` */ print (_, sums) { this.machine.gen('Print', sums); } /** `sums: sum [{ ',' sum }];` returns number of values */ sums (sum, many) { return 1 + (many ? many[0].length : 0); } /** `loop: While cmp Do stmts 'od';` */ loop (While, _, Do, s, o) { const od = this.machine.gen('Branch', While); this.machine.code[Do] = this.machine.ins('Bzero', od); } /** `While: 'while';` returns address for branch to `while` */ While (w) { return this.machine.code.length; } /** `Do: 'do';` returns address of slot for bzero to `od` */ Do (d) { return this.machine.code.push(null) - 1; } /** `select: 'if' cmp Then stmts [ Else stmts ] 'fi';` */ select (i, c, Then, s, Else, f) { const fi = this.machine.code.length; // address of 'fi' if (Else) { Else = Else[0]; // address after branch to 'fi' this.machine.code[Then] = this.machine.ins('Bzero', Else); this.machine.code[Else - 1] = this.machine.ins('Branch', fi); } else this.machine.code[Then] = this.machine.ins('Bzero', fi); } /** `Then: 'then';` returns address for bzero to `else` `fi` */ Then (t) { return this.machine.code.push(null) - 1; } /** `Else: 'else';` creates slot for branch to `fi`, returns address of `else` */ Else (e) { return this.machine.code.push(null); } // cmp: sum rel; // rel: eq | ne | gt | ge | lt | le; /** `eq: '=' sum;` */ eq () { this.machine.gen('Eq'); } /** `ne: '&lt;&gt;' sum;` */ ne () { this.machine.gen('Ne'); } /** `gt: '&gt;' sum;` */ gt () { this.machine.gen('Gt'); } /** `ge: '&gt;=' sum;` */ ge () { this.machine.gen('Ge'); } /** `lt: '&lt;' sum;` */ lt () { this.machine.gen('Lt'); } /** `le: '&lt;=' sum;` */ le () { this.machine.gen('Le'); } // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: Name; } /** [Example 6/12](../?eg=06/12): compile a little language into JavaScript functions. @extends module:Six~Functions07 */ class Functions12 extends Functions07 { /** `prog: stmts;` returns executable */ prog (stmts) { return () =&gt; stmts({ }); } /** `stmts: stmt [{ ';' stmt }];` returns fct */ stmts (stmt, many) { return (many ? many[0] : []). reduce((left, list) =&gt; memory =&gt; (left(memory), list[1][0](memory)), stmt[0]); } // stmt: assign | print | loop | select; /** `assign: Name '=' sum;` returns fct */ assign (name, e, sum) { return memory =&gt; memory[name] = sum(memory); } /** `print: 'print' sums;` returns function */ print (p, sums) { return memory =&gt; puts(... sums.map(fct =&gt; fct(memory))); } /** `sums: sum [{ ',' sum }];` returns list of functions */ sums (sum, many) { return [ sum ].concat(many ? many[0].map(seq =&gt; seq[1]) : []); } /** `loop: 'while' cmp 'do' stmts 'od';` returns fct */ loop (w, cmp, d, stmts, o) { return memory =&gt; { while (cmp(memory)) stmts(memory); }; } /** `select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi';` returns fct */ select (i, cmp, t, stmts, opt, f) { return opt ? (memory =&gt; cmp(memory) ? stmts(memory) : opt[1](memory)) : (memory =&gt; { if (cmp(memory)) stmts(memory); }); } /** `cmp: sum rel;` returns fct */ cmp (sum, rel) { return memory =&gt; rel[0](sum)(memory); } // rel: eq | ne | gt | ge | lt | le; /** `eq: '=' expr;` returns fct for composition */ eq (_, right) { return left =&gt; memory =&gt; left(memory) == right(memory); } /** `ne: '&lt;&gt;' expr;` returns fct for composition */ ne (_, right) { return left =&gt; memory =&gt; left(memory) != right(memory); } /** `gt: '&gt;' expr;` returns fct for composition */ gt (_, right) { return left =&gt; memory =&gt; left(memory) &gt; right(memory); } /** `ge: '&gt;=' expr;` returns fct for composition */ ge (_, right) { return left =&gt; memory =&gt; left(memory) &gt;= right(memory); } /** `lt: '&lt;' expr;` returns fct for composition */ lt (_, right) { return left =&gt; memory =&gt; left(memory) &lt; right(memory); } /** `le: '&lt;=' expr;` returns fct for composition */ le (_, right) { return left =&gt; memory =&gt; left(memory) &lt;= right(memory); } /** `sum: product [{ add | subtract }];` returns fct */ sum (product, many) { return this.product(product, many); } // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; // input: 'input' [ Number ]; // number: Number; // name: Name; } export { Eval02, Eval03, Eval04, Functions05, Functions06, Functions07, Postfix08, Arithmetic09, Machine09, Arithmetic10, Machine10, Control11, Machine11, Functions12 }; × Search results Close "},"10.js.html":{"id":"10.js.html","title":"Source: 10.js","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Source: 10.js /** This module contains classes for some examples in chapter ten. * * @module Ten * @author © 2024 Axel T. Schreiner &lt;axel@schreiner-family.net&gt; * @version 2024-02-26 */ /** [Example 10/07](../?mode=stack&amp;eg=10/07): immediate evaluation. */ class Actions07 { /** `expr: add | subtract | ... | '(' expr ')' | number;` */ expr (... arg) { return arg.length &gt; 1 ? arg[1] : arg[0]; } /** `add: expr '+' expr;` */ add (a, x, b) { return a + b; } /** `subtract: expr '-' expr;` */ subtract (a, x, b) { return a - b; } /** `multiply: expr '*' expr;` */ multiply (a, x, b) { return a * b; } /** `divide: expr '/' expr;` */ divide (a, x, b) { return a / b; } /** `power: expr '**' expr;` */ power (a, x, b) { return a ** b; } /** `number: Number;` */ number (number) { return parseInt(number, 10); } } /** [Example 10/09](../?mode=stack&amp;eg=10/09): unary minus. */ class Actions09 extends Actions07 { minus (x, a) { return - a; } } export { Actions07, Actions09 }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Modules × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Classes × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixins × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Interactive Introduction to Compiler Construction links The Book e-Book PDF Book, thanks to prince Examples The Practice Page The Method Browser Sources and Documentation source documentation ebnf.js LL(1) Parser Generator bnf.js SLR(1) Parser Generator base.js Common Code practice.js Model for Practice Page index.js Graphical User Interface for the Model script.js Scripting the Model 06.js 6. Compiling Little Languages 07.js 7. Language Features 08.js 8. Functions as Values 10.js 10. Recognition Revisited 11.js 11. Compiling Revisited Syntax highlighting is produced using Sunlight. × Search results Close "},"module-BNF.html":{"id":"module-BNF.html","title":"Module: BNF","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: BNF A module which extends the Base module and supports creating scanners and SLR(1) parsers from BNF grammars. Parsers employ the observer pattern to be traced and to call actions written in JavaScript. The fundamental object created by this module is a Grammar which could be prepared from grammar rules using the syntax defined here. Grammars are written as ordered pairs and can define precedences. The state table is created from sets of positions in rules, and conflicts are resolved using the lookahead and follow sets, and precedences, if available, i.e., it is a simplified implementation of LR(1). The table is not optimized. An EBNF grammar, optionally with precedences and $error, can be imported for SLR(1) parsing, but the BNF and EBNF modules only depend on the Base module and not on each other. The grammar rules, precedence levels, and states are represented using a number of classes summarized below. check() creates a state table which controls a Parser. A Scanner is created from the grammar's terminals. Objects are created using factory methods which check parameters and maintain inventories. All factory methods are defined in Grammar and the factory methods for all but Message have the same name as the classes (with lower-case initials). All properties have getters, very few have setters, i.e., there is no assignment outside class boundaries. class main properties main methods Grammar: Factory config, ebnf, sr, rr, rules: Array&lt;Rule&gt;,states: Array&lt;State&gt; check(), parser(), build(), trace() Rule nt, symbols: Array&lt;Symbol&gt;, prec, empty, reached, finite, first, reduced NT: NT: Symbol name, ord, rules: Array&lt;Rule&gt;, empty, reached, finite, first, follow Lit: Lit: T: Symbol name, value, ord, prec, used, first unescape(s) Token: Token: T: Symbol name, pat, ord, prec, used, first State marks: Array&lt;Mark&gt;, core,messages: Object&lt;ord, Message&gt; advance(state), equals(core) Mark rule, position, complete advance(), equals(mark) Message message, symbol, info Parser grammar, stack[], state: State, values[] parse(input) Version: 2024-07-25 Author: © 2023 Axel T. Schreiner Source: bnf.js, line 1 See: module:Base Classes Actions Grammar Lit Mark Message NT Parser Rule State Token Mixins T × Search results Close "},"module-BNF-Actions.html":{"id":"module-BNF-Actions.html","title":"Class: Actions","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions BNF~ Actions The BNF grammar parser's actions, used internally in new Grammar(). The methods intentionally defeat the argument count checks. &lt;private&gt; new Actions(g) Creates the singleton with the action methods. Parameters: Name Type Description g module:BNF~Grammar to hold the rule representations. Properties: Name Type Description g module:BNF~Grammar the grammar to add precedences and rules to. Source: bnf.js, line 1821 Methods grammar() grammar: precedences rules; Source: bnf.js, line 1833 Returns: g - represents and checks the grammar. Type module:BNF~Grammar lit() lit: Lit; Source: bnf.js, line 1899 Returns: represents a used literal. Type module:BNF~Lit name() name: Name; Source: bnf.js, line 1890 Returns: represents a used token or a non-terminal. Type module:BNF~Token | module:BNF~NT precedences() precedences: ; precedences: precedences '%left' terminals ';'; precedences: precedences '%right' terminals ';'; precedences: precedences '%nonassoc' terminals ';'; Source: bnf.js, line 1840 rule() rule: Name ':' symbols ';'; rule: Name ':' symbols '%prec' terminal ';'; Source: bnf.js, line 1870 Returns: represents a rule. Type module:BNF~Rule symbols() symbols: ; symbols: symbols name; symbols: symbols lit; Source: bnf.js, line 1881 Returns: represents a list of symbols. Type Array.&lt;module:Base~Symbol&gt; terminal() terminal: lit; terminal: name; Source: bnf.js, line 1860 Returns: represents a terminal. Type module:BNF~Lit | module:BNF~Token terminals() terminals: terminal; terminals: terminals terminal; Source: bnf.js, line 1850 Returns: represents a list of terminals. Type module:BNF~Lit | module:BNF~Token × Search results Close "},"module-BNF-Grammar.html":{"id":"module-BNF-Grammar.html","title":"Class: Grammar","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Grammar BNF~ Grammar Represents a context-free grammar to create SLR(1) parsers. Contains factory methods to create objects to represent the grammar as a tree and to represent the parsers' state table. A `Grammar` object can be asked to generate scanners and [parsers](#parser) to process input sentences conforming to the grammar. If a parser is called with suitable actions it can transform input. new Grammar( [grammar] [, tokens] [, config]) Creates a grammar representation. Creates the $accept non-terminal, $eof end of input literal, and $error token, and reserves rule zero: $accept: start $eof;. Defines tokens, if any. Parameters: Name Type Argument Description grammar string &lt;optional&gt; &lt;nullable&gt; the grammar to represent, using the BNF grammar and BNF token and literal notation. This can be omitted to construct the rules directly using the factory methods. tokens Object.&lt;string, RegExp&gt; &lt;optional&gt; &lt;nullable&gt; maps token names, if any, in the new grammar to their patterns which must not accept empty input, must not use d, g, or y flag, should not be anchored, and should use (:? ) rather than ( ) for grouping. tokens can map the empty string to a skip pattern which will be used to interpret the grammar string. config Object.&lt;string, Object&gt; &lt;optional&gt; overwrites configurable values' defaults; loaded first but can only be the third parameter. Properties: Name Type Argument Description ebnf module:EBNF~Grammar &lt;nullable&gt; set only if created from EBNF Grammar. rules Array.&lt;module:BNF~Rule&gt; list of grammar rules, can be pushed. states Array.&lt;module:BNF~State&gt; list of possible states for parser. sr number number of shift/reduce conflicts. rr number number of reduce/reduce conflicts. config Object.&lt;string, Object&gt; maps names to configurable values. Properties Name Type Argument Description log function function to print strings, by default console.log. lits RegExp restricts literal representation, by default single-quoted; must be anchored. tokens RegExp restricts token names, by default alphanumeric; must be anchored. nts RegExp restricts non-terminal names, by default alphanumeric; must be anchored. uniq string prefix for unique non-terminal names, by default $-. error boolean &lt;optional&gt; if true, insert $error when translating some. lookahead boolean &lt;optional&gt; if true, trace lookahead when parsing. trace RegEx &lt;optional&gt; if set, observe with grammar.trace( , config.trace); only affects grammar.parser(). build boolean &lt;optional&gt; if set, build with grammar.build(); only affects grammar.parser(). lits Array.&lt;module:Base~Lit&gt; list of unique literals, can be pushed. litsByName Object.&lt;string, module:Base~Lit&gt; maps 'x' to unique literal. tokens Array.&lt;module:Base~Token&gt; list of unique tokens, can be pushed. tokensByName Object.&lt;string, module:Base~Token&gt; maps name to unique token. levels Array.&lt;module:Base~Precedence&gt; list of precedence levels, can be pushed. nts Array.&lt;module:Base~NT&gt; list of unique non-terminals, can be pushed. ntsByName Object.&lt;string, module:Base~NT&gt; maps name to unique non-terminal. errors number incremented by error() method. Source: bnf.js, line 635 Throws: an error for bad token definitions or syntax errors in the grammar. Type Error Examples LL(1) recursive descent parsing const e = new EBNF.Grammar(' ... grammar ... ') e.parser(/ ... skip .../)(' ... input ... ') e.parser(/ ... skip .../)(' ... input ... ', { ... actions ... }) equivalent SLR(1) stack-based parsing const b = BNF.Grammar.fromEBNF(e) b.parser(/ ... skip .../)(' ... input ... ') b.parser(/ ... skip .../)(' ... input ... ', { ... actions ... }) details const b = BNF.Grammar.fromEBNF(e) const s = b.scanner(/ ... skip ... /) new BNF.Parser(b).parse(s.scan(' ... input ... ').concat(null), b.build()) new BNF.Parser(b).parse(s.scan(' ... input ... ').concat(null), b.build({ ... actions ... })) Extends module:Base~Factory Members &lt;static, constant&gt; bnf :string Grammar describing the BNF notation accepted by new Grammar(): A *grammar* consists of an optional sequence of *precedence levels* followed by one or more rules. Each *precedence level* consists of an associativity followed by one or more literals or token names and terminated with a semicolon. Precedence levels are increasing. Each *rule* consists of a non-terminal name on the left-hand side, a colon, a *symbol sequence* on the right-hand side, and a semicolon. Rules with the same names are alternatives. A *symbol sequence* contains zero or more items, such as a non-terminal name, a self-defining literal, or the name of a token. Type: string Source: bnf.js, line 1537 Example BNF grammars' grammar grammar: precedences rules; precedences: ; precedences: precedences '%left' terminals ';'; precedences: precedences '%right' terminals ';'; precedences: precedences '%nonassoc' terminals ';'; terminals: terminal; terminals: terminals terminal; terminal: lit; terminal: name; rules: rule; rules: rules rule; rule: Name ':' symbols ';'; rule: Name ':' symbols '%prec' terminal ';'; symbols: ; symbols: symbols name; symbols: symbols lit; name: Name; lit: Lit; &lt;static, constant&gt; fromEBNF :function Factory method to represent an EBNF grammar as a BNF grammar and check it. Type: function Source: bnf.js, line 1729 Examples Translating [ s | t | ... ] $-#: ; $-#: s; $-#: t; ... Translating { s | t | ... } $-##: $-#; $-##: $-## $-#; $-##: $error; $-##: $-## $error; $-#: s; $-#: t; ... &lt;private, static, constant&gt; grammar :module:BNF~Grammar The BNF grammars' grammar; created when the module is loaded and used internally in new Grammar(). Type: module:BNF~Grammar Source: bnf.js, line 1589 See: Actions &lt;static, constant&gt; terminals :Object.&lt;string, RegExp&gt; Token definitions for Lit and Name in Grammar#bnf. *Literals* represent themselves and are single-quoted strings using `\\` only to escape single quotes and `\\` itself. A *Name* either represents a non-terminal or a *token*. *Tokens* represent sets of inputs, such as names or numbers, and are alphanumeric names which must start with a letter and may include underscores. `$error` is a special token to control error recovery. Type: Object.&lt;string, RegExp&gt; Source: bnf.js, line 1577 See: recover() Grammar.grammar Example BNF grammars' tokens { Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, Name: /[A-Za-z][A-Za-z0-9_]*|\\$error/ } Methods accept() Factory method to create the accept message for $eof. Source: bnf.js, line 931 Returns: an object representing the message. Type module:BNF~Message add(item) Adds a new symbol to the proper inventory or creates and adds new tokens. Must be called with a new, unique symbol or with a map of token names to patterns. Validates item names against .config. Token patterns must not accept empty input, must not use d, g, or y flag, should not be anchored, and should use (:? ) rather than ( ) for grouping. Parameters: Name Type Description item Symbol | Object.&lt;string, RegExp&gt; to add to the proper inventory or create and add. Inherited From: module:Base~Factory#add Overrides: module:Base~Factory#add Source: base.js, line 84 assert(condition, s) Displays a message and throws an error if a condition is not met; primarily used for stronger argument typing. Parameters: Name Type Argument Description condition boolean should be true. s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#assert Overrides: module:Base~Factory#assert Source: base.js, line 217 Throws: message if condition is not met. Type string check(start) Completes the grammar representation and reports if there are errors; call exactly once. Creates rule zero: $accept: start $eof;. Sets ordinal number for literals, then tokens, then non-terminals. Checks that all rules are reached and all non-terminals can reduce to a terminal. Computes first and follow sets. Creates state table. Checks that all rules can be reduced. Parameters: Name Type Description start module:BNF~NT the start non-terminal. Source: bnf.js, line 721 dump(a, states) Displays grammar, terminals, and non-terminals with name and contents of all sets. Displays number of errors if any. Parameters: Name Type Argument Description a Object &lt;nullable&gt; with one argument (kludge!) acts as a static method and displays the argument converting nested arrays to a string – useful because console.debug only reaches 3 levels. states boolean if true also displays states. Overrides: module:Base~Factory#dump Source: bnf.js, line 1050 Returns: Type string error(s) Displays a message and counts it as an error. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#error Overrides: module:Base~Factory#error Source: base.js, line 223 Returns: the message. Type string lit( [literal] [, used]) Factory method to create a unique literal symbol, maintains .lits and .litsByName Parameters: Name Type Argument Description literal string &lt;optional&gt; literal's representation conforming to .config.lits. If omitted represents the $eof literal terminal. used boolean &lt;optional&gt; if true mark literal as used. Source: bnf.js, line 828 Returns: a unique literal. Type module:BNF~Lit mark(rule, position) Factory method to represent a mark in a rule. Parameters: Name Type Description rule module:BNF~Rule rule to mark. position number position in rule, before a symbol or after all. Source: bnf.js, line 965 Returns: an object representing the marked rule. Type module:BNF~Mark message(s) Displays a message on the configured .log. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#message Overrides: module:Base~Factory#message Source: base.js, line 229 Returns: the message. Type string nt( [name]) Factory method to create a unique non-terminal symbol, maintains .nts and .ntsByName. Parameters: Name Type Argument Description name string &lt;optional&gt; non-terminal's name conforming to config.nts; error if a token. If omitted represents the $accept non-terminal, if not a string creates a unique name (intended for EBNF translation). Source: bnf.js, line 871 Returns: a unique non-terminal. Type module:BNF~NT parser( [skip]) Factory method to create a parser to recognize and process input. Parameters: Name Type Argument Description skip RegEx &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use flags, must not be anchored, should use (:? )rather than ( ) for grouping. Source: bnf.js, line 1007 Returns: the parser. Type module:BNF~Parser precedence(assoc, terminals) Factory method to represent a list of terminals with equal precedence level and equal associativity. Creates a new Precedence object, adds it to .levels, adds .prec.level and .prec.assoc to all terminals in the list, and checks for duplicates. Parameters: Name Type Description assoc string associativity: '%left', '%right', or '%nonassoc'. terminals Array.&lt;?module:Base~T&gt; to add, null elements are ignored; no duplicates. Inherited From: module:Base~Factory#precedence Overrides: module:Base~Factory#precedence Source: base.js, line 157 Returns: representing the set, or null if there are no terminals. Type module:Base~Precedence reduce(t, rule) Factory method to create a reduce message. Parameters: Name Type Description t module:Base~T terminal on which to send message. rule module:BNF~Rule rule to reduce. Source: bnf.js, line 940 Returns: an object representing the message. Type module:BNF~Message rule(nt [, symbols] [, terminal]) Factory method to create a rule representation for BNF. Maintains rule's non-terminal's .rules and this.rules. Maintains rule's non-terminal's .empty. Precedence levels have to be defined prior to using this method. Parameters: Name Type Argument Default Description nt module:BNF~NT left-hand side, non-terminal. symbols Array.&lt;module:Base~Symbol&gt; &lt;optional&gt; right-hand side, list of symbols. terminal module:Base~T &lt;optional&gt; &lt;nullable&gt; null can define rule's precedence, by default the precedence of the rightmost terminal, if any. Source: bnf.js, line 898 Returns: a new rule representation. Type module:BNF~Rule scanner( [skip] [, terminals]) Factory method to create a scanner. Parameters: Name Type Argument Description skip RegExp &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? ) rather than ( ) for grouping. terminals Array.&lt;T&gt; &lt;optional&gt; ordered list to create the lexical analysis pattern. Inherited From: module:Base~Factory#scanner Overrides: module:Base~Factory#scanner Source: base.js, line 184 Returns: the scanner. Type module:Base~Scanner shift_or_goto(symbol, state) Factory method to create a shift or goto message. Parameters: Name Type Description symbol module:Base~Symbol symbol on which to send message. state number state to shift to. Source: bnf.js, line 952 Returns: an object representing the message. Type module:BNF~Message state(core) Factory method to represent a state of the parser automaton. The state is created from the core marks; rules in the closure are added. Parameters: Name Type Description core Array.&lt;module:BNF~Mark&gt; list of marks in the core, closure is added. Source: bnf.js, line 978 Returns: an object representing the state. Type module:BNF~State toString( [states]) Displays description of grammar and number of errors if any. Parameters: Name Type Argument Description states boolean &lt;optional&gt; if true, also displays state table. Source: bnf.js, line 1016 Returns: Type string token( [name] [, pat] [, used]) Factory method to create a unique token symbol, maintains .tokens and .tokensByName. Parameters: Name Type Argument Description name string &lt;optional&gt; token's name conforming to .config.tokens; error if a non-terminal. If omitted represents the $error token with an empty RegExp. pat RegExp &lt;optional&gt; pattern to match values representing the token in input; used only when the token is created, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? ) rather than ( ) for grouping. used boolean &lt;optional&gt; if true mark token as used. Source: bnf.js, line 850 Returns: a unique token. Type module:BNF~Token tuple(lineno, t [, value]) Factory method to create an element of a tokenized input stream. Parameters: Name Type Argument Default Description lineno number input position. t module:Base~T &lt;nullable&gt; terminal, i.e., literal or token object; scan() uses null for an illegal character. value string &lt;optional&gt; &lt;nullable&gt; null terminal's representation in the input. Inherited From: module:Base~Factory#tuple Overrides: module:Base~Factory#tuple Source: base.js, line 203 Returns: an element of a tokenized input stream. Type module:Base~Tuple × Search results Close "},"module-BNF-Lit.html":{"id":"module-BNF-Lit.html","title":"Class: Lit","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Lit BNF~ Lit Represents a literal symbol for BNF. new Lit( [name]) Creates a literal symbol for BNF; see factory method grammar.lit(). Parameters: Name Type Argument Description name string &lt;optional&gt; a (quoted) representation for the literal. Properties: Name Type Argument Description ord number global index; set in check(). first Object.&lt;number, module:Base~T&gt; maps ord to this. name string representation for a literal. Empty string is reserved for $eof, the end of input. prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. value string (unquoted) value for the literal; empty string for $eof, too. screened boolean &lt;optional&gt; set true only during scanner construction if literal value matches a token pattern. Mixes In: module:BNF~T Source: bnf.js, line 94 Extends module:Base~Lit Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~Lit#dump Source: base.js, line 279 Returns: Type string toString() Displays representation of a literal or $eof. Inherited From: module:Base~Lit#toString Overrides: module:Base~Lit#toString Source: base.js, line 314 Returns: Type string unescape(s) Removes leading and trailing delimiter character and elaboarates backslash escapes. Parameters: Name Type Description s string string to unescape. Inherited From: module:Base~Lit#unescape Overrides: module:Base~Lit#unescape Source: base.js, line 321 Returns: unquoted, unescaped string. Type string × Search results Close "},"module-BNF-Mark.html":{"id":"module-BNF-Mark.html","title":"Class: Mark","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Mark BNF~ Mark Represents a mark in a rule. new Mark(grammar, rule, position) Creates a new mark for a rule; see factory method grammar.mark(). Parameters: Name Type Description grammar module:BNF~Grammar supplies factory method. rule module:BNF~Rule rule to mark. position number position in rule, before a symbol or after all. Properties: Name Type Description assert function bound to grammar.assert(). mark function bound to grammar.mark(). rule module:BNF~Rule rule to mark. position number position in rule, before a symbol or after all. complete boolean true if position is after all symbols. Source: bnf.js, line 348 Methods advance() Advances the mark. Source: bnf.js, line 398 Returns: a new configuration with the mark moved right, i.e., position increased by 1. Type module:BNF~Mark equals(c) Compares two marks. Parameters: Name Type Description c module:BNF~Mark to compare to this. Source: bnf.js, line 389 Returns: true if same rule and same position. toString() Displays the marked rule. Source: bnf.js, line 383 Returns: Type string × Search results Close "},"module-BNF-Message.html":{"id":"module-BNF-Message.html","title":"Class: Message","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Message BNF~ Message Represents a message of the parser automaton. new Message(verb, symbol, info) Creates a new message; see factory methods grammar.accept(), grammar.reduce(), grammar.shift_or_goto(), and parser.observe(). Parameters: Name Type Description verb string one of 'accept', 'error', 'goto', 'reduce', or 'shift'. symbol module:BNF~T | module:BNF~NT symbol on which to send message. info Number | module:BNF~Rule additional information, if any. Properties: Name Type Description verb string one of 'accept', 'error', 'goto', 'reduce', or 'shift'. symbol module:Base~Symbol symbol on which to message. info Number | module:BNF~Rule additional information, if any. Source: bnf.js, line 301 Methods toString() Displays symbol, message, and additional information if any. Source: bnf.js, line 330 Returns: Type string × Search results Close "},"module-BNF-NT.html":{"id":"module-BNF-NT.html","title":"Class: NT","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: NT BNF~ NT Represents a non-terminal symbol for BNF. new NT(name, index) Creates a non-terminal symbol for BNF; see factory method grammar.nt(). Parameters: Name Type Description name string non-terminal's name. index number non-terminal's index in .nts. Properties: Name Type Description index number non-terminal's index in .nts. ord number non-terminal's global index; set in check(). rules Array.&lt;module:BNF~Rule&gt; defining this. empty boolean true if no input can be accepted. reached boolean true if this can be reached from rule zero. finite boolean true if there is a non-recursive expansion. first Object.&lt;number, module:BNF~T&gt; terminals at front, maps ord to module:BNF~T. follow Object.&lt;number, module:BNF~T&gt; terminals following, maps ord to module:BNF~T. name string name for the non-terminal. Empty string is reserved for $accept, can be left-hand side of a start rule. Source: bnf.js, line 145 Extends module:Base~NT Methods dump() Displays index or ord and name and contents of all sets. Overrides: module:Base~NT#dump Source: bnf.js, line 187 Returns: Type string toString() Displays name of a non-terminal or $accept. Inherited From: module:Base~NT#toString Overrides: module:Base~NT#toString Source: base.js, line 448 Returns: Type string × Search results Close "},"module-BNF-Parser.html":{"id":"module-BNF-Parser.html","title":"Class: Parser","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Parser BNF~ Parser Wraps a method parser.parse() which recognizes input and calls on an observer, if any. Unlike grammar.parser().parse(), here input can be presented in pieces, i.e., the method throws true if it should be called with more input. new Parser(grammar [, skip]) Creates a parser; see parser() factory method. Parameters: Name Type Argument Description grammar module:BNF~Grammar represents grammar and states. skip RegExp &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? )rather than ( ) for grouping. Properties: Name Type Argument Description scanner module:Base~Scanner &lt;nullable&gt; tokenizes input. parsing boolean true while recognition is in progress. building boolean true if recognition calls build(). stack Array.&lt;number&gt; stack of state numbers. state module:BNF~State current state. values Array.&lt;object&gt; parallels state stack, nested lists or action results. input function | Array.&lt;module:Base~Tuple&gt; | boolean &lt;nullable&gt; provides input as tuples. null, an empty array, or a null array element act as $eof. false is set to request more input. current module:Base~Tuple &lt;nullable&gt; current input tuple, if any. tuples Array.&lt;module:Base~Tuple&gt; available tuples. index number index of next tuple. grammar module:BNF~Grammar represents the grammar and states, counts errors; concurrent recognition will trash error counting. actions Object &lt;nullable&gt; maps rule names to action methods during recognition. Source: bnf.js, line 1103 Extends module:Base~Parser Methods act(name, result) Calls an action method. Checks argument count unless grammar.config.noargs is set or the method expects no arguments, i.e., has a rest parameter. Parameters: Name Type Description name string rule name to match. result Array list of arguments. Inherited From: module:Base~Parser#act Overrides: module:Base~Parser#act Source: base.js, line 758 Returns: action method result or unchanged result. &lt;private&gt; build(tuple, verb, info) List builder, part of parse(). Manages the value stack to collect nested lists of all terminal values and applies action methods matching rule names which can restructure the list of values collected for a rule. If the grammar is created from an EBNF grammar the generated rules $-#: $-# other; and $-#: ; have implicit actions to support transparency for actions. An action should throw an Error to abort recognition or a string to report an error and return null as result. verb effect 'shift' pushes the tuple's terminal's value onto the value stack; returns null. 'reduce' pops one value per symbol, presents the list to an action function if any; returns the list or the result. 'goto' the result of the preceding 'reduce' is on top of the value stack; returns null. 'accept' returns the top-level value. 'error' if there is no info pops one value and returns null. Parameters: Name Type Description tuple module:Base~Tuple current input. verb string 'shift', 'reduce', 'goto', 'accept', or 'error'. info module:BNF~Rule | module:Base~T | number | string a reference to the relevant rule, terminal, or state number, or an error message. Source: bnf.js, line 1388 Throws: with an error message to abort recognition. Type Error Returns: anything on success. Type object call(target, method, args) Checks if argument and parameter count of a method match unless the method expects no parameters, or has a rest parameter or grammar.config.noargs is true. Parameters: Name Type Argument Description target object to apply method to. method function to check. args Object &lt;repeatable&gt; arguments to pass. Inherited From: module:Base~Parser#call Overrides: module:Base~Parser#call Source: base.js, line 787 Returns: method result. Type Object Example super.method(arg1, .. argn) this.parser.call(this, super.method, arg1, .. argn) error(s) Displays a message; lets grammar count it as an error. Parameters: Name Type Argument Description s Array.&lt;object&gt; &lt;repeatable&gt; message, to be displayed; prefixed by .current and joined by blanks. Source: bnf.js, line 1498 Returns: the message. Type string &lt;private&gt; next() Part of parse(). Sets .current to a new tuple, but not past $eof. Source: bnf.js, line 1238 Throws: true to ask for more input. &lt;private&gt; observe(tuple, verb, info) Recognition observer, part of parse(). Calls build() to create a result, if any; calls trace() if configured; reports info from an error message, if any, Parameters: Name Type Description tuple module:Base~Tuple current input. verb string of message. info module:BNF~Rule | number | string of message. Source: bnf.js, line 1331 Returns: the result. Type Object parse(input [, actions], arg) Parses (some more) input. actions can only be supplied with the first input; however, the function is serially reusable. Resets and reports .errors for the grammar. Parameters: Name Type Argument Description input string | Array.&lt;module:Base~Tuple&gt; | function &lt;nullable&gt; a string is scanned into tuples with null appended as end of input; can be a function which returns an array of tuples. null, an empty array, or a null array element act like a tuple containing $eof. actions function | Object &lt;optional&gt; a function is assumed to be a class and a singleton is created with this as constructor argument. The object maps rule names to action methods. arg Object &lt;repeatable&gt; used as further constructor arguments. Overrides: module:Base~Parser#parse Source: bnf.js, line 1161 Throws: true for more input, Error or error message otherwise — terminates one recognition. Type boolean | Error | string Returns: result from observer, if any; ends one recognition. Type Object &lt;private&gt; process(tuple) Part of parse(). processes an expected input: sends message to observe() and handles the state stack and the result, if any. Parameters: Name Type Description tuple module:Base~Tuple to be processed. Source: bnf.js, line 1278 Throws: fatal error message or [ result ] if accept message. Type string | Array.&lt;Object&gt; Returns: true if tuple is consumed (shift), false if not (reduce). Type boolean &lt;private&gt; recover() Part of parse(). Attempts error recovery within the current input sequence. Sends one 'error' with an error message, works on input and stack until a shift $error and shift current are done. Sends 'error' with null message every time the stack is popped. Returns when current was consumed to resume normal processing. Source: bnf.js, line 1438 Throws: true to ask for more input, i.e., abandons recovery. [ result ] for $accept. 'irrecoverable error' if the stack is empty. toString() Displays the current state stack and value stack, if any. Source: bnf.js, line 1485 Returns: Type string &lt;private&gt; trace(tuple, verb, info, the) Formats and displays trace, part of parse(). Parameters: Name Type Description tuple module:Base~Tuple current input. verb string of message. info module:BNF~Rule | number | string of message. the Object result. Source: bnf.js, line 1351 × Search results Close "},"module-BNF-Rule.html":{"id":"module-BNF-Rule.html","title":"Class: Rule","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Rule BNF~ Rule Represents a BNF rule, i.e., an ordered pair. new Rule(nt, symbols, index [, prec]) Creates a BNF rule; see rule() factory method. Parameters: Name Type Argument Description nt module:BNF~NT left-hand side, non-terminal. symbols Array.&lt;module:Base~Symbol&gt; right-hand side. index number rule's index in module:BNF~Grammar.rules. prec Object &lt;optional&gt; &lt;nullable&gt; precedence, if any. Properties: Name Type Argument Description nt module:BNF~NT rule's non-terminal (left-hand side). symbols Array.&lt;module:Base~Symbol&gt; rule's right-hand side. index number rule's index in grammar.rules. empty boolean computed from .symbols. reached boolean true if this can be reached from rule zero. finite boolean true if all non-terminals in the right-hand side have module:BNF~NT.finite set. first Object.&lt;number, module:BNF~T&gt; terminals at front, maps ord to module:BNF~T. reduced boolean true if this rule has been reduced. prec Object &lt;nullable&gt; precedence. Properties Name Type Description assoc string associativity, '%left', '%right' or '%nonassoc' if any. level number precedence level, from 0. t module:BNF~T terminal providing the precedence. Source: bnf.js, line 220 Methods dump() Displays index, rule, empty, and content of first. Source: bnf.js, line 282 Returns: Type string toString( [mark]) Displays a rule in BNF notation. Parameters: Name Type Argument Description mark number &lt;optional&gt; precedes a symbol on the right-hand side if it is in range. Source: bnf.js, line 268 Returns: Type string × Search results Close "},"module-BNF-State.html":{"id":"module-BNF-State.html","title":"Class: State","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: State BNF~ State Represents a state of the automaton. new State(grammar, marks, core, messages) Creates a new state of the automaton; see factory method grammar.state(). Parameters: Name Type Description grammar module:BNF~Grammar owner of this state. marks Array.&lt;module:BNF~Mark&gt; core and closure defining this state. core number number of marked rules in the core. messages Object.&lt;number, module:BNF~Message&gt; maps possible next symbols to null. Properties: Name Type Description grammar module:BNF~Grammar owner of this state. marks Array.&lt;module:BNF~Mark&gt; core and closure defining this state. core number number of marked rules in the core. messages Object.&lt;number, module:BNF~Message&gt; maps possible next symbols to messages. errors Array.&lt;string&gt; errors detected in this state, if any. Source: bnf.js, line 408 Methods advance(stateNumber) Populates the .messages table. Fills in reduce for complete rules, shift for terminals, accept for the end of input terminal, and goto for non-terminals. Parameters: Name Type Description stateNumber number this state's number for error messages. Source: bnf.js, line 475 dump(core) Displays all marked rules and messages. Parameters: Name Type Description core boolean if true, only displays core configurations. Source: bnf.js, line 447 Returns: Type string equals(core) Compares a core of marked rules to this state's core. Parameters: Name Type Description core Array.&lt;module:BNF~Mark&gt; to compare to this. Source: bnf.js, line 460 Returns: true if this state has the same core (in any order). toString() Displays core configurations and messages. Source: bnf.js, line 441 Returns: Type string × Search results Close "},"module-BNF-T.html":{"id":"module-BNF-T.html","title":"Mixin: T","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: T BNF~ T Properties: Name Type Description ord number global index; set in check(). first Object.&lt;number, module:Base~T&gt; maps ord to this. Source: bnf.js, line 61 Methods dump() Displays ordinal number, if any, and description of terminal. Source: bnf.js, line 75 Returns: Type string × Search results Close "},"module-BNF-Token.html":{"id":"module-BNF-Token.html","title":"Class: Token","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Token BNF~ Token Represents a token symbol for BNF. mixes module:BNF~T new Token(name, pat) Creates a token symbol for BNF; see factory method grammar.token(). Parameters: Name Type Description name string token name. pat RegExp for a token. Properties: Name Type Argument Description ord number global index; set in check(). first Object.&lt;number, module:Base~T&gt; maps ord to this. name string name for the token. Empty string is reserved for $error, can be something unexpected. prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. pat RegExp pattern for token; empty RegExp for $error. screen Array.&lt;Lit&gt; &lt;optional&gt; contains literals with values matching the pattern, if any. Source: bnf.js, line 118 Extends module:Base~Token Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~Token#dump Source: base.js, line 279 Returns: Type string toString() Displays name of a token or $error. Inherited From: module:Base~Token#toString Overrides: module:Base~Token#toString Source: base.js, line 396 Returns: Type string × Search results Close "},"module-Base.html":{"id":"module-Base.html","title":"Module: Base","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Base A module which contains classes and methods shared by both, the BNF and EBNF modules. It implements messaging, creating precedence levels, and creating scanners. class main properties main methods Factory config, errors,lits[ByName], tokens[ByName], nts[ByName],levels: Array&lt;Precedence&gt; add(item), dump(item),assert(condition, ...),error(...),message(...) Precedence assoc, terminals Scanner pattern scan(input): Array&lt;Tuple&gt; Tuple lineno, t, value escape(s) Version: 2024-02-13 Author: © 2023 Axel T. Schreiner Source: base.js, line 1 Classes Factory Lit NT Parser Precedence Scanner Symbol T Token Tuple Type Definitions Action(value) Method to process values collected by a rule. Parameters: Name Type Argument Description value Object &lt;repeatable&gt; one value collected per item on the right-hand side. Source: base.js, line 701 Throws: a string with an error message to continue recognition or an Error with an error message to abort recognition. Type string | Error Returns: the value to be collected in the parent rule or returned by recognition. Type Object × Search results Close "},"module-Base-Factory.html":{"id":"module-Base-Factory.html","title":"Class: Factory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Factory Base~ Factory Contains configurable values, inventories, and factory methods to create scanners, tokenized input tuples, and precedence levels. &lt;abstract&gt; new Factory() Properties: Name Type Description config Object.&lt;string, Object&gt; maps names to configurable values. Properties Name Type Description log function function to print strings, by default console.log. lits RegExp restricts literal representation, by default single-quoted; must be anchored. tokens RegExp restricts token names, by default alphanumeric; must be anchored. nts RegExp restricts non-terminal names, by default alphanumeric; must be anchored. uniq string prefix for unique non-terminal names, by default $-. lits Array.&lt;module:Base~Lit&gt; list of unique literals, can be pushed. litsByName Object.&lt;string, module:Base~Lit&gt; maps 'x' to unique literal. tokens Array.&lt;module:Base~Token&gt; list of unique tokens, can be pushed. tokensByName Object.&lt;string, module:Base~Token&gt; maps name to unique token. levels Array.&lt;module:Base~Precedence&gt; list of precedence levels, can be pushed. nts Array.&lt;module:Base~NT&gt; list of unique non-terminals, can be pushed. ntsByName Object.&lt;string, module:Base~NT&gt; maps name to unique non-terminal. errors number incremented by error() method; can be reset, e.g., to count during recognition. noargs boolean don't check for argument count errors in act() method. Source: base.js, line 41 Methods add(item) Adds a new symbol to the proper inventory or creates and adds new tokens. Must be called with a new, unique symbol or with a map of token names to patterns. Validates item names against .config. Token patterns must not accept empty input, must not use d, g, or y flag, should not be anchored, and should use (:? ) rather than ( ) for grouping. Parameters: Name Type Description item Symbol | Object.&lt;string, RegExp&gt; to add to the proper inventory or create and add. Source: base.js, line 84 assert(condition, s) Displays a message and throws an error if a condition is not met; primarily used for stronger argument typing. Parameters: Name Type Argument Description condition boolean should be true. s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Source: base.js, line 217 Throws: message if condition is not met. Type string dump( [a]) Displays an object as a string; in particular, nested arrays. This is useful because console.debug only reaches 3 levels. Parameters: Name Type Argument Description a Object &lt;optional&gt; the object to display; if omitted, returns an empty string. Source: base.js, line 128 Returns: Type string error(s) Displays a message and counts it as an error. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Source: base.js, line 223 Returns: the message. Type string message(s) Displays a message on the configured .log. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Source: base.js, line 229 Returns: the message. Type string precedence(assoc, terminals) Factory method to represent a list of terminals with equal precedence level and equal associativity. Creates a new Precedence object, adds it to .levels, adds .prec.level and .prec.assoc to all terminals in the list, and checks for duplicates. Parameters: Name Type Description assoc string associativity: '%left', '%right', or '%nonassoc'. terminals Array.&lt;?module:Base~T&gt; to add, null elements are ignored; no duplicates. Source: base.js, line 157 Returns: representing the set, or null if there are no terminals. Type module:Base~Precedence scanner( [skip] [, terminals]) Factory method to create a scanner. Parameters: Name Type Argument Description skip RegExp &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? ) rather than ( ) for grouping. terminals Array.&lt;T&gt; &lt;optional&gt; ordered list to create the lexical analysis pattern. Source: base.js, line 184 Returns: the scanner. Type module:Base~Scanner tuple(lineno, t [, value]) Factory method to create an element of a tokenized input stream. Parameters: Name Type Argument Default Description lineno number input position. t module:Base~T &lt;nullable&gt; terminal, i.e., literal or token object; scan() uses null for an illegal character. value string &lt;optional&gt; &lt;nullable&gt; null terminal's representation in the input. Source: base.js, line 203 Returns: an element of a tokenized input stream. Type module:Base~Tuple × Search results Close "},"module-Base-Lit.html":{"id":"module-Base-Lit.html","title":"Class: Lit","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Lit Base~ Lit Represents a literal symbol. &lt;abstract&gt; new Lit(name) Creates a literal symbol; should only be used by factory method. Extracts value from representation. Parameters: Name Type Description name string (quoted) representation for the literal. Empty string is reserved for $eof, the end of input. Properties: Name Type Argument Description value string (unquoted) value for the literal; empty string for $eof, too. screened boolean &lt;optional&gt; set true only during scanner construction if literal value matches a token pattern. prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. used boolean true if used in a grammar. name string name for a token, representation for a literal. Source: base.js, line 297 Extends module:Base~T Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~T#dump Source: base.js, line 279 Returns: Type string toString() Displays representation of a literal or $eof. Source: base.js, line 314 Returns: Type string unescape(s) Removes leading and trailing delimiter character and elaboarates backslash escapes. Parameters: Name Type Description s string string to unescape. Source: base.js, line 321 Returns: unquoted, unescaped string. Type string × Search results Close "},"module-Base-NT.html":{"id":"module-Base-NT.html","title":"Class: NT","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: NT Base~ NT Represents a non-terminal symbol. &lt;abstract&gt; new NT(name) Creates a non-terminal symbol; should only be used by factory method. Parameters: Name Type Description name string non-terminal's name. Properties: Name Type Description name string name for the non-terminal. Empty string is reserved for $accept, can be left-hand side of a start rule. Source: base.js, line 438 Extends module:Base~Symbol Methods dump() Displays name of a non-terminal or $accept. Source: base.js, line 453 Returns: Type string toString() Displays name of a non-terminal or $accept. Source: base.js, line 448 Returns: Type string × Search results Close "},"module-Base-Parser.html":{"id":"module-Base-Parser.html","title":"Class: Parser","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Parser Base~ Parser Abstract base class for recognition based on a grammar. Should wrap a method parse() which recognizes input, builds a tree of nested lists, and creates and calls on an object with action methods, if any. &lt;abstract&gt; new Parser(grammar) Creates a parser; only used by subclass to set .grammar. Parameters: Name Type Description grammar module:Base~Factory represents grammar. Properties: Name Type Argument Description grammar module:Base~Factory represents the grammar, counts errors; concurrent recognition will trash error counting. actions Object &lt;nullable&gt; maps rule names to action methods during recognition. Source: base.js, line 718 Methods act(name, result) Calls an action method. Checks argument count unless grammar.config.noargs is set or the method expects no arguments, i.e., has a rest parameter. Parameters: Name Type Description name string rule name to match. result Array list of arguments. Source: base.js, line 758 Returns: action method result or unchanged result. call(target, method, args) Checks if argument and parameter count of a method match unless the method expects no parameters, or has a rest parameter or grammar.config.noargs is true. Parameters: Name Type Argument Description target object to apply method to. method function to check. args Object &lt;repeatable&gt; arguments to pass. Source: base.js, line 787 Returns: method result. Type Object Example super.method(arg1, .. argn) this.parser.call(this, super.method, arg1, .. argn) parse( [actions], arg) Only used by subclass to set .actions; resets .errors for the grammar. Should recognize an input sentence. Parameters: Name Type Argument Description actions function | Object &lt;optional&gt; a function is assumed to be a class and a singleton is created with this as constructor argument. The object maps rule names to action methods. arg Object &lt;repeatable&gt; used as further constructor arguments. Source: base.js, line 737 × Search results Close "},"module-Base-Precedence.html":{"id":"module-Base-Precedence.html","title":"Class: Precedence","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Precedence Base~ Precedence Represents a list of terminal symbols of equal precedence and associativity. new Precedence(assoc) Creates a new precedence level; see factory method grammar.precedence(). Parameters: Name Type Description assoc string associativity, '%left', '%right', or '%nonassoc'. Properties: Name Type Description assoc string associativity, '%left', '%right', or '%nonassoc'. terminals Array.&lt;module:Base~T&gt; list of terminal symbols. Source: base.js, line 403 Methods dump() Displays associativity and the list of terminals. Source: base.js, line 428 Returns: . Type string toString() Displays associativity and the list of terminals. Source: base.js, line 423 Returns: . Type string × Search results Close "},"module-Base-Scanner.html":{"id":"module-Base-Scanner.html","title":"Class: Scanner","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Scanner Base~ Scanner Wraps a function which tokenizes a string. Token patterns should not partially overlap literals, e.g., /[a-z]+/ would conceal 'formula1'. new Scanner(factory, skip [, terminals]) Creates the pattern used to tokenize a string; see factory method grammar.scanner(). Parameters: Name Type Argument Description factory module:Base~Factory supplies literals and tokens; unused terminals and $eof and $error, if any, are ignored. skip RegExp a pattern to define ignorable character sequences, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? ) rather than ( ) for grouping. terminals Array.&lt;T&gt; &lt;optional&gt; ordered list corresponding to .pattern; if omitted, tokens by ascending name and then literals by decreasing length. Properties: Name Type Description assert function bound to factory.assert(). tuple function bound to factory.tuple(). terminals Array.&lt;module:Base~T&gt; ordered for pattern; first tokens ordered by ascending name then literals ordered by decreasing length. skip RegExp a pattern to define ignorable character sequences, should not accept empty input, should not use flags, should not be anchored, should use (:? ) rather than ( ) for grouping. pattern RegExp read-only, concatenates capture groups with skip and terminals, used to disect input. Source: base.js, line 541 Methods escape(s) Escapes most characters by \\. or \\x.. or \\u..... Similar to Tuple.escape(). Parameters: Name Type Description s string string to escape. Source: base.js, line 673 Returns: escaped string. escape(null) // will crash escape('a') // [alphanumerics] returns string containing a escape('\\b') // [controls] returns string containing \\b escape('s') // [specials] returns string containing \\s escape('x') // [other] returns string containing \\x## or \\u#### Type string scan(input) Tokenizes a string. Parameters: Name Type Description input string to be divided into literals and tokens. Source: base.js, line 629 Returns: a list of literals and tokens. The list contains one Tuple with a null terminal for each character sequence which is neither ignorable nor a literal or a token. Type Array.&lt;module:Base~Tuple&gt; × Search results Close "},"module-Base-Symbol.html":{"id":"module-Base-Symbol.html","title":"Class: Symbol","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Symbol Base~ Symbol Represents a symbol in the grammar alphabets. Symbols are only created through factory methods in the grammar which arrange for uniqueness. &lt;abstract&gt; new Symbol(name) Creates a symbol; should only be used by subclass. Parameters: Name Type Description name string symbol name. Properties: Name Type Description name string name for a token or non-terminal, representation for a literal. An empty string is used for one reserved symbol in each subclass. Source: base.js, line 243 × Search results Close "},"module-Base-T.html":{"id":"module-Base-T.html","title":"Class: T","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: T Base~ T Represents a terminal, i.e., a literal or a token. &lt;abstract&gt; new T(name) Creates a terminal; should only be used by subclass. Parameters: Name Type Description name string name for a token, representation for a literal. Properties: Name Type Description prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. used boolean true if used in a grammar. name string name for a token, representation for a literal. Source: base.js, line 263 Extends module:Base~Symbol Methods dump() Displays description and precedence, if any. Source: base.js, line 279 Returns: Type string × Search results Close "},"module-Base-Token.html":{"id":"module-Base-Token.html","title":"Class: Token","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Token Base~ Token Represents a token symbol. &lt;abstract&gt; new Token(name, pat) Creates a token symbol; should only be used by factory method. Parameters: Name Type Description name string token name. Empty string is reserved for $error, something unexpected. pat RegExp pattern for token; empty RegExp for $error. Properties: Name Type Argument Description pat RegExp pattern for token; empty RegExp for $error. screen Array.&lt;Lit&gt; &lt;optional&gt; contains literals with values matching the pattern, if any. prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. used boolean true if used in a grammar. name string name for a token, representation for a literal. Empty string is reserved for $error, can be something unexpected. Source: base.js, line 379 Extends module:Base~T Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~T#dump Source: base.js, line 279 Returns: Type string toString() Displays name of a token or $error. Source: base.js, line 396 Returns: Type string × Search results Close "},"module-Base-Tuple.html":{"id":"module-Base-Tuple.html","title":"Class: Tuple","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Tuple Base~ Tuple Represents an element of a tokenized input stream. new Tuple(lineno, t, value) Creates an element of a tokenized input stream; see factory method grammar.tuple(). Parameters: Name Type Argument Description lineno number input position. t module:Base~T &lt;nullable&gt; terminal, i.e., literal or token object. null is reserved for unrecognizable input. value string t's representation in the input. Properties: Name Type Argument Description lineno number input position. t module:Base~T &lt;nullable&gt; terminal, i.e., literal or token object. null is reserved for unrecognizable input. value string t's representation in the input. Source: base.js, line 462 Methods escape(s) Escapes non-ASCII and invisible characters using backslash. Similar to Scanner.escape(). Parameters: Name Type Description s string string to escape. Source: base.js, line 506 Returns: double-quoted, escaped string. Type string Example escape(null) // returns empty string escape('x') // returns string containing \"x\" escape('\\b') // returns string containing \"\\b\" escape('y') // returns string containing \"\\x##\" or \"\\u####\" toString() Displays position, terminal, and associated value. Source: base.js, line 488 Returns: . Type string × Search results Close "},"module-EBNF.html":{"id":"module-EBNF.html","title":"Module: EBNF","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: EBNF A module which extends the Base module and supports creating scanners and recursive descent parsers from LL(1) grammars and actions written in JavaScript. The fundamental object created by this module is a Grammar prepared from grammar rules using the syntax defined here. The syntax includes alternative and optional and iterated sequences, all of which must not recognize empty input. This book chapter explains how to write grammar rules. A Grammar, optionally with precedences, can be imported by the BNF module for stack-based parsing, but the BNF and EBNF modules do not depend on each other. The grammar rules are represented using a number of classes as discussed in this book chapter and summarized in the following table: tree structure getters checking parsing Grammar config, rules, prefix check() parser().parse() Node grammar, expect, #follow shallow(), deep(), follow(), check() parse(): stringfor terminals Lit: Lit: T: Symbol + Node name, value, prec, used, expect : string Token: Token: T: Symbol + Node name, pat, prec, used, expect : string NT: NT: Symbol + Node name, rule: Rule, expect shallow(), deep(), follow() parse(): Array|action value Alt + Node seqs: Seq[], expect shallow(), deep(), follow(), check() parse(): Array Rule: Alt nt, recursed, reached shallow(), deep() parse(): Array|action value Opt: Alt check() : null|Array Some: Alt follow(), check() parse(): Array&lt;Array&gt; Seq + Node nodes: Array&lt;Symbol|Opt|Some&gt;, prec: Term , expect shallow(), deep(), follow(), check() parse(): Array Version: 2024-02-12 Author: © 2023 Axel T. Schreiner Source: ebnf.js, line 1 See: module:Base Classes Actions Alt Grammar Lit NT Opt Parser Rule Seq Set Some Token Mixins Node × Search results Close "},"module-EBNF-Actions.html":{"id":"module-EBNF-Actions.html","title":"Class: Actions","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions EBNF~ Actions The EBNF grammar parser's actions, used internally in new Grammar(). &lt;private&gt; new Actions(g) Creates the singleton with the action methods. Parameters: Name Type Description g module:EBNF~Grammar to hold the rule representations. Properties: Name Type Description g module:EBNF~Grammar the grammar to add precedences and rules to. Source: ebnf.js, line 1610 Methods alt() alt: seq [{ '|' seq }]; Source: ebnf.js, line 1637 Returns: represents a list of one or more alternatives. Type module:EBNF~Alt grammar() grammar: [{ level }] { rule }; Source: ebnf.js, line 1622 Returns: represents the grammar, not yet checked. Type module:EBNF~Grammar level() level: '%left' { term } ';' | '%right' { term } ';' | '%nonassoc' { term } ';'; Source: ebnf.js, line 1627 Returns: represents a precedence level. Type module:Base~Precedence lit() lit: Lit; Source: ebnf.js, line 1665 Returns: represents a used literal. Type module:EBNF~Lit opt() opt: '[' alt ']'; Source: ebnf.js, line 1679 Returns: represents an optional list of one or more alternatives. Type module:EBNF~Opt ref() ref: Token; Source: ebnf.js, line 1670 Returns: represents a used token or a non-terminal. Type module:EBNF~Token | module:EBNF~NT rule() rule: Token ':' alt ';'; Source: ebnf.js, line 1632 Returns: represents a rule. Type module:EBNF~Rule seq() seq: { lit | ref | opt | some } [ '%prec' term ]; Source: ebnf.js, line 1646 Returns: represents a list of one or more items. Type module:EBNF~Seq some() some: '{' alt '}'; Source: ebnf.js, line 1684 Returns: represents a list of one or more alternatives. Type module:EBNF~Some term() term: lit | ref; Source: ebnf.js, line 1660 Returns: represents a symbol. Type module:EBNF~Lit | module:EBNF~Token | module:EBNF~NT × Search results Close "},"module-EBNF-Alt.html":{"id":"module-EBNF-Alt.html","title":"Class: Alt","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Alt EBNF~ Alt Represents a list of one or more alternatives. Each entry is a Seq representing one alternative. new Alt(seqs) Creates a list of one or more alternatives; should only be used by subclass. Parameters: Name Type Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. Properties: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Mixes In: module:EBNF~Node Source: ebnf.js, line 404 Methods check(error, name) Check for ambiguity: descendants' expect must be disjoint. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule. Source: ebnf.js, line 463 Returns: error message, if any. Type undefined | string deep() Override getter: computes the set as sum over all descendants. Source: ebnf.js, line 437 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set follow( [increment]) Override setter: sets me and all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 449 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Recognizes one of several alternatives. Parameters: Name Type Description parser module:EBNF~Parser context. Source: ebnf.js, line 481 Throws: if recognition fails. Type string Returns: the list produced by the selected descendant Seq, see parser.parse(). Type Array shallow( [increment]) Override getter: computes the set as sum over all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 421 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays all alternatives. Source: ebnf.js, line 490 Returns: Type string × Search results Close "},"module-EBNF-Grammar.html":{"id":"module-EBNF-Grammar.html","title":"Class: Grammar","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Grammar EBNF~ Grammar Represents a context-free LL(1) grammar to create recursive descent parsers. Contains factory methods to create objects to represent the grammar as a tree. A Grammar object can be asked to generate scanners, and parsers to process input sentences conforming to the grammar. If a parser is called with suitable actions it can transform input. new Grammar( [grammar] [, tokens] [, config]) Creates a grammar representation. Defines tokens, if any. Parameters: Name Type Argument Description grammar string &lt;optional&gt; &lt;nullable&gt; the grammar to represent, using the EBNF grammar and EBNF token and literal notation. This can be omitted to construct the rules directly using the factory methods. tokens Object.&lt;string, RegExp&gt; &lt;optional&gt; &lt;nullable&gt; maps token names, if any, in the new grammar to their patterns which must not accept empty input, must not use d, g, or y flag, should not be anchored, and should use (:? )rather than ( ) for grouping. tokens can map the empty string to a skip pattern which will be used to interpret the grammar string. config Object.&lt;string, Object&gt; &lt;optional&gt; overwrites configurable values' defaults; loaded first but can only be third parameter. Properties: Name Type Description rules Array.&lt;module:EBNF~Rule&gt; list of rules; rule zero is start rule. prefix string prefix for log; assign string to push, else pop. config Object.&lt;string, Object&gt; maps names to configurable values. Properties Name Type Description log function function to print strings, by default console.log. lits RegExp restricts literal representation, by default single-quoted; must be anchored. tokens RegExp restricts token names, by default alphanumeric; must be anchored. nts RegExp restricts non-terminal names, by default alphanumeric; must be anchored. uniq string prefix for unique non-terminal names, by default $-. shallow boolean trace lookahead during shallow. deep boolean trace lookahead during deep. follow boolean trace follow during follow. parse boolean trace parse(). lookahead boolean trace lookahead during parse(). actions boolean trace actions, if any, during parse(). lits Array.&lt;module:Base~Lit&gt; list of unique literals, can be pushed. litsByName Object.&lt;string, module:Base~Lit&gt; maps 'x' to unique literal. tokens Array.&lt;module:Base~Token&gt; list of unique tokens, can be pushed. tokensByName Object.&lt;string, module:Base~Token&gt; maps name to unique token. levels Array.&lt;module:Base~Precedence&gt; list of precedence levels, can be pushed. nts Array.&lt;module:Base~NT&gt; list of unique non-terminals, can be pushed. ntsByName Object.&lt;string, module:Base~NT&gt; maps name to unique non-terminal. errors number incremented by error() method. Source: ebnf.js, line 939 Extends module:Base~Factory Members &lt;static, constant&gt; ebnf :string Grammar describing the EBNF notation accepted by new Grammar(): A *grammar* consists of one or more rules. Each *rule* has a unique name on the left-hand side and alternatives on the right-hand side * *Alternatives* are one or more symbol sequences, separated by `|`. A *symbol sequence* contains one or more items, such as a rule name, a self-defining literal, the name of a token, or alternatives enclosed by braces or brackets. Braces denote that the enclosed alternatives appear one or more times in a sentence. Brackets denote that the enclosed alternatives are optional, i.e., they may or may not appear (once) in a sentence. A symbol sequence must not only contain optional alternatives. Type: string Source: ebnf.js, line 1424 Example EBNF grammars' grammar grammar: [{ level }] { rule }; level: '%left' { term } ';' | '%right' { term } ';' | '%nonassoc' { term } ';'; rule: Token ':' alt ';'; alt: seq [{ '|' seq }]; seq: { lit | ref | opt | some } [ '%prec' term ]; term: lit | ref; lit: Lit; ref: Token; opt: '[' alt ']'; some: '{' alt '}'; &lt;private, static, constant&gt; grammar :module:EBNF~Grammar The EBNF grammars' grammar; created when the module is loaded and used internally in new Grammar(). Type: module:EBNF~Grammar Source: ebnf.js, line 1468 See: Actions &lt;static, constant&gt; terminals :Object.&lt;string, RegExp&gt; Token definitions for Lit and Token in Grammar.ebnf. *Literals* represent themselves and are single-quoted strings using `\\` only to escape single quotes and `\\` itself. *Tokens* represent sets of inputs, such as names or numbers, and are alphanumeric names which must start with a letter and may include underscores. A `Name` can include `$error` for translation to BNF. Type: Object.&lt;string, RegExp&gt; Source: ebnf.js, line 1456 See: Grammar.grammar Example EBNF grammars' tokens { Lit: /'(?:[^'\\\\]|\\\\['\\\\])+'/, Token: /[A-Za-z][A-Za-z0-9_]*|\\$error/ } &lt;static&gt; tracing :Object.&lt;string, Object.&lt;string, function()&gt;&gt; Common method cache for tracing grammar checking and parsing. cls.prototype.method is cached as Grammar.tracing[method][cls.name]. If Grammar.tracing[method] exists, tracing can only be turned off and vice versa. Tracing grammar checking and parsing is static, i.e., common to all grammars that might be created, because the methods themselves are common to all grammars. Type: Object.&lt;string, Object.&lt;string, function()&gt;&gt; Source: ebnf.js, line 1392 Methods add(item) Adds a new symbol to the proper inventory or creates and adds new tokens. Must be called with a new, unique symbol or with a map of token names to patterns. Validates item names against .config. Token patterns must not accept empty input, must not use d, g, or y flag, should not be anchored, and should use (:? ) rather than ( ) for grouping. Parameters: Name Type Description item Symbol | Object.&lt;string, RegExp&gt; to add to the proper inventory or create and add. Inherited From: module:Base~Factory#add Overrides: module:Base~Factory#add Source: base.js, line 84 alt(seqs) Factory method to represent a list of alternatives for EBNF. Parameters: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; &lt;repeatable&gt; the alternatives, not empty. Source: ebnf.js, line 1289 Returns: a new list of alternatives. Type module:EBNF~Alt assert(condition, s) Displays a message and throws an error if a condition is not met; primarily used for stronger argument typing. Parameters: Name Type Argument Description condition boolean should be true. s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#assert Overrides: module:Base~Factory#assert Source: base.js, line 217 Throws: message if condition is not met. Type string check() Checks the grammar to be LL(1). Calls expect() if necessary. Computes follow for each node; a non-terminal obtains it from the rule. Detects ambiguities. Source: ebnf.js, line 1053 Returns: an error message on failure. Type udefined | string dump( [a]) Displays the grammar and all symbols with name and contents of all sets. With argument (kludge!) acts as a static method and converts nested arrays to a string – useful because console.debug only reaches 3 levels. Parameters: Name Type Argument Description a Object &lt;optional&gt; &lt;nullable&gt; the object to convert to a string. Overrides: module:Base~Factory#dump Source: ebnf.js, line 1359 Returns: Type string error(s) Displays a message and counts it as an error. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#error Overrides: module:Base~Factory#error Source: base.js, line 223 Returns: the message. Type string expect() Computes the expect sets; only call once. Does not permit precedences. There has to be at least one rule. All non-terminals must be defined, each by a unique rule. Detects left recursion as an error. Computes expect for each node; a non-terminal obtains it from the rule. All rules must be necessary, i.e., reachable from the first rule. Source: ebnf.js, line 1011 Returns: an error message on failure. Type undefined | string lit(literal [, used]) Factory method to create a unique literal symbol, maintains .lits and .litsByName Parameters: Name Type Argument Description literal string literal's representation conforming to .config.lits. used boolean &lt;optional&gt; if true mark literal as used. Source: ebnf.js, line 1186 Returns: a unique literal. Type module:EBNF~Lit message(s) Displays a message on the configured .log. Parameters: Name Type Argument Description s Array.&lt;?object&gt; &lt;repeatable&gt; message, to be displayed; joined by blanks. Inherited From: module:Base~Factory#message Overrides: module:Base~Factory#message Source: base.js, line 229 Returns: the message. Type string nt( [name]) Factory method to create a unique non-terminal symbol, maintains .nts and .ntsByName. Parameters: Name Type Argument Description name string &lt;optional&gt; non-terminal's name conforming to config.nts; error if a token. If not a string creates a unique name (intended for grammar extension). Source: ebnf.js, line 1228 Returns: a unique non-terminal. Type module:EBNF~NT opt(seqs) Factory method to represent an optional list of alternatives for EBNF. Parameters: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; &lt;repeatable&gt; the alternatives, not empty. Source: ebnf.js, line 1300 Returns: a new optional list of alternatives. Type module:EBNF~Opt parser( [skip]) Factory method to create a parser to recognize and process input. Requires that the expect sets for this grammar have been prepared. Parameters: Name Type Argument Description skip RegEx &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use flags, must not be anchored, should use (:? )rather than ( ) for grouping. Source: ebnf.js, line 1326 Returns: the parser. Type module:EBNF~Parser precedence(assoc, terminals) Factory method to represent a list of terminals with equal precedence level and equal associativity. Creates a new Precedence object, adds it to .levels, adds .prec.level and .prec.assoc to all terminals in the list, and checks for duplicates. Parameters: Name Type Description assoc string associativity: '%left', '%right', or '%nonassoc'. terminals Array.&lt;?module:Base~T&gt; to add, null elements are ignored; no duplicates. Inherited From: module:Base~Factory#precedence Overrides: module:Base~Factory#precedence Source: base.js, line 157 Returns: representing the set, or null if there are no terminals. Type module:Base~Precedence rule(nt, seqs) Factory method to create a rule representation for EBNF. Maintains rule's non-terminal's .rule and this.rules. Parameters: Name Type Argument Description nt module:EBNF~NT left-hand side, non-terminal. seqs Array.&lt;module:EBNF~Seq&gt; &lt;repeatable&gt; right-hand side, list of alternative sequences. Source: ebnf.js, line 1251 Returns: a new rule representation. Type module:EBNF~Rule scanner( [skip] [, terminals]) Factory method to create a scanner. Parameters: Name Type Argument Description skip RegExp &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? ) rather than ( ) for grouping. terminals Array.&lt;T&gt; &lt;optional&gt; ordered list to create the lexical analysis pattern. Inherited From: module:Base~Factory#scanner Overrides: module:Base~Factory#scanner Source: base.js, line 184 Returns: the scanner. Type module:Base~Scanner seq(nodes [, terminal]) Factory method to represent a sequence of nodes for EBNF. Precedence levels have to be defined prior to using this method. Parameters: Name Type Argument Default Description nodes Array.&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt; descendants, not empty, not all Opt. terminal module:Base~T &lt;optional&gt; &lt;nullable&gt; null can define precedence for translation to BNF. Source: ebnf.js, line 1274 Returns: a new sequence. Type module:EBNF~Seq some(seqs) Factory method to represent a repeatable list of alternatives for EBNF. Parameters: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; &lt;repeatable&gt; the alternatives, not empty. Source: ebnf.js, line 1311 Returns: a new repeatable list of alternatives. Type module:EBNF~Opt toString() Displays a description of the grammar. Source: ebnf.js, line 1335 Returns: Type string token( [name] [, pat] [, used]) Factory method to create a unique token symbol, maintains .tokens and .tokensByName. Parameters: Name Type Argument Description name string &lt;optional&gt; token's name conforming to .config.tokens; error if a non-terminal. If omitted represents the $error token with an empty RegExp (intended for BNF translation). pat RegExp &lt;optional&gt; pattern to match values representing the token in input; used only when the token is created, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? )rather than ( ) for grouping. used boolean &lt;optional&gt; if true mark token as used. Source: ebnf.js, line 1208 Returns: a unique token. Type module:EBNF~Token trace(what) Installs and removes trace wrappers for grammar checking and parse methods; controlled by the configuration flags shallow, deep, follow, and parse, should only be called by expect() and parser.parse(). The tracing wrappers use .config.log and .prefix. Grammar checking and parse methods are cached in Grammar.tracing globally per method and class. Parameters: Name Type Description what string one of shallow, deep, follow, or parse to trace that algorithm. Source: ebnf.js, line 1086 tuple(lineno, t [, value]) Factory method to create an element of a tokenized input stream. Parameters: Name Type Argument Default Description lineno number input position. t module:Base~T &lt;nullable&gt; terminal, i.e., literal or token object; scan() uses null for an illegal character. value string &lt;optional&gt; &lt;nullable&gt; null terminal's representation in the input. Inherited From: module:Base~Factory#tuple Overrides: module:Base~Factory#tuple Source: base.js, line 203 Returns: an element of a tokenized input stream. Type module:Base~Tuple × Search results Close "},"module-EBNF-Lit.html":{"id":"module-EBNF-Lit.html","title":"Class: Lit","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Lit EBNF~ Lit Represents a literal symbol for EBNF. new Lit( [literal]) Creates a literal symbol for EBNF; see factory method grammar.lit(). Sets .expect to contain this. Parameters: Name Type Argument Description literal string &lt;optional&gt; a (quoted) representation for the literal. Properties: Name Type Argument Description expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). name string representation for a literal. Empty string is reserved for $eof, the end of input. used boolean true if used in a grammar. prec Object precedence, only for translation to BNF. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. value string (unquoted) value for the literal; empty string for $eof. screened boolean &lt;optional&gt; set true only during scanner construction if literal value matches a token pattern. Mixes In: module:EBNF~Node Source: ebnf.js, line 150 Extends module:Base~Lit Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~Lit#dump Source: base.js, line 279 Returns: Type string toString() Displays representation of a literal or $eof. Inherited From: module:Base~Lit#toString Overrides: module:Base~Lit#toString Source: base.js, line 314 Returns: Type string unescape(s) Removes leading and trailing delimiter character and elaboarates backslash escapes. Parameters: Name Type Description s string string to unescape. Inherited From: module:Base~Lit#unescape Overrides: module:Base~Lit#unescape Source: base.js, line 321 Returns: unquoted, unescaped string. Type string × Search results Close "},"module-EBNF-NT.html":{"id":"module-EBNF-NT.html","title":"Class: NT","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: NT EBNF~ NT Represents a non-terminal symbol for EBNF. new NT(name) Creates a non-terminal symbol for BNF; see factory method grammar.nt(). Parameters: Name Type Description name string non-terminal's name. Properties: Name Type Argument Description rule module:EBNF~Rule &lt;nullable&gt; defines this, initially null. expect module:EBNF~Set delegated to .rule. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). name string name for the non-terminal. Mixes In: module:EBNF~Node Source: ebnf.js, line 205 Extends module:Base~NT Methods deep() Override getter: delegates to the referenced rule. Source: ebnf.js, line 231 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set dump() Displays name and contents of all sets. Overrides: module:Base~NT#dump Source: ebnf.js, line 260 Returns: Type string follow( [increment]) Override setter: sets .rule only if it makes a difference; i.e., recursion stops here once there is no more change. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 239 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Delegates to the referenced rule.. Parameters: Name Type Description parser module:EBNF~Parser context. Source: ebnf.js, line 255 Throws: if recognition fails. Type string Returns: the result produce by the referenced rule, see parser.parse(). shallow( [increment]) Override getter: delegates to the referenced rule if any. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 223 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays name of a non-terminal or $accept. Inherited From: module:Base~NT#toString Overrides: module:Base~NT#toString Source: base.js, line 448 Returns: Type string × Search results Close "},"module-EBNF-Node.html":{"id":"module-EBNF-Node.html","title":"Mixin: Node","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Node EBNF~ Node Acts as a superclass of all elements of a grammar tree, specifies the methods to recursively check LL(1) and defines the parse method for terminal symbols. Properties: Name Type Argument Description expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Source: ebnf.js, line 52 Methods check(error, name) Check for ambiguity, override to report an error. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule, to label errors. Source: ebnf.js, line 108 Returns: error message, if any. Type undefined | string deep() Manage .expect during grammar checking: shallow() acts as getter; override to compute .expect from left to right as far as necessary. shallow( increment ) acts as setter; adds to .expect. deep() also acts as getter, override to completely compute .expect. Source: ebnf.js, line 80 Returns: the set, maps terminal names to true. Type module:EBNF~Set dump() Displays the same as toString(). Source: ebnf.js, line 128 follow( [increment]) Manage .follow during grammar checking, creates initial set. follow() getter, may return null. follow( increment ) setter, adds to .follow, creates if necessary, override to compute from right to left. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 92 Returns: getter: the set, maps terminal names to true, setter: undefined. Type module:EBNF~Set parse(parser) Consume the current input symbol (because it is expected). This method should be redefined in all but the classes representing terminal symbols. Parameters: Name Type Description parser module:EBNF~Parser context. Source: ebnf.js, line 118 Throws: if recognition fails. Type string Returns: the input string. Type string shallow( [increment]) Manage .expect during grammar checking: shallow() acts as getter; override to compute .expect from left to right as far as necessary. shallow( increment ) acts as setter; adds to .expect. deep() also acts as getter, override to completely compute .expect. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 67 Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set × Search results Close "},"module-EBNF-Opt.html":{"id":"module-EBNF-Opt.html","title":"Class: Opt","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Opt EBNF~ Opt Represents an optional list of alternatives. Note that Seq implements optional. new Opt(seqs) Creates an optional list of alternatives; see opt() factory method. Parameters: Name Type Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. Properties: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Source: ebnf.js, line 597 Extends module:EBNF~Alt Methods check(error, name) Check for ambiguity: expect and follow must be disjoint; delegate to superclass. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule. Overrides: module:EBNF~Alt#check Source: ebnf.js, line 610 Returns: error message, if any. Type undefined | string deep() Override getter: computes the set as sum over all descendants. Inherited From: module:EBNF~Alt#deep Overrides: module:EBNF~Alt#deep Source: ebnf.js, line 437 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set follow( [increment]) Override setter: sets me and all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Inherited From: module:EBNF~Alt#follow Overrides: module:EBNF~Alt#follow Source: ebnf.js, line 449 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Recognizes one of several alternatives. Parameters: Name Type Description parser module:EBNF~Parser context. Inherited From: module:EBNF~Alt#parse Overrides: module:EBNF~Alt#parse Source: ebnf.js, line 481 Throws: if recognition fails. Type string Returns: the list produced by the selected descendant Seq, see parser.parse(). Type Array shallow( [increment]) Override getter: computes the set as sum over all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Inherited From: module:EBNF~Alt#shallow Overrides: module:EBNF~Alt#shallow Source: ebnf.js, line 421 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays alternatives in brackets. Overrides: module:EBNF~Alt#toString Source: ebnf.js, line 621 Returns: Type string × Search results Close "},"module-EBNF-Parser.html":{"id":"module-EBNF-Parser.html","title":"Class: Parser","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Parser EBNF~ Parser Wraps a method parser.parse() which recognizes input and builds a tree of nested lists, calls action functions, if any. new Parser(grammar [, skip]) Creates a parser; see parser() factory method. Parameters: Name Type Argument Description grammar module:EBNF~Grammar represents grammar and states. skip RegExp &lt;optional&gt; a pattern to define ignorable character sequences, by default white space, must not accept empty input, must not use d, g, or y flag, should not be anchored, should use (:? )rather than ( ) for grouping. Properties: Name Type Argument Description scanner module:Base~Scanner &lt;nullable&gt; tokenizes input. tuples Array.&lt;?module:Base~Tuple&gt; tokenized input during recognition. index number index of next tuple during recognition. current module:Base~Tuple &lt;nullable&gt; current input tuple or null for end of input during recognition. ruleStack Array.&lt;?module:EBNF:Rule&gt; currently activated rules during recognition. grammar module:EBNF~Grammar represents the grammar, counts errors; concurrent recognition will trash error counting. actions Object.&lt;string, module:Base~Action&gt; &lt;nullable&gt; maps rule names to action functions or methods during recognition. data Object &lt;nullable&gt; context for all actions during recognition. Properties Name Type Description parser module:Base~Parser set to this unless already defined by caller. oop boolean true if .actions is set to a singleton with ClassAction methods. Source: ebnf.js, line 768 Extends module:Base~Parser Methods act(name, result) Calls an action method. Checks argument count unless grammar.config.noargs is set or the method expects no arguments, i.e., has a rest parameter. Parameters: Name Type Description name string rule name to match. result Array list of arguments. Inherited From: module:Base~Parser#act Overrides: module:Base~Parser#act Source: base.js, line 758 Returns: action method result or unchanged result. call(target, method, args) Checks if argument and parameter count of a method match unless the method expects no parameters, or has a rest parameter or grammar.config.noargs is true. Parameters: Name Type Argument Description target object to apply method to. method function to check. args Object &lt;repeatable&gt; arguments to pass. Inherited From: module:Base~Parser#call Overrides: module:Base~Parser#call Source: base.js, line 787 Returns: method result. Type Object Example super.method(arg1, .. argn) this.parser.call(this, super.method, arg1, .. argn) error(s) Displays a message and the rule stack, if any; lets grammar count it as an error. Parameters: Name Type Argument Description s Array.&lt;object&gt; &lt;repeatable&gt; message, to be displayed; prefixed by .current and joined by blanks. Source: ebnf.js, line 892 Returns: the message. Type string next(caller) Advances .index and, therefore, .current to the next element of .tuples, if any. Finds or creates null as .current to indicate end of input. Ignores illegal characters but only reports the first in a sequence. Implements lookahead trace. Parameters: Name Type Description caller string for trace. Source: ebnf.js, line 805 parse(input [, actions], arg) Recognizes an input sentence. Requires grammar.expect(). Resets and reports .errors for the grammar. Parameters: Name Type Argument Default Description input string to process. actions function | Object &lt;optional&gt; null a function is assumed to be a class and a singleton is created with this as constructor argument. The object maps rule names to action methods. arg Object &lt;repeatable&gt; used as further constructor arguments. Overrides: module:Base~Parser#parse Source: ebnf.js, line 858 Throws: error message, also reported by parser.error(). Type string Returns: the collected sequence of values or the value produced by the action of the start rule. The parsing methods return the following types, where object refers to the result produced by the action of a rule. class returns Lit string Token string Alt Array Opt null|Array Seq Array Some Array&lt;Array&gt; Rule Array|object NT Array|object Type Array | Object × Search results Close "},"module-EBNF-Rule.html":{"id":"module-EBNF-Rule.html","title":"Class: Rule","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Rule EBNF~ Rule Represents an EBNF rule. new Rule(nt, seqs) Creates an EBNF rule; see rule() factory method. Parameters: Name Type Description nt module:EBNF~NT left-hand side, non-terminal. seqs Array.&lt;module:EBNF~Seq&gt; the alternatives on the right-hand side. Properties: Name Type Argument Description nt module:EBNF~NT rule's non-terminal (left-hand side). recursed number counts nesting during shallow lookahead computation for all rules. reached boolean true if rule is reached during deep lookahead computation from the start rule; avoids multiple computations. seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Source: ebnf.js, line 507 Extends module:EBNF~Alt Methods check(error, name) Check for ambiguity: descendants' expect must be disjoint. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule. Inherited From: module:EBNF~Alt#check Overrides: module:EBNF~Alt#check Source: ebnf.js, line 463 Returns: error message, if any. Type undefined | string deep() Override getter: sets .reached, inherits: computes the set as sum over all descendants. Overrides: module:EBNF~Alt#deep Source: ebnf.js, line 554 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set follow( [increment]) Override setter: sets me and all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Inherited From: module:EBNF~Alt#follow Overrides: module:EBNF~Alt#follow Source: ebnf.js, line 449 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Delegates to superclass to recognize the descendants and processes the result with the corresponding action if any. The rule name selects either a function-valued property or a method of the actions object. Parameters: Name Type Description parser module:EBNF~Parser context. Overrides: module:EBNF~Alt#parse Source: ebnf.js, line 570 Throws: if recognition fails or if the action throws. Type string Returns: the result produced by the selected descendant and modified by the action, if any, see parser.parse(). shallow( [increment]) Override getter: if left recursion returns empty set (which cannot happen...); otherwise inherits: computes the set as sum over all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Overrides: module:EBNF~Alt#shallow Source: ebnf.js, line 533 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays a rule in EBNF notation. Overrides: module:EBNF~Alt#toString Source: ebnf.js, line 582 Returns: Type string × Search results Close "},"module-EBNF-Seq.html":{"id":"module-EBNF-Seq.html","title":"Class: Seq","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Seq EBNF~ Seq Represents a sequence of nodes, i.e., one alternative. new Seq(nodes [, terminal]) Creates a sequence of nodes, i.e., one alternative; see factory method grammar.seq(). Parameters: Name Type Argument Description nodes Array.&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt; descendants, not empty, not all Opt. terminal module:Base~T &lt;optional&gt; &lt;nullable&gt; can define precedence; only for translation to BNF. Properties: Name Type Argument Description nodes Array.&lt;(module:Base~Symbol|module:EBNF~Opt|module:EBNF~Some)&gt; descendants, not empty, not all Opt. terminal module:Base~T &lt;optional&gt; &lt;nullable&gt; can define precedence; only for translation to BNF. expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Mixes In: module:EBNF~Node Source: ebnf.js, line 280 Methods check(error, name) Check for ambiguity: delegate to descendants. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule. Source: ebnf.js, line 359 Returns: error message, if any. Type undefined | string deep() Override getter: computes the set from right to left, implements optional. Source: ebnf.js, line 324 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set follow( [increment]) Override setter: sets me, and sets descendants, pushing from right to left; implements optional. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 340 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Recognizes a sequence of descendants; implements Opt with a result of null or the collected array. Parameters: Name Type Description parser module:EBNF~Parser context. Source: ebnf.js, line 375 Throws: if recognition fails. Type string Returns: list of results produced by the descendants, cannot be empty, see parser.parse(). Type Array shallow( [increment]) Override getter: computes .expect from left to right as far as necessary. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Source: ebnf.js, line 306 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Throws: Seq: all elements are optional (cannot happen) Type Error Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays all descendants and precedence terminal, if any. Source: ebnf.js, line 390 Returns: Type string × Search results Close "},"module-EBNF-Set.html":{"id":"module-EBNF-Set.html","title":"Class: Set","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Set EBNF~ Set Class representing a set of unique, non-empty names. new Set(names) Create a set containing some unique names. Parameters: Name Type Argument Description names Array.&lt;string&gt; &lt;repeatable&gt; to be in the set, implied to be unique. Properties: Name Type Description set Object.&lt;string, boolean&gt; maps names to true. length number the number of names in the set. Source: ebnf.js, line 694 Methods import(other) Import another set. Parameters: Name Type Description other module:EBNF~Set to import. Source: ebnf.js, line 710 Returns: this set, changed. Type module:EBNF~Set includes(other) Check if this set includes another set. Parameters: Name Type Description other module:EBNF~Set the other set. Source: ebnf.js, line 728 Returns: true if the other set is a subset of this set. Type boolean match(tuple) Check if next input matches. Parameters: Name Type Argument Description tuple module:Base~Tuple &lt;nullable&gt; next available input symbol. Source: ebnf.js, line 719 Returns: true if matched, false otherwise. Type boolean overlap(other) Check if two sets overlap. Parameters: Name Type Description other module:EBNF~Set the other set. Source: ebnf.js, line 736 Returns: the overlap, a new set, may be empty. Type module:EBNF~Set toString() Displays the elements. Source: ebnf.js, line 745 × Search results Close "},"module-EBNF-Some.html":{"id":"module-EBNF-Some.html","title":"Class: Some","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Some EBNF~ Some Represents a repeatable list of alternatives. new Some(seqs) Creates a repeatable list of alternatives; see some() factory method. Parameters: Name Type Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. Properties: Name Type Argument Description seqs Array.&lt;module:EBNF~Seq&gt; the alternatives. expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). Source: ebnf.js, line 633 Extends module:EBNF~Alt Methods check(error, name) Check for ambiguity: expect and follow must be disjoint; delegate to superclass. Parameters: Name Type Description error function should be bound to grammar.error(). name string current rule. Overrides: module:EBNF~Alt#check Source: ebnf.js, line 661 Returns: error message, if any. Type undefined | string deep() Override getter: computes the set as sum over all descendants. Inherited From: module:EBNF~Alt#deep Overrides: module:EBNF~Alt#deep Source: ebnf.js, line 437 See: {linkcode module:EBNF~Node#deep Node.deep(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set follow( [increment]) Override setter: sets me, and sets descendants to my .expect plus increment. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Overrides: module:EBNF~Alt#follow Source: ebnf.js, line 646 See: {linkcode module:EBNF~Node#follow Node.fallow(increment)}. Returns: the set, maps terminal names to true. Type module:EBNF~Set parse(parser) Recognizes the descendants one or more times. Parameters: Name Type Description parser module:EBNF~Parser context. Overrides: module:EBNF~Alt#parse Source: ebnf.js, line 676 Throws: if recognition fails. Type string Returns: list of at least one list created by a descendant Alt, see parser.parse(). The descendants are Type Array.&lt;Array&gt; shallow( [increment]) Override getter: computes the set as sum over all descendants. Parameters: Name Type Argument Description increment module:EBNF~Set &lt;optional&gt; &lt;nullable&gt; controls getter/setter behavior, setter adds. Inherited From: module:EBNF~Alt#shallow Overrides: module:EBNF~Alt#shallow Source: ebnf.js, line 421 See: {linkcode module:EBNF~Node#shallow Node.shallow(increment)}. Returns: the (incremented) set, maps terminal names to true. Type module:EBNF~Set toString() Displays a alternatives in braces. Overrides: module:EBNF~Alt#toString Source: ebnf.js, line 686 Returns: Type string × Search results Close "},"module-EBNF-Token.html":{"id":"module-EBNF-Token.html","title":"Class: Token","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Token EBNF~ Token Represents a token symbol for EBNF. new Token(name, pat) Creates a token symbol for BNF; see factory method grammar.token(). Sets .expect to contain this. Parameters: Name Type Description name string token name. pat RegExp for a token. Properties: Name Type Argument Description expect module:EBNF~Set set of terminals which a node expects to see as parser.current.t, maps terminal names to true; expect is not empty. follow module:EBNF~Set &lt;nullable&gt; see node.follow(). name string name for the token. Empty string is reserved for $error, can be something unexpected; only for translation to BNF. used boolean true if used in a grammar. prec Object precedence. Properties Name Type Argument Description assoc string &lt;optional&gt; associativity, '%left', '%right', or '%nonassoc', if any. level number &lt;optional&gt; precedence level, from 0, if any. pat RegExp pattern for token; empty RegExp for $error. screen Array.&lt;Lit&gt; &lt;optional&gt; contains literals with values matching the pattern, if any. Mixes In: module:EBNF~Node Source: ebnf.js, line 180 Extends module:Base~Token Methods dump() Displays description and precedence, if any. Inherited From: module:Base~T#dump Overrides: module:Base~Token#dump Source: base.js, line 279 Returns: Type string toString() Displays name of a token or $error. Inherited From: module:Base~Token#toString Overrides: module:Base~Token#toString Source: base.js, line 396 Returns: Type string × Search results Close "},"module-Eight.html":{"id":"module-Eight.html","title":"Module: Eight","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Eight This module contains the classes for all examples in chapter eight. Version: 2024-06-24 Author: © 2024 Axel T. Schreiner Source: 08.js, line 1 Mixins First14 Global01 Machine01 Machine08 Machine14 Pass08 × Search results Close "},"module-Eight-First14.html":{"id":"module-Eight-First14.html","title":"Mixin: First14","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: First14 Eight~ First14 Example 8/14: adds actions and infrastructure to compile nested functions as first-order values. Requires Nest13 and Global01, cannot be mixed with Pass08. Source: 08.js, line 856 Classes Fun Var Methods _lift(args) [replace] need two slots for function argument and value. Parameters: Name Type Description args Array.&lt;Type&gt; list of argument types. Source: 08.js, line 1043 _startup(main) [Replace] Need PushFP for main. Parameters: Name Type Description main Fun describes main(). Source: 08.js, line 981 call() call: { args }; pops extra slot for function value. Source: 08.js, line 1032 return() return: 'return' [ sum ]; [extend] pops extra slot for function value. Source: 08.js, line 1057 store() store: '=' sum; [extend] pops extra slot for function value. Source: 08.js, line 1024 varname() varname: Name [ ':' type ]; [extend] two slots for function value. Source: 08.js, line 1000 × Search results Close "},"module-Eight-First14_Fun.html":{"id":"module-Eight-First14_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Eight~First14# Fun @extends super.Fun new Fun() Describes a function in First14. Properties: Name Type Description parms number [replace] memory slots for arguments. setParms() function [replace] function values take 2 slots similar to Pass08.Fun.setParms(). call() function [extend] PushFP, Call(addr). load() function [extend] PushFP, Push(start). store() function [replace] StoreGC. exit() function [replace] Entry, Exit. Source: 08.js, line 904 × Search results Close "},"module-Eight-First14_Var.html":{"id":"module-Eight-First14_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Eight~First14# Var @extends super.Var new Var() Describes a variable in First14. Properties: Name Type Description load() function [replace] local/global and function slots store() function [replace] local/global and function slots Source: 08.js, line 863 × Search results Close "},"module-Eight-Global01.html":{"id":"module-Eight-Global01.html","title":"Mixin: Global01","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Global01 Eight~ Global01 Example 8/01: adds actions and infrastructure to compile global higher-order functions. Source: 08.js, line 30 Classes Fun Type Var Members &lt;constant&gt; mainType :Type Predefined type descriptor for main (): number. Type: Type Source: 08.js, line 76 &lt;constant&gt; numberType :Type Predefined type descriptor for number. Type: Type Source: 08.js, line 69 typeSymbols Type table, maps names to descriptions. Source: 08.js, line 62 Methods _lift(args) Move function address past arguments to the top of the stack. Parameters: Name Type Description args Array.&lt;Type&gt; list of argument types. Source: 08.js, line 323 add() add: '+' product; checks for number Source: 08.js, line 440 args() args: '(' [ sums ] ')'; codes call, chains context Source: 08.js, line 291 cmp() cmp: sum rel; checks for number Source: 08.js, line 366 divide() divide: '/' signed; checks for number Source: 08.js, line 477 eq() eq: '=' sum; checks for number Source: 08.js, line 376 ge() ge: '&gt;=' sum; checks for number Source: 08.js, line 403 gt() gt: '&gt;' sum; checks for number Source: 08.js, line 394 input() input: 'input' [ Number ]; returns `this.numberType Source: 08.js, line 501 le() le: '&lt;=' sum; checks for number Source: 08.js, line 421 lt() lt: '&lt;' sum; checks for number Source: 08.js, line 412 multiply() multiply: '*' signed; checks for number Source: 08.js, line 468 name() name: symbol [{ args }]; Source: 08.js, line 515 ne() ne: '&lt;&gt;' sum; checks for number Source: 08.js, line 385 number() number: Number; returns this.numberType Source: 08.js, line 508 parms() parms: '(' [ names ] ')' [ ':' Name ]; declares Source: 08.js, line 267 print() print: 'print' sums; checks types Source: 08.js, line 330 product() product: signed [{ multiply | divide }]; returns signed Source: 08.js, line 458 prog() prog: [ typedcls ] [ vars ] funs; Source: 08.js, line 192 return() return: 'return' [ sum ]; Source: 08.js, line 347 signed() signed: [ '-' ] term; checks for number, returns term Source: 08.js, line 486 store() store: '=' sum; expects context, codes assignment Source: 08.js, line 281 subtract() subtract: '-' product; checks for number Source: 08.js, line 449 sum() sum: product [{ add | subtract }]; returns product Source: 08.js, line 430 sums() sums: sum [{ ',' sum }]; returns list of types Source: 08.js, line 339 term() term: input | number | name | '(' sum ')'; returns type Source: 08.js, line 496 type() type: Name | 'number'; returns type symbol Source: 08.js, line 252 typedcl() typedcl: Name '(' [ types ] ')' [ ':' typename ]; declares Source: 08.js, line 216 typedcls() typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; checks and translates the types Source: 08.js, line 197 typename() typename: Name | 'number'; returns name or 'number' Source: 08.js, line 235 types() types: typename [{ ',' typename }]; returns list Source: 08.js, line 227 varname() varname: Name [ ':' type ]; declares the name. Can be used with one or two arguments, defaults to number. Source: 08.js, line 243 × Search results Close "},"module-Eight-Global01_Fun.html":{"id":"module-Eight-Global01_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Eight~Global01# Fun @extends super.Fun new Fun() Describes a function in Global01. Properties: Name Type Description type Type function's type. loads Array.&lt;number&gt; slots to insert Push start. setParms() function [replace] set/check types. load() function generates Push(start). storeOk() function [extend] check type. end() function [extend] fixes loads toString() function [extend] shows type, if any. Source: 08.js, line 90 × Search results Close "},"module-Eight-Global01_Type.html":{"id":"module-Eight-Global01_Type.html","title":"Class: Type","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Type Eight~Global01# Type @extends super.Symbol new Type() Describes a type. Properties: Name Type Argument Description parms Array.&lt;(String|Type)&gt; &lt;nullable&gt; null for scalar, else list of parameter types. returns String | Type null or result type. isFun Boolean true if function type. toString() function represents as text. Source: 08.js, line 39 × Search results Close "},"module-Eight-Global01_Var.html":{"id":"module-Eight-Global01_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Eight~Global01# Var @extends super.Var new Var() Describes a variable in Global01. Properties: Name Type Description type Type variable's type. storeOk() function [replace] check type. call() function code call to value toString() function [extend] show type, if any. Source: 08.js, line 160 × Search results Close "},"module-Eight-Machine01.html":{"id":"module-Eight-Machine01.html","title":"Mixin: Machine01","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Machine01 Eight~ Machine01 Example 8/01: adds support for global higher-order functions. Source: 08.js, line 12 Methods CallValue() stack: ... addr -&gt; ... old-pc | pc: addr Source: 08.js, line 16 Rotate() stack: ... x-len n*val -&gt; ... n*val x-len Source: 08.js, line 22 × Search results Close "},"module-Eight-Machine08.html":{"id":"module-Eight-Machine08.html","title":"Mixin: Machine08","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Machine08 Eight~ Machine08 Example 8/08: adds support for nested functions as arguments. Source: 08.js, line 527 Methods Entry(args, depth, vars) stack: ... arguments dp old-pc -&gt; ... arguments old-pc old-fp old-dp result display locals Parameters: Name Type Description args number size of argument values. depth number number of display entries. vars number size of local variables. Source: 08.js, line 535 Exit(args) stack: ... arguments old-pc old-fp old-dp result display locals -&gt; ... result old-pc Parameters: Name Type Description args number size of argument values. Source: 08.js, line 554 PushDP() stack: ... -&gt; ... dp Source: 08.js, line 566 × Search results Close "},"module-Eight-Machine14.html":{"id":"module-Eight-Machine14.html","title":"Mixin: Machine14","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Machine14 Eight~ Machine14 Example 8/14: adds support for garbage-collected frames, cannot be mixed with Machine08. Source: 08.js, line 745 Classes Memory Methods Entry(args, depth, result, vars) stack: ... arguments fp old-pc -&gt; ... | frame: old-pc old-fp display result arguments locals Parameters: Name Type Description args number size of argument values. depth number number of display entries. result number size of result value. vars number size of local variables. Source: 08.js, line 796 Exit(depth, result) stack: ... | frame: old-pc old-fp display result ... -&gt; ... result old-pc | fp: old-fp | frame unchanged Parameters: Name Type Description depth number number of display entries. result number size of result value. Source: 08.js, line 819 LoadGC() stack: ... -&gt; ... frame[depth][addr] Source: 08.js, line 831 PushFP() stack: ... -&gt; ... fp Source: 08.js, line 846 StoreGC() stack: ... val -&gt; ... val | frame[depth][addr]: val Source: 08.js, line 838 × Search results Close "},"module-Eight-Machine14_Memory.html":{"id":"module-Eight-Machine14_Memory.html","title":"Class: Memory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Memory Eight~Machine14# Memory @extends super.Memory new Memory() Data memory for nested functions as arguments Properties: Name Type Argument Description fp Array &lt;nullable&gt; current frame dp number no longer used id number current tag for frames (trace) newId number new tag for frames (trace) dirty Array &lt;nullable&gt; changed frame (trace) toString() function [replace] interpret dirty frame Source: 08.js, line 756 × Search results Close "},"module-Eight-Pass08.html":{"id":"module-Eight-Pass08.html","title":"Mixin: Pass08","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Pass08 Eight~ Pass08 Example 8/08: adds actions and infrastructure to compile nested functions as arguments. Requires Nest13 and Global01. Source: 08.js, line 574 Classes Fun Var Methods _startup(main) [Replace] Need PushDP for main. Parameters: Name Type Description main Fun describes main(). Source: 08.js, line 679 × Search results Close "},"module-Eight-Pass08_Fun.html":{"id":"module-Eight-Pass08_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Eight~Pass08# Fun @extends super.Fun new Fun() Describes a function in Pass08. Properties: Name Type Description parms number [replace] memory slots for arguments. setParms() function [replace] function values take 2 slots. call() function [extend] PushDP, Call(addr). load() function [extend] PushDP, Push(start). exit() function [replace] Entry, Exit. Source: 08.js, line 617 × Search results Close "},"module-Eight-Pass08_Var.html":{"id":"module-Eight-Pass08_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Eight~Pass08# Var @extends super.Var new Var() Describes a variable in Pass08 Properties: Name Type Description load() function [replace] for function slots. storeOk(type) function [extend] false for function value. Source: 08.js, line 582 × Search results Close "},"module-Eleven.html":{"id":"module-Eleven.html","title":"Module: Eleven","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Eleven This module contains classes and mix-ins to compile various stages of a little language using builder actions to represent programs as trees and visitors to interpret, check types, and compile. The details are discussed in chapter 11 and appendix D. A tree consists of nodes represented as nested Array objects, each consisting of a string tag selecting a method of a visitor, followed by zero or more nodes or other argument values. visit cannot be a tag. A tree node can have .lineno and .type properties referring to the source line number and the type (bool, number, or string) delivered by the node. visitor._dump(node) displays the properties if they exist. The module assumes that there are globalThis definitions of puts() for output and prompt() for num which are available to eval(). Version: 2024-08-04 Author: © 2023 Axel T. Schreiner Source: 11.js, line 1 Classes Build Check Code Visit Mixins Build_Bool Build_Cast Build_Cmps Build_Dcl Build_Names Build_Number Build_RD Build_Stmts Build_String Check_Bool Check_Cast Check_Cmps Check_Dcl Check_Names Check_Number Check_Stmts Check_String Code_Bool Code_Cast Code_Cmps Code_Dcl Code_Names Code_Number Code_Stmts Code_String Compile Eval_Bool Eval_Cast Eval_Cmps Eval_Dcl Eval_Names Eval_Number Eval_Stmts Eval_String Main Symbols Members Instructions Power instruction. Source: 11.js, line 1161 Methods Bnzero() stack: ... bool -&gt; ... | pc: bool? a Source: 11.js, line 1304 Cast() stack: ... a -&gt; ... cast a Source: 11.js, line 1517 Concat() stack: ... a b -&gt; ... a+b Source: 11.js, line 1463 IfFalse() stack: ... bool -&gt; ... bool | pc: !bool? a Source: 11.js, line 1374 IfTrue() stack: ... bool -&gt; ... bool | pc: bool? a Source: 11.js, line 1370 InputString() stack: ... -&gt; ... val Source: 11.js, line 1471 Len() stack: ... a -&gt; ... a.length Source: 11.js, line 1467 Not() stack: ... a -&gt; ... !a Source: 11.js, line 1378 Power() stack: ... a b -&gt; ... a**b Source: 11.js, line 1165 × Search results Close "},"module-Eleven-Build.html":{"id":"module-Eleven-Build.html","title":"Class: Build","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Build Eleven~ Build Base class for tree building. Private method names start with an underscore. new Build() Sets the property Properties: Name Type Description parser module:Base~Parser access to source position. Source: 11.js, line 36 Methods _lineno() Tags node with source position as .lineno if available. Source: 11.js, line 41 × Search results Close "},"module-Eleven-Build_Bool.html":{"id":"module-Eleven-Build_Bool.html","title":"Mixin: Build_Bool","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Bool Eleven~ Build_Bool Class actions to represent Boolean expressions as trees. Source: 11.js, line 551 Methods and() and: expr 'and' expr; returns [ 'and' a b ] Source: 11.js, line 560 bool() bool: 'true' | 'false'; returns [ 'bool' bool ] Source: 11.js, line 570 not() not: 'not' expr; returns [ 'not' b ] Source: 11.js, line 565 or() or: expr 'or' expr; returns [ 'or' a b ] Source: 11.js, line 555 × Search results Close "},"module-Eleven-Build_Cast.html":{"id":"module-Eleven-Build_Cast.html","title":"Mixin: Build_Cast","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Cast Eleven~ Build_Cast Class action to represent type casts as trees. Source: 11.js, line 604 Methods cast() cast: '(' type ')' expr; returns [ 'cast' type b ] Source: 11.js, line 613 type() type: 'bool' | 'number' | 'string'; returns type Source: 11.js, line 608 × Search results Close "},"module-Eleven-Build_Cmps.html":{"id":"module-Eleven-Build_Cmps.html","title":"Mixin: Build_Cmps","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Cmps Eleven~ Build_Cmps Class actions to represent comparisons as trees. Source: 11.js, line 397 Methods eq() eq: expr '=' expr; returns [ 'eq' a b ] Source: 11.js, line 401 ge() ge: expr '&gt;=' expr; returns [ 'ge' a b ] Source: 11.js, line 416 gt() gt: expr '&gt;' expr; returns [ 'gt' a b ] Source: 11.js, line 411 le() le: expr '&lt;=' expr; returns [ 'le' a b ] Source: 11.js, line 426 lt() lt: expr '&lt;' expr; returns [ 'lt' a b ] Source: 11.js, line 421 ne() ne: expr '&lt;&gt;' expr; returns [ 'ne' a b ] Source: 11.js, line 406 × Search results Close "},"module-Eleven-Build_Dcl.html":{"id":"module-Eleven-Build_Dcl.html","title":"Mixin: Build_Dcl","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Dcl Eleven~ Build_Dcl Class actions to represent a block with declarations and other items as a tree. Source: 11.js, line 952 Methods block() block: item [{ ';' item }]; item: dcl | stmt; returns [ 'block' dcl... stmt... ] Source: 11.js, line 956 dcl() dcl: type Name [{ ',' Name }]; returns [ 'dcl' type name ... ] Source: 11.js, line 967 × Search results Close "},"module-Eleven-Build_Names.html":{"id":"module-Eleven-Build_Names.html","title":"Mixin: Build_Names","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Names Eleven~ Build_Names Class actions to represent names in a tree. Source: 11.js, line 380 Methods assign() assign: Name '=' expr; returns [ 'assign' name expr ] Source: 11.js, line 384 name() name: Name; returns [ 'name' name ] Source: 11.js, line 391 × Search results Close "},"module-Eleven-Build_Number.html":{"id":"module-Eleven-Build_Number.html","title":"Mixin: Build_Number","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Number Eleven~ Build_Number Class actions to represent an arithmetic expression as a tree using a precedence table. Source: 11.js, line 115 Methods add() add: expr '+' expr; returns [ 'add' a b ] Source: 11.js, line 124 divide() divide: expr '/' expr; returns [ 'divide' a b ] Source: 11.js, line 139 expr() expr: add | ... | '(' expr ')' | number; returns tree Source: 11.js, line 119 minus() minus: '-' expr; returns [ 'minus' b ] Source: 11.js, line 149 multiply() multiply: expr '*' expr; returns [ 'multiply' a b ] Source: 11.js, line 134 number() number: Number; returns [ 'number' number ] Source: 11.js, line 154 power() power: expr '**' expr; returns [ 'power' a b ] Source: 11.js, line 144 subtract() subtract: expr '-' expr; returns [ 'subtract' a b ] Source: 11.js, line 129 × Search results Close "},"module-Eleven-Build_RD.html":{"id":"module-Eleven-Build_RD.html","title":"Mixin: Build_RD","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_RD Eleven~ Build_RD Class actions to represent an arithmetic expression as a tree using recursive descent. Source: 11.js, line 52 See: example 6/07 Methods add() add: '+' product; returns [ 'add' null product ] Source: 11.js, line 70 divide() divide: '/' signed; returns [ 'divide' null signed ] Source: 11.js, line 92 list() list: sum [{ ',' sum }]; returns [ 'list' sum ... ] Source: 11.js, line 56 multiply() multiply: '*' signed; returns [ 'multiply' null signed ] Source: 11.js, line 87 number() number: Number; returns [ 'number' number ] Source: 11.js, line 107 product() product: signed [{ multiply | divide }]; returns tree Source: 11.js, line 80 signed() signed: [ '-' ] term; returns term or [ 'minus' term ] Source: 11.js, line 97 subtract() subtract: '-' product; returns [ 'subtract' null product ] Source: 11.js, line 75 sum() sum: product [{ add | subtract }]; returns tree Source: 11.js, line 63 term() term: number | name | '(' sum ')'; returns tree Source: 11.js, line 102 × Search results Close "},"module-Eleven-Build_Stmts.html":{"id":"module-Eleven-Build_Stmts.html","title":"Mixin: Build_Stmts","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_Stmts Eleven~ Build_Stmts Class actions to represent a list of statements as a tree. Source: 11.js, line 331 Methods loop() loop: 'while' expr 'do' stmts 'od'; returns [ 'loop' expr stmts ] Source: 11.js, line 364 print() print: 'print' expr [{ ',' expr }]; returns [ 'print' expr ... ] Source: 11.js, line 353 select() select: 'if' expr 'then' stmts [ 'else' stmts ] 'fi'; returns [ 'select' expr left right? ] Source: 11.js, line 371 stmt() stmt: print | ...; returns tree Source: 11.js, line 348 stmts() stmts: stmt [{ ';' stmt }]; returns stmt or [ 'stmts' stmt ... ] Source: 11.js, line 336 × Search results Close "},"module-Eleven-Build_String.html":{"id":"module-Eleven-Build_String.html","title":"Mixin: Build_String","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Build_String Eleven~ Build_String Class actions to represent string expressions as trees. Source: 11.js, line 576 Methods input() input: 'input' [ String String ]; returns [ 'input' unescaped-string unescaped-string ] Source: 11.js, line 580 len() len: 'len' expr; returns [ 'len' b ] Source: 11.js, line 590 string() string: String; returns [ 'string' unescaped-string ] Source: 11.js, line 595 × Search results Close "},"module-Eleven-Check.html":{"id":"module-Eleven-Check.html","title":"Class: Check","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Check Eleven~ Check Base class for type checking. new Check() Source: 11.js, line 729 Methods _literal(node) Utility: accepts [ type value ], sets .type from tag, returns node. Parameters: Name Type Description node Array to check. Source: 11.js, line 732 _require(type, node) Utility: casts all operands to type if needed, sets .type, returns node. Parameters: Name Type Description type string expected. node Array tree to check. Source: 11.js, line 751 _toType(type, node, index) Utility: visits and casts node[index] to type if needed, returns node. Parameters: Name Type Description type string expected. node Array parent of subtree to check. index number of subtree in node. Source: 11.js, line 742 × Search results Close "},"module-Eleven-Check_Bool.html":{"id":"module-Eleven-Check_Bool.html","title":"Mixin: Check_Bool","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Bool Eleven~ Check_Bool Methods to check Boolean expressions, cast to bool if needed, return bool node. Source: 11.js, line 862 Methods and(node) [ 'and' a b ] casts to bool. Parameters: Name Type Description node Array to check. Source: 11.js, line 873 bool(node) [ 'bool' value ] expects boolean value. Parameters: Name Type Description node Array to check. Source: 11.js, line 885 not(node) [ 'not' b ] casts to bool. Parameters: Name Type Description node Array to check. Source: 11.js, line 879 or(node) [ 'or' a b ] casts to bool. Parameters: Name Type Description node Array to check. Source: 11.js, line 867 × Search results Close "},"module-Eleven-Check_Cast.html":{"id":"module-Eleven-Check_Cast.html","title":"Mixin: Check_Cast","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Cast Eleven~ Check_Cast Method to check explicit cast, sets .type from cast, returns typed node. Source: 11.js, line 936 Methods cast(node) [ 'cast' type b ] returns node.type. Parameters: Name Type Description node Array to check. Source: 11.js, line 941 × Search results Close "},"module-Eleven-Check_Cmps.html":{"id":"module-Eleven-Check_Cmps.html","title":"Mixin: Check_Cmps","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Cmps Eleven~ Check_Cmps Methods to check comparisons, cast to left operand's type if needed, return bool node. Source: 11.js, line 810 Methods _cmp(node) Casts right operand to left operand's type if needed. Parameters: Name Type Description node Array to check. Source: 11.js, line 815 eq(node) [ 'eq' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 826 ge(node) [ 'ge' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 843 gt(node) [ 'gt' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 837 le(node) [ 'le' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 855 lt(node) [ 'lt' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 849 ne(node) [ 'ne' a b ] Parameters: Name Type Description node Array to check. Source: 11.js, line 831 × Search results Close "},"module-Eleven-Check_Dcl.html":{"id":"module-Eleven-Check_Dcl.html","title":"Mixin: Check_Dcl","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Dcl Eleven~ Check_Dcl Methods to check a list of statements and declarations, return node. Source: 11.js, line 1049 Methods block(node) [ 'block' dcl ... other ... ] replaces each node by the result of the visit, returns node. Parameters: Name Type Description node Array to check. Source: 11.js, line 1054 dcl() [ 'dcl' type Name ...] allocates and types each Name, returns node. Source: 11.js, line 1062 × Search results Close "},"module-Eleven-Check_Names.html":{"id":"module-Eleven-Check_Names.html","title":"Mixin: Check_Names","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Names Eleven~ Check_Names Methods to check names, return (typed) node. Requires Symbols. Source: 11.js, line 1013 Methods _type(lineno, name) Utility: returns type of name, defaulted to number. Parameters: Name Type Description lineno number for error message, if any. name string to find. Source: 11.js, line 1028 assign(node) [ 'assign' name value ] casts value to type of name. Parameters: Name Type Description node Array to check. Source: 11.js, line 1041 name(node) Returns node.type(name), if undefined node.number. Parameters: Name Type Description node Array to check. Source: 11.js, line 1018 × Search results Close "},"module-Eleven-Check_Number.html":{"id":"module-Eleven-Check_Number.html","title":"Mixin: Check_Number","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Number Eleven~ Check_Number Methods to check arithmetic expressions, cast to number if needed, return number node. Source: 11.js, line 762 Methods add(node) [ 'add' a b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 767 divide(node) [ 'divide' a b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 785 minus(node) [ 'minus' b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 797 multiply(node) [ 'multiply' a b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 779 number(node) [ 'number' value ] expects number value. Parameters: Name Type Description node Array to check. Source: 11.js, line 803 power(node) [ 'power' a b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 791 subtract(node) [ 'subtract' a b ] casts to number. Parameters: Name Type Description node Array to check. Source: 11.js, line 773 × Search results Close "},"module-Eleven-Check_Stmts.html":{"id":"module-Eleven-Check_Stmts.html","title":"Mixin: Check_Stmts","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_Stmts Eleven~ Check_Stmts Methods to check typed statements, return node. Source: 11.js, line 976 Methods loop(node) [ 'loop' cond stmt ] condition cast to bool. Parameters: Name Type Description node Array to check. Source: 11.js, line 995 print(node) [ 'print' value ... ] values cast to string. Parameters: Name Type Description node Array to check. Source: 11.js, line 989 select(node) [ 'select' cond then else? ] condition cast to bool. Parameters: Name Type Description node Array to check. Source: 11.js, line 1003 stmts(node) [ 'stmts' stmt ... ] checks each stmt. Parameters: Name Type Description node Array to check. Source: 11.js, line 981 × Search results Close "},"module-Eleven-Check_String.html":{"id":"module-Eleven-Check_String.html","title":"Mixin: Check_String","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Check_String Eleven~ Check_String Methods to check string expressions, cast to string if needed; requires Check_Number06 as superclass to defer to add. Return string node. Source: 11.js, line 893 Methods add(node) [ 'add' a b ] for at least one string casts to string and returns node as concat.string. Parameters: Name Type Description node Array to check. Source: 11.js, line 906 input(node) [ 'input' prompt? default? ] returns node.string. Parameters: Name Type Description node Array to check. Source: 11.js, line 898 len(node) [ 'len' b ] casts to string and returns node.number. Parameters: Name Type Description node Array to check. Source: 11.js, line 921 string(node) [ 'string' value ] expects string value, returns node.string. Parameters: Name Type Description node Array to check. Source: 11.js, line 930 × Search results Close "},"module-Eleven-Code.html":{"id":"module-Eleven-Code.html","title":"Class: Code","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Code Eleven~ Code Base class for code generation. new Code() Properties: Name Type Description Machine Object stack machine generator class. machine module:Six~Machine10 stack machine to generate code for. Source: 11.js, line 1126 Extends module:Eleven~Visit Members Instructions Extended stack machine instructions. Source: 11.js, line 1132 Machine Stack machine generator class. Source: 11.js, line 1128 executable The executable. Source: 11.js, line 1144 machine Stack machine generator. Source: 11.js, line 1138 Methods _dump(node [, shallow]) Creates a deep display of a node. Parameters: Name Type Argument Description node Array to recursively traverse. shallow number &lt;optional&gt; limits depth if non-negative, by default unlimited. Inherited From: module:Eleven~Visit#_dump Source: 11.js, line 192 _error() Displays and counts an error message. Inherited From: module:Eleven~Visit#_error Source: 11.js, line 170 _postfix(op) Visits the subtrees and generates an instruction. Parameters: Name Type Description op string instruction name. Source: 11.js, line 1149 Returns: end of code memory. Type number _tree(node) Recursively checks tree tags, throws an error if there is a problem. Parameters: Name Type Description node Array to validate. Inherited From: module:Eleven~Visit#_tree Source: 11.js, line 178 visit(node [, trace]) Visits a (valid!) tree node, returns either node itself or the result of calling tag as method for an array. Parameters: Name Type Argument Description node Array to visit, using the tag as a method name and the node as argument. trace RegExp &lt;optional&gt; sets .trace if specified. Inherited From: module:Eleven~Visit#visit Source: 11.js, line 211 × Search results Close "},"module-Eleven-Code_Bool.html":{"id":"module-Eleven-Code_Bool.html","title":"Mixin: Code_Bool","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Bool Eleven~ Code_Bool Methods to generate code for Boolean expressions; all return the next code address. Adds IfTrue, IfFalse, and Not to super.Instructions. Source: 11.js, line 1362 Members Instructions [Override] Add IfTrue, IfFalse, and Not. Source: 11.js, line 1366 Methods and() [ 'and' a b ] Source: 11.js, line 1399 bool() [ 'bool' value ] Source: 11.js, line 1417 not() [ 'not' b ] Source: 11.js, line 1412 or() [ 'or' a b ] Source: 11.js, line 1386 × Search results Close "},"module-Eleven-Code_Cast.html":{"id":"module-Eleven-Code_Cast.html","title":"Mixin: Code_Cast","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Cast Eleven~ Code_Cast Method to generate code for cast; returns the next code address. Adds Cast to Machine11. Source: 11.js, line 1509 Members Instructions [Override] Add Cast. Source: 11.js, line 1513 Methods cast() [ 'cast' type b ] Source: 11.js, line 1538 × Search results Close "},"module-Eleven-Code_Cmps.html":{"id":"module-Eleven-Code_Cmps.html","title":"Mixin: Code_Cmps","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Cmps Eleven~ Code_Cmps Methods to generate code for comparisons; all return the next code address. Uses Machine11. Requires Symbols for frame size and tracing. Source: 11.js, line 1219 Members Machine [Override] Use Six.Machine11. Source: 11.js, line 1223 executable [Override] The executable, checks for trace variable. Source: 11.js, line 1229 Methods eq() [ 'eq' a b ] Source: 11.js, line 1238 ge() [ 'ge' a b ] Source: 11.js, line 1253 gt() [ 'gt' a b ] Source: 11.js, line 1248 le() [ 'le' a b ] Source: 11.js, line 1263 lt() [ 'lt' a b ] Source: 11.js, line 1258 ne() [ 'ne' a b ] Source: 11.js, line 1243 × Search results Close "},"module-Eleven-Code_Dcl.html":{"id":"module-Eleven-Code_Dcl.html","title":"Mixin: Code_Dcl","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Dcl Eleven~ Code_Dcl Methods to generate code for block and dcl; all return the next code address. Requires Symbols. Source: 11.js, line 1549 Methods block() [ 'block' dcl ... stmt ... ] visits all. Source: 11.js, line 1553 dcl() [ 'dcl' type name ...] allocate, initializes bool and string. Source: 11.js, line 1560 × Search results Close "},"module-Eleven-Code_Names.html":{"id":"module-Eleven-Code_Names.html","title":"Mixin: Code_Names","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Names Eleven~ Code_Names Methods to generate code for names; all return the next code address. Requires Symbols. Source: 11.js, line 1271 Methods assign() [ 'assign' name value ] returns next code address. Source: 11.js, line 1283 name() [ 'name' name ] Source: 11.js, line 1276 × Search results Close "},"module-Eleven-Code_Number.html":{"id":"module-Eleven-Code_Number.html","title":"Mixin: Code_Number","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Number Eleven~ Code_Number Methods to generate code for arithmetic expressions; all return the next code address. Source: 11.js, line 1159 Methods add() [ 'add' a b ] Source: 11.js, line 1174 divide() [ 'divide' a b ] Source: 11.js, line 1189 minus() [ 'minus' a ] Source: 11.js, line 1199 multiply() [ 'multiply' a b ] Source: 11.js, line 1184 number() [ 'number' a ] Source: 11.js, line 1204 power() [ 'power' a b ] Source: 11.js, line 1194 subtract() [ 'subtract' a b ] Source: 11.js, line 1179 × Search results Close "},"module-Eleven-Code_Stmts.html":{"id":"module-Eleven-Code_Stmts.html","title":"Mixin: Code_Stmts","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_Stmts Eleven~ Code_Stmts Methods to generate code for statements; all return the next code address. Requires Code_Cmps. Adds Bnzero to super.Instructions. Source: 11.js, line 1296 Members Instructions [Override] Add Bnzero. Source: 11.js, line 1300 Methods loop() [ 'loop' cond stmt ] Source: 11.js, line 1329 print() [ 'print' value ... ] Source: 11.js, line 1321 select() [ 'select' cond then else? ] Source: 11.js, line 1340 stmts() [ 'stmts' stmt ... ] Source: 11.js, line 1314 × Search results Close "},"module-Eleven-Code_String.html":{"id":"module-Eleven-Code_String.html","title":"Mixin: Code_String","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Code_String Eleven~ Code_String Methods to generate code for string expressions; all return the next code address. Adds Concat, Len, and InputString to Machine11. Source: 11.js, line 1429 Members Instructions [Override] Add InputString, Concat, and Len. Source: 11.js, line 1459 Machine [Override] Show strings in memory. Source: 11.js, line 1438 Methods _escape() Convert raw to literal string. Only escapes single quote, newline, backslash; see module:Base~Tuple#escape. Source: 11.js, line 1433 concat() [ 'concat' a b ] Source: 11.js, line 1489 input() [ 'input' prompt? default? ] returns next code address. Source: 11.js, line 1481 len() [ 'len' b ] returns number. Source: 11.js, line 1493 string() [ 'string' value ] returns string. Source: 11.js, line 1498 × Search results Close "},"module-Eleven-Compile.html":{"id":"module-Eleven-Compile.html","title":"Mixin: Compile","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Compile Eleven~ Compile Class action for a top-level rule to visit a tree and return a stack machine; requires module:Eleven~Main and module:Eleven~Code as last visitor. Source: 11.js, line 1107 Methods compile() Create and apply all visitors, return executable. Source: 11.js, line 1112 Throws: error message, e.g., error count or _tree issue. Type string × Search results Close "},"module-Eleven-Eval_Bool.html":{"id":"module-Eleven-Eval_Bool.html","title":"Mixin: Eval_Bool","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Bool Eleven~ Eval_Bool Methods to interpret Boolean expressions. Source: 11.js, line 619 Methods and() [ 'and' a b ] returns Boolean. Source: 11.js, line 636 bool() [ 'bool' value ] returns Boolean. Source: 11.js, line 659 not() [ 'not' b ] returns Boolean. Source: 11.js, line 649 or() [ 'or' a b ] returns Boolean. Source: 11.js, line 623 × Search results Close "},"module-Eleven-Eval_Cast.html":{"id":"module-Eleven-Eval_Cast.html","title":"Mixin: Eval_Cast","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Cast Eleven~ Eval_Cast Method to interpret explicit typing. Source: 11.js, line 710 Methods cast() [ 'cast' type b ] returns type-cast value. Source: 11.js, line 714 × Search results Close "},"module-Eleven-Eval_Cmps.html":{"id":"module-Eleven-Eval_Cmps.html","title":"Mixin: Eval_Cmps","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Cmps Eleven~ Eval_Cmps Methods to interpret comparisons. All of these expect Number values and return a Boolean result. Source: 11.js, line 435 Methods eq() [ 'eq' a b ]; returns Boolean. Source: 11.js, line 439 ge() [ 'ge' a b ]; returns Boolean. Source: 11.js, line 454 gt() [ 'gt' a b ]; returns Boolean. Source: 11.js, line 449 le() [ 'le' a b ]; returns Boolean. Source: 11.js, line 464 lt() [ 'lt' a b ]; returns Boolean. Source: 11.js, line 459 ne() [ 'ne' a b ]; returns Boolean. Source: 11.js, line 444 × Search results Close "},"module-Eleven-Eval_Dcl.html":{"id":"module-Eleven-Eval_Dcl.html","title":"Mixin: Eval_Dcl","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Dcl Eleven~ Eval_Dcl Methods to interpret a block with declarations and other items; requires Symbols. Source: 11.js, line 1078 Methods block() [ 'block' dcl ... other ... ] visits all. Source: 11.js, line 1082 dcl() [ 'dcl' type name ...] defines as false, 0, or empty strings. Source: 11.js, line 1087 × Search results Close "},"module-Eleven-Eval_Names.html":{"id":"module-Eleven-Eval_Names.html","title":"Mixin: Eval_Names","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Names Eleven~ Eval_Names Method to interpret names, requires Symbols. Source: 11.js, line 530 Methods assign() [ 'assign' name value ] Source: 11.js, line 543 name() [ 'name' name ] returns the stored value. Source: 11.js, line 534 × Search results Close "},"module-Eleven-Eval_Number.html":{"id":"module-Eleven-Eval_Number.html","title":"Mixin: Eval_Number","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Number Eleven~ Eval_Number Methods to evaluate arithmetic expressions. All of these expect Number values and return a Number result. Source: 11.js, line 231 Methods add() [ 'add' a b ]; returns Number Source: 11.js, line 235 divide() [ 'divide' a b ]; returns Number Source: 11.js, line 250 minus() [ 'minus' a ]; returns Number Source: 11.js, line 260 multiply() [ 'multiply' a b ]; returns Number Source: 11.js, line 245 number() [ 'number' a ]; returns Number Source: 11.js, line 265 power() [ 'power' a b ]; returns Number Source: 11.js, line 255 subtract() [ 'subtract' a b ]; returns Number Source: 11.js, line 240 × Search results Close "},"module-Eleven-Eval_Stmts.html":{"id":"module-Eleven-Eval_Stmts.html","title":"Mixin: Eval_Stmts","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_Stmts Eleven~ Eval_Stmts Methods to interpret a list of statements. Source: 11.js, line 470 Methods loop() [ 'loop' cond stmt ] Source: 11.js, line 485 print() [ 'print' value ... ] Source: 11.js, line 480 select() [ 'select' cond then else? ] Source: 11.js, line 490 stmts() [ 'stmts' stmt ... ] Source: 11.js, line 475 × Search results Close "},"module-Eleven-Eval_String.html":{"id":"module-Eleven-Eval_String.html","title":"Mixin: Eval_String","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Eval_String Eleven~ Eval_String Methods to interpret string expressions. Source: 11.js, line 669 Methods concat() [ 'concat' a b ] returns String. Source: 11.js, line 673 input() [ 'input' prompt? default? ] returns String. Source: 11.js, line 683 len() [ 'len' b ] returns Number. Source: 11.js, line 690 string() [ 'string' value ] returns String. Source: 11.js, line 700 × Search results Close "},"module-Eleven-Main.html":{"id":"module-Eleven-Main.html","title":"Mixin: Main","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Main Eleven~ Main Class actions for top-level rules to display and visit a tree. For the main rule: Add optional arguments with visitor classes. Add an optional RegExp argument to display the tree between visits and trace each visit. Source: 11.js, line 274 Methods _doVisits() Create and apply all but the last visitor, check the last. Source: 11.js, line 280 Throws: error message, e.g., error count or _tree issue. Type string Returns: checked last visitor, last tree, trace if any. Type Array dump() dump: tree; Display and return the tree. Source: 11.js, line 315 main() main: tree; return the checked last visit as a function. Source: 11.js, line 307 Throws: error message, e.g., error count or _tree issue. Type string run() run: funct; Execute the function and return the result. Source: 11.js, line 323 × Search results Close "},"module-Eleven-Symbols.html":{"id":"module-Eleven-Symbols.html","title":"Mixin: Symbols","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Symbols Eleven~ Symbols Mixin with a symbol table. Private method names start with an underscore. Properties: Name Type Description symbols Map symbol table, maps names to descriptions; imported from previous visitor, if any. Source: 11.js, line 502 Members constructor Creates the Map for symbol descriptions or gets it from the previous processor. Source: 11.js, line 503 Methods _alloc(name) Returns a name's description, if necessary creates it. Parameters: Name Type Description name string to allocate. Source: 11.js, line 518 Returns: description which indicates creation order, starting at 1. Type ord:number × Search results Close "},"module-Eleven-Visit.html":{"id":"module-Eleven-Visit.html","title":"Class: Visit","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Visit Eleven~ Visit Base class with methods to validate and visit a tree. Private method names start with an underscore. new Visit() Properties: Name Type Description trace RegExp selects matching tags to trace visits. errors number count of calls to _error(). Source: 11.js, line 165 Methods _dump(node [, shallow]) Creates a deep display of a node. Parameters: Name Type Argument Description node Array to recursively traverse. shallow number &lt;optional&gt; limits depth if non-negative, by default unlimited. Source: 11.js, line 192 _error() Displays and counts an error message. Source: 11.js, line 170 _tree(node) Recursively checks tree tags, throws an error if there is a problem. Parameters: Name Type Description node Array to validate. Source: 11.js, line 178 visit(node [, trace]) Visits a (valid!) tree node, returns either node itself or the result of calling tag as method for an array. Parameters: Name Type Argument Description node Array to visit, using the tag as a method name and the node as argument. trace RegExp &lt;optional&gt; sets .trace if specified. Source: 11.js, line 211 × Search results Close "},"module-Five.html":{"id":"module-Five.html","title":"Module: Five","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Five This module contains the classes for the last three examples in chapter five. Version: 2024-02-06 Author: © 2023 Axel T. Schreiner Source: 05.js, line 1 Classes Actions14 Actions15 Actions16 × Search results Close "},"module-Five-Actions14.html":{"id":"module-Five-Actions14.html","title":"Class: Actions14","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions14 Five~ Actions14 Example 5/14: actions to process a list of semicolon-terminated items. new Actions14() Source: 05.js, line 9 Methods dec() dec: 'dec' Decimal ';'; returns value Source: 05.js, line 11 hex() hex: 'hex' ref ';'; returns value Source: 05.js, line 14 list() item: dec | hex; returns [ value ] list: { item ';' }; displays value ... Source: 05.js, line 18 × Search results Close "},"module-Five-Actions15.html":{"id":"module-Five-Actions15.html","title":"Class: Actions15","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions15 Five~ Actions15 Example 5/15: action to display a list of comma-separated items. new Actions15() Source: 05.js, line 23 Extends module:Five~Actions14 Methods dec() dec: 'dec' Decimal ';'; returns value Inherited From: module:Five~Actions14#dec Source: 05.js, line 11 hex() hex: 'hex' ref ';'; returns value Inherited From: module:Five~Actions14#hex Source: 05.js, line 14 list() item: dec | hex; returns [ value ] list: { item ';' }; returns [ value ... ] Overrides: module:Five~Actions14#list Source: 05.js, line 26 × Search results Close "},"module-Five-Actions16.html":{"id":"module-Five-Actions16.html","title":"Class: Actions16","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions16 Five~ Actions16 Example 5/16: action to process a list of comma-separated items. new Actions16() Source: 05.js, line 39 Extends module:Five~Actions14 Methods dec() dec: 'dec' Decimal ';'; returns value Inherited From: module:Five~Actions14#dec Source: 05.js, line 11 hex() hex: 'hex' ref ';'; returns value Inherited From: module:Five~Actions14#hex Source: 05.js, line 14 list() item: dec | hex; returns [ value ] list: [{ ',' item }]; returns value +... Overrides: module:Five~Actions14#list Source: 05.js, line 48 × Search results Close "},"module-GUI.html":{"id":"module-GUI.html","title":"Module: GUI","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: GUI This module implements the document ready event handler for jQuery to control the practice page model, i.e., to edit and run examples. Version: 2024-02-13 Author: © 2023 Axel T. Schreiner Source: index.js, line 1 Methods &lt;inner&gt; browse() The document ready event handler. Source: index.js, line 15 × Search results Close "},"module-Practice.html":{"id":"module-Practice.html","title":"Module: Practice","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Practice This module implements the model for the practice page which is shared by batch and graphical user interface scripting. Version: 2024-6-20 Author: © 2023 Axel T. Schreiner Source: practice.js, line 1 Classes Model × Search results Close "},"module-Practice-Model.html":{"id":"module-Practice-Model.html","title":"Class: Model","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Model Practice~ Model Model of the practice page. The following global variables and global modules will exist once the model has been constructed. Pre-existing global variables newOutput, prompt, and puts will not be overwritten. name type content actions string Defines the class and action methods to be called by a parser. g Grammar Represents grammar. grammar string Rules of a grammar, argument for the construction of g. newOutput function Displays it's arguments, blank-separated and marked as a new section. program string Should be a sentence conforming to grammar, argument for recognition. prompt function Displays a prompt string, returns input or a default string, else error. puts function Displays it's arguments, blank-separated. run function null or an executable compiled from program by the actions.A stack machine has two arguments, other executables have none. tokens string Defines an object with pattern properties defining the tokens used in grammar. module purpose Base Base classes shared by the parser generators EBNF LL(1) parser generator BNF SLR(1) parser generator Six Classes for the examples in chapter six Seven Classes for the examples in chapter seven Eight Classes for the examples in chapter eight Ten Classes for the examples in chapter ten Eleven Classes for the examples in chapter eleven new Model(global) Create a model. Parameters: Name Type Description global object either windows or globalThis. Properties: Name Type Argument Description grammar string global grammar; setter clears global g and global run. tokens string global tokens; setter clears global g and global run. skip RegExp set by doNew from an empty key in tokens; overwrites default for scanner and parser. actions string global actions; setter clears global run. program string global program; setter clears global run. mode string ebnf|stack|bnf; setter clears global g and global run. greedy boolean use expect() rather than check(). error boolean insert $error when translating EBNF. tShallow boolean trace algorithm and display sets. tDeep boolean trace algorithm and display sets. tFollow boolean trace algorithm and display sets. dSets boolean display sets. dStates boolean display states. tLookahead boolean trace lookahead during parse. tParser boolean trace parse. tActions boolean trace actions. tNoargs boolean do not check argument count for actions. build boolean build lists. memory Array &lt;nullable&gt; for stepping a stack machine. Source: practice.js, line 77 Examples // Use in scripting in a Windows environment new Model(windows); // Use in scripting in a node.js environment new Model(globalThis); Methods doNew() Event: eval?.(tokens), if any, and represent and check the grammar; modifies g, clears run, and removes memory. Source: practice.js, line 185 doParse() Event: eval?.(this.actions), if any, create a parser, and parse the program; modifies run and removes memory. Source: practice.js, line 286 doRun() Event: run the executable, if any. Source: practice.js, line 347 doScan() Event: create a scanner and apply it to this.program. Source: practice.js, line 273 doStep(n) Event: step the stack machine, if any. Parameters: Name Type Description n number number of steps to execute. Source: practice.js, line 361 × Search results Close "},"module-Script.html":{"id":"module-Script.html","title":"Module: Script","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Script This module implements a server function for node.js to script the practice page model, i.e., to run the examples from the command line. Version: 2024-02-13 Author: © 2023 Axel T. Schreiner Source: script.js, line 1 Methods &lt;async, inner&gt; script() The server function. Blank-separated words, read from standard input, have the effects described below. Any other word is interpreted as a path from which an example is merged into the global strings. word effect model resets all flags and variables. load resets global strings. ebnf, stack, bnf clear all flags and set a mode. actions, build, deep, error, follow, greedy,noargs, lookahead, parser, sets, shallow, states toggle flags. new calls model.doNew(). scan calls model.doScan(). parse calls model.doParse(). run calls model.doRun(). 1 calls model.doStep(1). 10 calls model.doStep(10). 100 calls model.doStep(100). exit terminates the script Source: script.js, line 40 Example Load an example, compile and run with each parser, overwrite parts, and repeat. $ node script.js &lt;&lt; 'end' model eg/06/06.eg new parse run stack new parse run ebnf test/06-06a.eg new parse run stack new parse run end × Search results Close "},"module-Seven.html":{"id":"module-Seven.html","title":"Module: Seven","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Seven This module contains the classes for all examples in chapter seven. Version: 2024-04-05 Author: © 2024 Axel T. Schreiner Source: 07.js, line 1 Classes Blocks09 Functions04 Machine04 Machine06 Machine13 Parameters06 TCheck01 TCheck02 Mixins Nest13 × Search results Close "},"module-Seven-Blocks09.html":{"id":"module-Seven-Blocks09.html","title":"Class: Blocks09","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Blocks09 Seven~ Blocks09 Example 7/09: compile global functions with block structure. new Blocks09() Source: 07.js, line 906 Extends module:Seven~Parameters06 Classes Block Fun Symbol Var Members context Manages a stack of contexts for assign or call to a name Inherited From: module:Seven~Parameters06#context Source: 07.js, line 764 funct Describes current function Inherited From: module:Seven~Functions04#funct Source: 07.js, line 334 size Manages next (global) variable address Inherited From: module:Seven~Functions04#size Source: 07.js, line 329 Methods Do() Do: 'do'; Overrides: module:Seven~Parameters06#Do Source: 07.js, line 1033 Else() Else: 'else'; Overrides: module:Seven~Parameters06#Else Source: 07.js, line 1051 Then() Then: 'then'; Overrides: module:Seven~Parameters06#Then Source: 07.js, line 1048 While() While: 'while'; returns address for branch to while Inherited From: module:Six~Control11#While Source: 06.js, line 603 _alloc() Replace: returns new Var at next local/global address. Inherited From: module:Seven~Parameters06#_alloc Source: 07.js, line 779 _check_defs() Flags undefined functions, returns main if defined Inherited From: module:Seven~Functions04#_check_defs Source: 07.js, line 466 _dcl() Replace: sets innermost map, returns sym Inherited From: module:Seven~Parameters06#_dcl Source: 07.js, line 795 _find() Replace: searches innermost to outermost blocks and global Overrides: module:Seven~Parameters06#_find Source: 07.js, line 982 _startup(main) [Extend] Push 0 for main parameters. Parameters: Name Type Description main Fun describes main(). Inherited From: module:Seven~Parameters06#_startup Source: 07.js, line 806 add() add: '+' product; Inherited From: module:Six~Arithmetic10#add Source: 06.js, line 444 args() args: '(' [ sums ] ')'; expects context, codes call Inherited From: module:Seven~Parameters06#args Source: 07.js, line 845 assign() assign: symbol action; codes Pop, pops context Inherited From: module:Seven~Parameters06#assign Source: 07.js, line 830 begin() begin: 'begin'; Source: 07.js, line 1012 block() block: begin [ vars ] stmts 'end'; Source: 07.js, line 1009 divide() divide: '/' signed; Inherited From: module:Six~Arithmetic10#divide Source: 06.js, line 455 else() else: Else [ vars ] stmts; Source: 07.js, line 1045 eq() eq: '=' sum; Inherited From: module:Six~Control11#eq Source: 06.js, line 629 fun() fun: head parms [ block ] ';'; Inherited From: module:Seven~Parameters06#fun Source: 07.js, line 818 ge() ge: '&gt;=' sum; Inherited From: module:Six~Control11#ge Source: 06.js, line 635 gt() gt: '&gt;' sum; Inherited From: module:Six~Control11#gt Source: 06.js, line 633 head() head: 'function' Name; returns function symbol Inherited From: module:Seven~Functions04#head Source: 07.js, line 523 input() input: 'input' [ Number ]; Inherited From: module:Six~Arithmetic10#input Source: 06.js, line 463 le() le: '&lt;=' sum; Inherited From: module:Six~Control11#le Source: 06.js, line 639 loop() loop: While cmp Do [ vars ] stmts 'od'; Overrides: module:Seven~Parameters06#loop Source: 07.js, line 1026 lt() lt: '&lt;' sum; Inherited From: module:Six~Control11#lt Source: 06.js, line 637 multiply() multiply: '*' signed; Inherited From: module:Six~Arithmetic10#multiply Source: 06.js, line 452 name() name: symbol [ args ]; codes variable load, pops context Inherited From: module:Seven~Parameters06#name Source: 07.js, line 886 names() names: Name [{ ',' Name }]; defines new variables, returns number of names Inherited From: module:Seven~Functions04#names Source: 07.js, line 506 ne() ne: '&lt;&gt;' sum; Inherited From: module:Six~Control11#ne Source: 06.js, line 631 number() number: Number; Inherited From: module:Six~Arithmetic10#number Source: 06.js, line 468 parms() parms: '(' [ names ] ')'; Inherited From: module:Seven~Parameters06#parms Source: 07.js, line 823 print() print: 'print' sums; Inherited From: module:Six~Control11#print Source: 06.js, line 591 prog() prog: [ vars ] funs; returns executable Inherited From: module:Seven~Functions04#prog Source: 07.js, line 486 return() return: 'return' [ sum ]; Inherited From: module:Seven~Functions04#return Source: 07.js, line 558 run() Creates stack machine Inherited From: module:Six~Machine09#run Source: 06.js, line 255 select() select: 'if' cmp then [ else ] 'fi'; Overrides: module:Seven~Parameters06#select Source: 07.js, line 1036 signed() signed: [ '-' ] term; Inherited From: module:Six~Arithmetic10#signed Source: 06.js, line 458 stmt() stmt: assign | print | loop | select; [replace] no op Inherited From: module:Six~Control11#stmt Source: 06.js, line 582 store() store: '=' sum; expects context, codes assignment Inherited From: module:Seven~Parameters06#store Source: 07.js, line 837 subtract() subtract: '-' product; Inherited From: module:Six~Arithmetic10#subtract Source: 06.js, line 447 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Inherited From: module:Six~Arithmetic10#sum Source: 06.js, line 438 sums() sums: sum [{ ',' sum }]; returns number of values Inherited From: module:Six~Control11#sums Source: 06.js, line 594 symbol() symbol: Name; pushes context, returns symbol Inherited From: module:Seven~Parameters06#symbol Source: 07.js, line 896 then() then: Then [ [ vars ] stmts ]; Source: 07.js, line 1042 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 × Search results Close "},"module-Seven-Blocks09_Block.html":{"id":"module-Seven-Blocks09_Block.html","title":"Class: Block","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Block Seven~Blocks09# Block new Block() Describes a block of nested symbols. Properties: Name Type Description locals Map maps names to descriptions. size number next variable address in block. toString() function describes as text. Source: 07.js, line 966 × Search results Close "},"module-Seven-Blocks09_Fun.html":{"id":"module-Seven-Blocks09_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Seven~Blocks09# Fun @extends super.Fun new Fun() Describes a function with block structure. Properties: Name Type Description blocks Array.&lt;Block&gt; block stack, [0] is innermost frameSize number must replace size locals Map [replace] delegate to blocks size number [replace] delegate to blocks push() function add a block pop() function end a block, maintain size end() function [extend] pop last block exit() function [replace] use frameSize Overrides: module:Seven~Parameters06#Fun Source: 07.js, line 917 × Search results Close "},"module-Seven-Blocks09_Symbol.html":{"id":"module-Seven-Blocks09_Symbol.html","title":"Class: Symbol","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Symbol Seven~Blocks09# Symbol new Symbol() (Inner) base class for symbol descriptions. Properties: Name Type Description owner module:Seven~Functions04 outer class. name string variable or function name. Inherited From: module:Seven~Functions04#Symbol Source: 07.js, line 342 × Search results Close "},"module-Seven-Blocks09_Var.html":{"id":"module-Seven-Blocks09_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Seven~Blocks09# Var @extends super.Var new Var() Describes a global or local variable. Properties: Name Type Description depth number 0: global, 1: local. load() function [replace] global/local. store() function [replace] global/local. Inherited From: module:Seven~Parameters06#Var Source: 07.js, line 680 × Search results Close "},"module-Seven-Functions04.html":{"id":"module-Seven-Functions04.html","title":"Class: Functions04","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Functions04 Seven~ Functions04 Example 7/04: compile parameter-less functions into stack machine code. new Functions04() Source: 07.js, line 327 Extends module:Six~Control11 Classes Fun Symbol Var Members funct Describes current function Source: 07.js, line 334 size Manages next (global) variable address Source: 07.js, line 329 Methods Do() Do: 'do'; returns address of slot for bzero to od Inherited From: module:Six~Control11#Do Overrides: module:Six~Control11#Do Source: 06.js, line 606 Else() Else: 'else'; creates slot for branch to fi, returns address of else Inherited From: module:Six~Control11#Else Overrides: module:Six~Control11#Else Source: 06.js, line 624 Then() Then: 'then'; returns address for bzero to else fi Inherited From: module:Six~Control11#Then Overrides: module:Six~Control11#Then Source: 06.js, line 620 While() While: 'while'; returns address for branch to while Inherited From: module:Six~Control11#While Overrides: module:Six~Control11#While Source: 06.js, line 603 _alloc() Returns new Var at next global address. Source: 07.js, line 463 _check_defs() Flags undefined functions, returns main if defined Source: 07.js, line 466 _dcl() (Re-)defines and returns sym, cannot be undefined Source: 07.js, line 455 _find() Returns symbol description for name, if any Source: 07.js, line 448 _startup(main) Generates Call to main.start and Print result Parameters: Name Type Description main Fun describes main(). Source: 07.js, line 480 add() add: '+' product; Inherited From: module:Six~Arithmetic10#add Overrides: module:Six~Control11#add Source: 06.js, line 444 assign() assign: Name [ '=' sum ]; Overrides: module:Six~Control11#assign Source: 07.js, line 542 divide() divide: '/' signed; Inherited From: module:Six~Arithmetic10#divide Overrides: module:Six~Control11#divide Source: 06.js, line 455 eq() eq: '=' sum; Inherited From: module:Six~Control11#eq Overrides: module:Six~Control11#eq Source: 06.js, line 629 fun() fun: head [ 'begin' stmts 'end' ] ';'; Source: 07.js, line 516 ge() ge: '&gt;=' sum; Inherited From: module:Six~Control11#ge Overrides: module:Six~Control11#ge Source: 06.js, line 635 gt() gt: '&gt;' sum; Inherited From: module:Six~Control11#gt Overrides: module:Six~Control11#gt Source: 06.js, line 633 head() head: 'function' Name; returns function symbol Source: 07.js, line 523 input() input: 'input' [ Number ]; Inherited From: module:Six~Arithmetic10#input Overrides: module:Six~Control11#input Source: 06.js, line 463 le() le: '&lt;=' sum; Inherited From: module:Six~Control11#le Overrides: module:Six~Control11#le Source: 06.js, line 639 loop() loop: While cmp Do stmts 'od'; Inherited From: module:Six~Control11#loop Overrides: module:Six~Control11#loop Source: 06.js, line 597 lt() lt: '&lt;' sum; Inherited From: module:Six~Control11#lt Overrides: module:Six~Control11#lt Source: 06.js, line 637 multiply() multiply: '*' signed; Inherited From: module:Six~Arithmetic10#multiply Overrides: module:Six~Control11#multiply Source: 06.js, line 452 name() name: Name; Overrides: module:Six~Control11#name Source: 07.js, line 590 names() names: Name [{ ',' Name }]; defines new variables, returns number of names Source: 07.js, line 506 ne() ne: '&lt;&gt;' sum; Inherited From: module:Six~Control11#ne Overrides: module:Six~Control11#ne Source: 06.js, line 631 number() number: Number; Inherited From: module:Six~Arithmetic10#number Overrides: module:Six~Control11#number Source: 06.js, line 468 print() print: 'print' sums; Inherited From: module:Six~Control11#print Overrides: module:Six~Control11#print Source: 06.js, line 591 prog() prog: [ vars ] funs; returns executable Overrides: module:Six~Control11#prog Source: 07.js, line 486 return() return: 'return' [ sum ]; Source: 07.js, line 558 run() Creates stack machine Inherited From: module:Six~Machine09#run Overrides: module:Six~Control11#run Source: 06.js, line 255 select() select: 'if' cmp Then stmts [ Else stmts ] 'fi'; Inherited From: module:Six~Control11#select Overrides: module:Six~Control11#select Source: 06.js, line 609 signed() signed: [ '-' ] term; Inherited From: module:Six~Arithmetic10#signed Overrides: module:Six~Control11#signed Source: 06.js, line 458 stmt() stmt: assign | print | loop | select; [replace] no op Inherited From: module:Six~Control11#stmt Overrides: module:Six~Control11#stmt Source: 06.js, line 582 subtract() subtract: '-' product; Inherited From: module:Six~Arithmetic10#subtract Overrides: module:Six~Control11#subtract Source: 06.js, line 447 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Inherited From: module:Six~Arithmetic10#sum Overrides: module:Six~Control11#sum Source: 06.js, line 438 sums() sums: sum [{ ',' sum }]; returns number of values Inherited From: module:Six~Control11#sums Overrides: module:Six~Control11#sums Source: 06.js, line 594 toString() Represents code as text Inherited From: module:Six~Machine09#toString Overrides: module:Six~Control11#toString Source: 06.js, line 250 × Search results Close "},"module-Seven-Functions04_Fun.html":{"id":"module-Seven-Functions04_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Seven~Functions04# Fun @extends Symbol new Fun() Describes a function. Properties: Name Type Description start boolean | number code address. calls Array.&lt;number&gt; slots to insert Call. returns Array.&lt;number&gt; slots to insert branch to exit. entry() function generates preamble code. undo() function undoes entry(). call() function generates Call instruction. return() function generates branch to exit. storeOk() function true if allowed to store. store() function generates store instruction. end() function fixes calls/returns, exit(). exit() function generates postamble code. toString() function represents as text. Source: 07.js, line 392 × Search results Close "},"module-Seven-Functions04_Symbol.html":{"id":"module-Seven-Functions04_Symbol.html","title":"Class: Symbol","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Symbol Seven~Functions04# Symbol new Symbol() (Inner) base class for symbol descriptions. Properties: Name Type Description owner module:Seven~Functions04 outer class. name string variable or function name. Source: 07.js, line 342 × Search results Close "},"module-Seven-Functions04_Var.html":{"id":"module-Seven-Functions04_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Seven~Functions04# Var @extends Symbol new Var() Describes a variable. Properties: Name Type Description addr number memory address. load() function generates load instruction. storeOk() function always true. store() function generates store instruction. toString() function represents as text. Source: 07.js, line 360 × Search results Close "},"module-Seven-Machine04.html":{"id":"module-Seven-Machine04.html","title":"Class: Machine04","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine04 Seven~ Machine04 Example 7/04: function calls. new Machine04() Source: 07.js, line 306 Extends module:Six~Machine11 Classes Memory Methods Add() stack: ... a b -&gt; ... a+b Inherited From: module:Six~Machine10#Add Source: 06.js, line 385 Branch() stack: ... -&gt; ... | pc: a Inherited From: module:Six~Machine11#Branch Source: 06.js, line 529 Bzero() stack: ... bool -&gt; ... | pc: !bool? a Inherited From: module:Six~Machine11#Bzero Source: 06.js, line 532 Call() stack: ... -&gt; ... old-pc | pc: addr Source: 07.js, line 308 Divide() stack: ... a b -&gt; ... a/b Inherited From: module:Six~Machine10#Divide Source: 06.js, line 388 Entry() stack: ... old-pc -&gt; ,,, 0 old-pc Source: 07.js, line 312 Eq() stack: ... a b -&gt; ... a == b Inherited From: module:Six~Machine11#Eq Source: 06.js, line 535 Ge() stack: ... a b -&gt; ... a &gt;= b Inherited From: module:Six~Machine11#Ge Source: 06.js, line 538 Gt() stack: ... a b -&gt; ... a &gt; b Inherited From: module:Six~Machine11#Gt Source: 06.js, line 541 Input() stack: ... -&gt; ... input Inherited From: module:Six~Machine10#Input Source: 06.js, line 391 Le() stack: ... a b -&gt; ... a &lt;= b Inherited From: module:Six~Machine11#Le Source: 06.js, line 544 Load() stack: ... -&gt; ... memory[addr] Inherited From: module:Six~Machine10#Load Source: 06.js, line 396 Lt() stack: ... a b -&gt; ... a &lt; b Inherited From: module:Six~Machine11#Lt Source: 06.js, line 547 Minus() stack: ... a -&gt; ... -a Inherited From: module:Six~Machine10#Minus Source: 06.js, line 399 Multiply() stack: ... a b -&gt; ... a*b Inherited From: module:Six~Machine10#Multiply Source: 06.js, line 402 Ne() stack: ... a b -&gt; ... a != b Inherited From: module:Six~Machine11#Ne Source: 06.js, line 550 Pop() stack: ... val -&gt; ... Inherited From: module:Six~Machine10#Pop Source: 06.js, line 405 Print() stack: ... n*val -&gt; ... Inherited From: module:Six~Machine11#Print Source: 06.js, line 553 Push() stack: ... -&gt; ... result Inherited From: module:Six~Machine10#Push Source: 06.js, line 408 Puts() stack: ... val -&gt; ... | puts(val) Inherited From: module:Six~Machine10#Puts Source: 06.js, line 411 Return() stack: ... old-pc -&gt; ... | pc: old-pc Source: 07.js, line 316 ReturnValue() stack: ... x old-pc result -&gt; ... result old-pc result Source: 07.js, line 320 Store() stack: ... val -&gt; ... val | memory[a]: val Inherited From: module:Six~Machine10#Store Source: 06.js, line 414 Subtract() stack: ... a b -&gt; ... a-b Inherited From: module:Six~Machine10#Subtract Source: 06.js, line 417 gen() returns code.length Inherited From: module:Six~Machine10#gen Source: 06.js, line 374 ins() returns instruction function Inherited From: module:Six~Machine10#ins Source: 06.js, line 379 run() Returns stack machine executable Inherited From: module:Six~Machine11#run Source: 06.js, line 506 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 trace() Returns trace function, if any Inherited From: module:Six~Machine11#trace Source: 06.js, line 483 × Search results Close "},"module-Seven-Machine04_Memory.html":{"id":"module-Seven-Machine04_Memory.html","title":"Class: Memory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Memory Seven~Machine04# Memory extends Array new Memory() Data memory. Properties: Name Type Description pc number program counter. continue boolean true if execution can be continued. toString() function represents as text. Inherited From: module:Six~Machine11#Memory Source: 06.js, line 499 × Search results Close "},"module-Seven-Machine06.html":{"id":"module-Seven-Machine06.html","title":"Class: Machine06","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine06 Seven~ Machine06 Example 7/06: parameters and local variables. new Machine06() Source: 07.js, line 599 Extends module:Seven~Machine04 Classes Memory Methods Add() stack: ... a b -&gt; ... a+b Inherited From: module:Six~Machine10#Add Source: 06.js, line 385 Branch() stack: ... -&gt; ... | pc: a Inherited From: module:Six~Machine11#Branch Source: 06.js, line 529 Bzero() stack: ... bool -&gt; ... | pc: !bool? a Inherited From: module:Six~Machine11#Bzero Source: 06.js, line 532 Call() stack: ... -&gt; ... old-pc | pc: addr Inherited From: module:Seven~Machine04#Call Source: 07.js, line 308 Divide() stack: ... a b -&gt; ... a/b Inherited From: module:Six~Machine10#Divide Source: 06.js, line 388 Entry() stack: ... arguments old-pc -&gt; ... arguments old-pc old-fp result locals Overrides: module:Seven~Machine04#Entry Source: 07.js, line 637 Eq() stack: ... a b -&gt; ... a == b Inherited From: module:Six~Machine11#Eq Source: 06.js, line 535 Exit() stack: ... arguments old-pc old-fp result locals -&gt; ... result old-pc Source: 07.js, line 651 Ge() stack: ... a b -&gt; ... a &gt;= b Inherited From: module:Six~Machine11#Ge Source: 06.js, line 538 Gt() stack: ... a b -&gt; ... a &gt; b Inherited From: module:Six~Machine11#Gt Source: 06.js, line 541 Input() stack: ... -&gt; ... input Inherited From: module:Six~Machine10#Input Source: 06.js, line 391 Le() stack: ... a b -&gt; ... a &lt;= b Inherited From: module:Six~Machine11#Le Source: 06.js, line 544 Load() stack: ... -&gt; ... memory[addr] Inherited From: module:Six~Machine10#Load Source: 06.js, line 396 LoadFP() stack: ... -&gt; ... frame[addr] Source: 07.js, line 662 Lt() stack: ... a b -&gt; ... a &lt; b Inherited From: module:Six~Machine11#Lt Source: 06.js, line 547 Minus() stack: ... a -&gt; ... -a Inherited From: module:Six~Machine10#Minus Source: 06.js, line 399 Multiply() stack: ... a b -&gt; ... a*b Inherited From: module:Six~Machine10#Multiply Source: 06.js, line 402 Ne() stack: ... a b -&gt; ... a != b Inherited From: module:Six~Machine11#Ne Source: 06.js, line 550 Pop() stack: ... val -&gt; ... Inherited From: module:Six~Machine10#Pop Source: 06.js, line 405 Print() stack: ... n*val -&gt; ... Inherited From: module:Six~Machine11#Print Source: 06.js, line 553 Push() stack: ... -&gt; ... result Inherited From: module:Six~Machine10#Push Source: 06.js, line 408 Puts() stack: ... val -&gt; ... | puts(val) Inherited From: module:Six~Machine10#Puts Source: 06.js, line 411 Return() stack: ... old-pc -&gt; ... | pc: old-pc Inherited From: module:Seven~Machine04#Return Source: 07.js, line 316 ReturnValue() stack: ... x old-pc result -&gt; ... result old-pc result Inherited From: module:Seven~Machine04#ReturnValue Source: 07.js, line 320 Store() stack: ... val -&gt; ... val | memory[a]: val Inherited From: module:Six~Machine10#Store Source: 06.js, line 414 StoreFP() stack: ... val -&gt; ... val | frame[addr]: val Source: 07.js, line 667 Subtract() stack: ... a b -&gt; ... a-b Inherited From: module:Six~Machine10#Subtract Source: 06.js, line 417 gen() returns code.length Inherited From: module:Six~Machine10#gen Source: 06.js, line 374 ins() returns instruction function Inherited From: module:Six~Machine10#ins Source: 06.js, line 379 run() Returns stack machine executable Inherited From: module:Six~Machine11#run Source: 06.js, line 506 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 trace() Returns trace function, if any Inherited From: module:Six~Machine11#trace Source: 06.js, line 483 × Search results Close "},"module-Seven-Machine06_Memory.html":{"id":"module-Seven-Machine06_Memory.html","title":"Class: Memory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Memory Seven~Machine06# Memory @extends super.Memory new Memory() Data memory for frames. Properties: Name Type Description fp number frame pointer. frames Array.&lt;number&gt; list of number of parameters, in reverse order of dynamic link. mapSlot() function shows one slot toString() function [replace] shows frames. Overrides: module:Seven~Machine04#Memory Source: 07.js, line 607 × Search results Close "},"module-Seven-Machine13.html":{"id":"module-Seven-Machine13.html","title":"Class: Machine13","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine13 Seven~ Machine13 Example 7/13: nested functions new Machine13() Source: 07.js, line 1077 Extends module:Seven~Machine06 Classes Memory Methods Add() stack: ... a b -&gt; ... a+b Inherited From: module:Six~Machine10#Add Source: 06.js, line 385 Branch() stack: ... -&gt; ... | pc: a Inherited From: module:Six~Machine11#Branch Source: 06.js, line 529 Bzero() stack: ... bool -&gt; ... | pc: !bool? a Inherited From: module:Six~Machine11#Bzero Source: 06.js, line 532 Call() stack: ... -&gt; ... old-pc | pc: addr Inherited From: module:Seven~Machine04#Call Source: 07.js, line 308 Divide() stack: ... a b -&gt; ... a/b Inherited From: module:Six~Machine10#Divide Source: 06.js, line 388 Entry() stack: ... arguments old-pc -&gt; ... arguments old-pc old-fp old-dp result display locals Overrides: module:Seven~Machine06#Entry Source: 07.js, line 1109 Eq() stack: ... a b -&gt; ... a == b Inherited From: module:Six~Machine11#Eq Source: 06.js, line 535 Exit() stack: ... arguments old-pc old-fp old-dp result display locals -&gt; ... result old-pc Overrides: module:Seven~Machine06#Exit Source: 07.js, line 1128 Ge() stack: ... a b -&gt; ... a &gt;= b Inherited From: module:Six~Machine11#Ge Source: 06.js, line 538 Gt() stack: ... a b -&gt; ... a &gt; b Inherited From: module:Six~Machine11#Gt Source: 06.js, line 541 Input() stack: ... -&gt; ... input Inherited From: module:Six~Machine10#Input Source: 06.js, line 391 Le() stack: ... a b -&gt; ... a &lt;= b Inherited From: module:Six~Machine11#Le Source: 06.js, line 544 Load() stack: ... -&gt; ... memory[addr] Inherited From: module:Six~Machine10#Load Source: 06.js, line 396 LoadDP() stack: ... -&gt; ... frame[depth][addr] Source: 07.js, line 1139 LoadFP() stack: ... -&gt; ... frame[addr] Inherited From: module:Seven~Machine06#LoadFP Source: 07.js, line 662 Lt() stack: ... a b -&gt; ... a &lt; b Inherited From: module:Six~Machine11#Lt Source: 06.js, line 547 Minus() stack: ... a -&gt; ... -a Inherited From: module:Six~Machine10#Minus Source: 06.js, line 399 Multiply() stack: ... a b -&gt; ... a*b Inherited From: module:Six~Machine10#Multiply Source: 06.js, line 402 Ne() stack: ... a b -&gt; ... a != b Inherited From: module:Six~Machine11#Ne Source: 06.js, line 550 Pop() stack: ... val -&gt; ... Inherited From: module:Six~Machine10#Pop Source: 06.js, line 405 Print() stack: ... n*val -&gt; ... Inherited From: module:Six~Machine11#Print Source: 06.js, line 553 Push() stack: ... -&gt; ... result Inherited From: module:Six~Machine10#Push Source: 06.js, line 408 Puts() stack: ... val -&gt; ... | puts(val) Inherited From: module:Six~Machine10#Puts Source: 06.js, line 411 Return() stack: ... old-pc -&gt; ... | pc: old-pc Inherited From: module:Seven~Machine04#Return Source: 07.js, line 316 ReturnValue() stack: ... x old-pc result -&gt; ... result old-pc result Inherited From: module:Seven~Machine04#ReturnValue Source: 07.js, line 320 Store() stack: ... val -&gt; ... val | memory[a]: val Inherited From: module:Six~Machine10#Store Source: 06.js, line 414 StoreDP() stack: ... val -&gt; ... val | frame[depth][addr]: val Source: 07.js, line 1145 StoreFP() stack: ... val -&gt; ... val | frame[addr]: val Inherited From: module:Seven~Machine06#StoreFP Source: 07.js, line 667 Subtract() stack: ... a b -&gt; ... a-b Inherited From: module:Six~Machine10#Subtract Source: 06.js, line 417 gen() returns code.length Inherited From: module:Six~Machine10#gen Source: 06.js, line 374 ins() returns instruction function Inherited From: module:Six~Machine10#ins Source: 06.js, line 379 run() Returns stack machine executable Inherited From: module:Six~Machine11#run Source: 06.js, line 506 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 trace() Returns trace function, if any Inherited From: module:Six~Machine11#trace Source: 06.js, line 483 × Search results Close "},"module-Seven-Machine13_Memory.html":{"id":"module-Seven-Machine13_Memory.html","title":"Class: Memory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Memory Seven~Machine13# Memory @extends super.Memory new Memory() Data memory for nested functions. Properties: Name Type Description dp number display (static link) pointer. frames Array.&lt;number&gt; toString() function [replace]: uses dp. Overrides: module:Seven~Machine06#Memory Source: 07.js, line 1083 × Search results Close "},"module-Seven-Nest13.html":{"id":"module-Seven-Nest13.html","title":"Mixin: Nest13","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Mixin: Nest13 Seven~ Nest13 Example 7/13: add actions and infrastructure to compile nested functions. Source: 07.js, line 1154 Classes Fun Var Members funct Replace: manage stack of functions Source: 07.js, line 1164 functs List of inner to outer nested frames, null at end. Source: 07.js, line 1158 Methods _alloc() Returns new Var at next local/global address. Source: 07.js, line 1210 _find() Replace: searches blocks, functions, and global. Source: 07.js, line 1296 block() block: begin body 'end'; [inherit]. Source: 07.js, line 1349 else() else: Else body; [inherit] Source: 07.js, line 1379 head() head: 'function' Name; returns function symbol. Source: 07.js, line 1325 loop() loop: While cmp Do body 'od'; [inherit] Source: 07.js, line 1367 × Search results Close "},"module-Seven-Nest13_Fun.html":{"id":"module-Seven-Nest13_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Seven~Nest13# Fun @extends super.Fun new Fun() Describes a nested function with block structure in Nest13. Properties: Name Type Description depth number length of static link scope undefined | Block .locals contains this entry() function [extend] create bypass setParms() function [extend] room for display storeOk() function [replace] consider outer functions store() function [replace] consider depth pop() function [extend] check for undefined functions exit() function [replace] use depth, fix bypass toString function () - [extend] display depth Source: 07.js, line 1231 × Search results Close "},"module-Seven-Nest13_Var.html":{"id":"module-Seven-Nest13_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Seven~Nest13# Var @extends super.Var new Var() Describes a global or nested variable in Nest13. Properties: Name Type Description depth number [extend] &gt;=1: nested. load() function [replace] use depth. store() function [replace] use depth toString() function [replace] show depth. Source: 07.js, line 1182 × Search results Close "},"module-Seven-Parameters06.html":{"id":"module-Seven-Parameters06.html","title":"Class: Parameters06","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Parameters06 Seven~ Parameters06 Example 7/06: compile functions with parameters and local variables. new Parameters06() Source: 07.js, line 674 Extends module:Seven~Functions04 Classes Fun Symbol Var Members context Manages a stack of contexts for assign or call to a name Source: 07.js, line 764 funct Describes current function Inherited From: module:Seven~Functions04#funct Overrides: module:Seven~Functions04#funct Source: 07.js, line 334 size Manages next (global) variable address Inherited From: module:Seven~Functions04#size Overrides: module:Seven~Functions04#size Source: 07.js, line 329 Methods Do() Do: 'do'; returns address of slot for bzero to od Inherited From: module:Six~Control11#Do Overrides: module:Seven~Functions04#Do Source: 06.js, line 606 Else() Else: 'else'; creates slot for branch to fi, returns address of else Inherited From: module:Six~Control11#Else Overrides: module:Seven~Functions04#Else Source: 06.js, line 624 Then() Then: 'then'; returns address for bzero to else fi Inherited From: module:Six~Control11#Then Overrides: module:Seven~Functions04#Then Source: 06.js, line 620 While() While: 'while'; returns address for branch to while Inherited From: module:Six~Control11#While Overrides: module:Seven~Functions04#While Source: 06.js, line 603 _alloc() Replace: returns new Var at next local/global address. Overrides: module:Seven~Functions04#_alloc Source: 07.js, line 779 _check_defs() Flags undefined functions, returns main if defined Inherited From: module:Seven~Functions04#_check_defs Overrides: module:Seven~Functions04#_check_defs Source: 07.js, line 466 _dcl() Replace: sets innermost map, returns sym Overrides: module:Seven~Functions04#_dcl Source: 07.js, line 795 _find() Extend: checks local then global map, returns sym Overrides: module:Seven~Functions04#_find Source: 07.js, line 787 _startup(main) [Extend] Push 0 for main parameters. Parameters: Name Type Description main Fun describes main(). Overrides: module:Seven~Functions04#_startup Source: 07.js, line 806 add() add: '+' product; Inherited From: module:Six~Arithmetic10#add Overrides: module:Seven~Functions04#add Source: 06.js, line 444 args() args: '(' [ sums ] ')'; expects context, codes call Source: 07.js, line 845 assign() assign: symbol action; codes Pop, pops context Overrides: module:Seven~Functions04#assign Source: 07.js, line 830 divide() divide: '/' signed; Inherited From: module:Six~Arithmetic10#divide Overrides: module:Seven~Functions04#divide Source: 06.js, line 455 eq() eq: '=' sum; Inherited From: module:Six~Control11#eq Overrides: module:Seven~Functions04#eq Source: 06.js, line 629 fun() fun: head parms [ block ] ';'; Overrides: module:Seven~Functions04#fun Source: 07.js, line 818 ge() ge: '&gt;=' sum; Inherited From: module:Six~Control11#ge Overrides: module:Seven~Functions04#ge Source: 06.js, line 635 gt() gt: '&gt;' sum; Inherited From: module:Six~Control11#gt Overrides: module:Seven~Functions04#gt Source: 06.js, line 633 head() head: 'function' Name; returns function symbol Inherited From: module:Seven~Functions04#head Overrides: module:Seven~Functions04#head Source: 07.js, line 523 input() input: 'input' [ Number ]; Inherited From: module:Six~Arithmetic10#input Overrides: module:Seven~Functions04#input Source: 06.js, line 463 le() le: '&lt;=' sum; Inherited From: module:Six~Control11#le Overrides: module:Seven~Functions04#le Source: 06.js, line 639 loop() loop: While cmp Do stmts 'od'; Inherited From: module:Six~Control11#loop Overrides: module:Seven~Functions04#loop Source: 06.js, line 597 lt() lt: '&lt;' sum; Inherited From: module:Six~Control11#lt Overrides: module:Seven~Functions04#lt Source: 06.js, line 637 multiply() multiply: '*' signed; Inherited From: module:Six~Arithmetic10#multiply Overrides: module:Seven~Functions04#multiply Source: 06.js, line 452 name() name: symbol [ args ]; codes variable load, pops context Overrides: module:Seven~Functions04#name Source: 07.js, line 886 names() names: Name [{ ',' Name }]; defines new variables, returns number of names Inherited From: module:Seven~Functions04#names Overrides: module:Seven~Functions04#names Source: 07.js, line 506 ne() ne: '&lt;&gt;' sum; Inherited From: module:Six~Control11#ne Overrides: module:Seven~Functions04#ne Source: 06.js, line 631 number() number: Number; Inherited From: module:Six~Arithmetic10#number Overrides: module:Seven~Functions04#number Source: 06.js, line 468 parms() parms: '(' [ names ] ')'; Source: 07.js, line 823 print() print: 'print' sums; Inherited From: module:Six~Control11#print Overrides: module:Seven~Functions04#print Source: 06.js, line 591 prog() prog: [ vars ] funs; returns executable Inherited From: module:Seven~Functions04#prog Overrides: module:Seven~Functions04#prog Source: 07.js, line 486 return() return: 'return' [ sum ]; Inherited From: module:Seven~Functions04#return Overrides: module:Seven~Functions04#return Source: 07.js, line 558 run() Creates stack machine Inherited From: module:Six~Machine09#run Overrides: module:Seven~Functions04#run Source: 06.js, line 255 select() select: 'if' cmp Then stmts [ Else stmts ] 'fi'; Inherited From: module:Six~Control11#select Overrides: module:Seven~Functions04#select Source: 06.js, line 609 signed() signed: [ '-' ] term; Inherited From: module:Six~Arithmetic10#signed Overrides: module:Seven~Functions04#signed Source: 06.js, line 458 stmt() stmt: assign | print | loop | select; [replace] no op Inherited From: module:Six~Control11#stmt Overrides: module:Seven~Functions04#stmt Source: 06.js, line 582 store() store: '=' sum; expects context, codes assignment Source: 07.js, line 837 subtract() subtract: '-' product; Inherited From: module:Six~Arithmetic10#subtract Overrides: module:Seven~Functions04#subtract Source: 06.js, line 447 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Inherited From: module:Six~Arithmetic10#sum Overrides: module:Seven~Functions04#sum Source: 06.js, line 438 sums() sums: sum [{ ',' sum }]; returns number of values Inherited From: module:Six~Control11#sums Overrides: module:Seven~Functions04#sums Source: 06.js, line 594 symbol() symbol: Name; pushes context, returns symbol Source: 07.js, line 896 toString() Represents code as text Inherited From: module:Six~Machine09#toString Overrides: module:Seven~Functions04#toString Source: 06.js, line 250 × Search results Close "},"module-Seven-Parameters06_Fun.html":{"id":"module-Seven-Parameters06_Fun.html","title":"Class: Fun","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Fun Seven~Parameters06# Fun @extends super.Fun new Fun() Describes a function with parameters and local variables. Properties: Name Type Description parms number number of parameters. addr number offset of function result slot in frame. locals Map maps names to local variables. size number size of frame. entry() function [replace] slot for Entry. setParms() function captures number of parameters, starts frame. undo() function [extend] also reset locals. store() function [replace] use StoreFP. exit() function [replace] fill Entry, Exit. Overrides: module:Seven~Functions04#Fun Source: 07.js, line 716 × Search results Close "},"module-Seven-Parameters06_Symbol.html":{"id":"module-Seven-Parameters06_Symbol.html","title":"Class: Symbol","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Symbol Seven~Parameters06# Symbol new Symbol() (Inner) base class for symbol descriptions. Properties: Name Type Description owner module:Seven~Functions04 outer class. name string variable or function name. Inherited From: module:Seven~Functions04#Symbol Overrides: module:Seven~Functions04#Symbol Source: 07.js, line 342 × Search results Close "},"module-Seven-Parameters06_Var.html":{"id":"module-Seven-Parameters06_Var.html","title":"Class: Var","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Var Seven~Parameters06# Var @extends super.Var new Var() Describes a global or local variable. Properties: Name Type Description depth number 0: global, 1: local. load() function [replace] global/local. store() function [replace] global/local. Overrides: module:Seven~Functions04#Var Source: 07.js, line 680 × Search results Close "},"module-Seven-TCheck01.html":{"id":"module-Seven-TCheck01.html","title":"Class: TCheck01","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: TCheck01 Seven~ TCheck01 Example 7/01: actions to compile string values and conversions into functions. new TCheck01() Source: 07.js, line 12 Extends module:Six~Functions12 Methods _unq() Removes quotes and backslash Source: 07.js, line 14 add() add: '+' product; returns fct for composition Inherited From: module:Six~Functions07#add Source: 06.js, line 175 assign() assign: Name '=' sum; returns fct Inherited From: module:Six~Functions12#assign Source: 06.js, line 671 cmp() cmp: sum rel; returns fct Inherited From: module:Six~Functions12#cmp Source: 06.js, line 698 divide() divide: '/' signed; returns fct for composition Inherited From: module:Six~Functions07#divide Source: 06.js, line 197 eq() eq: '=' expr; returns fct for composition Inherited From: module:Six~Functions12#eq Source: 06.js, line 703 ge() ge: '&gt;=' expr; returns fct for composition Inherited From: module:Six~Functions12#ge Source: 06.js, line 718 gt() gt: '&gt;' expr; returns fct for composition Inherited From: module:Six~Functions12#gt Source: 06.js, line 713 input() input: 'input' String String; [replace] returns fct Overrides: module:Six~Functions12#input Source: 07.js, line 75 le() le: '&lt;=' expr; returns fct for composition Inherited From: module:Six~Functions12#le Source: 06.js, line 728 list() list: sum [{ ',' sum }]; returns executable Inherited From: module:Six~Functions07#list Source: 06.js, line 156 loop() loop: 'while' cmp 'do' stmts 'od'; returns fct Inherited From: module:Six~Functions12#loop Source: 06.js, line 686 lt() lt: '&lt;' expr; returns fct for composition Inherited From: module:Six~Functions12#lt Source: 06.js, line 723 multiply() multiply: '*' signed; returns fct for composition Inherited From: module:Six~Functions07#multiply Source: 06.js, line 192 name() name: Name; returns fct Inherited From: module:Six~Functions06#name Source: 06.js, line 146 ne() ne: '&lt;&gt;' expr; returns fct for composition Inherited From: module:Six~Functions12#ne Source: 06.js, line 708 number() number: Number; returns fct Inherited From: module:Six~Functions06#number Source: 06.js, line 140 print() print: 'print' sums; returns function Inherited From: module:Six~Functions12#print Source: 06.js, line 676 product() product: signed [{ multiply | divide }]; returns fct Inherited From: module:Six~Functions07#product Source: 06.js, line 185 prog() prog: stmts; returns executable Inherited From: module:Six~Functions12#prog Source: 06.js, line 659 select() select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi'; returns fct Inherited From: module:Six~Functions12#select Source: 06.js, line 691 signed() signed: [ '-' ] term; returns fct Inherited From: module:Six~Functions07#signed Source: 06.js, line 202 stmts() stmts: stmt [{ ';' stmt }]; returns fct Inherited From: module:Six~Functions12#stmts Source: 06.js, line 662 string() string: String; returns fct Source: 07.js, line 70 stringEq() stringEq: '=' stringSum; returns fct for composition Source: 07.js, line 82 stringGe() stringGe: '&gt;=' stringSum; returns fct for composition Source: 07.js, line 91 stringGt() stringGt: '&gt;' stringSum; returns fct for composition Source: 07.js, line 88 stringLe() stringLe: '&lt;=' stringSum; returns fct for composition Source: 07.js, line 97 stringLt() stringLt: '&lt;' stringSum; returns fct for composition Source: 07.js, line 94 stringNe() stringNe: '&lt;&gt;' stringSum; returns fct for composition Source: 07.js, line 85 stringSum() stringSum: stringTerm [{ stringTerm }]; returns fct Source: 07.js, line 56 stringTerm() stringTerm: string | name | input | 'string' term; Source: 07.js, line 64 subtract() subtract: '-' product; returns fct for composition Inherited From: module:Six~Functions07#subtract Source: 06.js, line 180 sum() sum: product [{ add | subtract }]; returns fct Inherited From: module:Six~Functions12#sum Source: 06.js, line 733 sums() sums: sum [{ ',' sum }]; returns list of functions Inherited From: module:Six~Functions12#sums Source: 06.js, line 681 term() term: number | '(' sum ')' | 'number' stringTerm; returns fct:term Overrides: module:Six~Functions12#term Source: 07.js, line 38 × Search results Close "},"module-Seven-TCheck02.html":{"id":"module-Seven-TCheck02.html","title":"Class: TCheck02","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: TCheck02 Seven~ TCheck02 Example 7/02: actions to type-check and compile int|float|string into functions. new TCheck02() Source: 07.js, line 102 Extends module:Seven~TCheck01 Members parser For error messages Source: 07.js, line 104 stack For symbolic computing with types Source: 07.js, line 110 symbols Symbol table, maps names to types Source: 07.js, line 107 Methods _cast() Converts fct:from into fct:to if needed Source: 07.js, line 127 _type() Returns type of name, message if undefined Source: 07.js, line 120 _unq() Removes quotes and backslash Inherited From: module:Seven~TCheck01#_unq Overrides: module:Seven~TCheck01#_unq Source: 07.js, line 14 add() add: '+' product; returns fct:string|int|float Overrides: module:Seven~TCheck01#add Source: 07.js, line 217 assign() assign: Name '=' sum; returns fct Overrides: module:Seven~TCheck01#assign Source: 07.js, line 168 cmp() cmp: sum rel; returns fct Overrides: module:Seven~TCheck01#cmp Source: 07.js, line 200 decl() decl: type Name [{ ',' Name }]; Source: 07.js, line 154 divide() divide: '/' signed; returns fct:float Overrides: module:Seven~TCheck01#divide Source: 07.js, line 245 eq() eq: '=' expr; returns fct for composition Inherited From: module:Six~Functions12#eq Overrides: module:Seven~TCheck01#eq Source: 06.js, line 703 float() float: Float; returns fct:float Source: 07.js, line 288 ge() ge: '&gt;=' expr; returns fct for composition Inherited From: module:Six~Functions12#ge Overrides: module:Seven~TCheck01#ge Source: 06.js, line 718 gt() gt: '&gt;' expr; returns fct for composition Inherited From: module:Six~Functions12#gt Overrides: module:Seven~TCheck01#gt Source: 06.js, line 713 input() input: 'input' String String; returns fct.string Overrides: module:Seven~TCheck01#input Source: 07.js, line 280 int() int: Int; returns fct:int Source: 07.js, line 285 le() le: '&lt;=' expr; returns fct for composition Inherited From: module:Six~Functions12#le Overrides: module:Seven~TCheck01#le Source: 06.js, line 728 list() list: sum [{ ',' sum }]; returns executable Inherited From: module:Six~Functions07#list Overrides: module:Seven~TCheck01#list Source: 06.js, line 156 loop() loop: 'while' cmp 'do' stmts 'od'; returns fct Inherited From: module:Six~Functions12#loop Overrides: module:Seven~TCheck01#loop Source: 06.js, line 686 lt() lt: '&lt;' expr; returns fct for composition Inherited From: module:Six~Functions12#lt Overrides: module:Seven~TCheck01#lt Source: 06.js, line 723 multiply() multiply: '*' signed; returns fct:int|float Overrides: module:Seven~TCheck01#multiply Source: 07.js, line 236 name() name: Name; returns fct:_type(name) Overrides: module:Seven~TCheck01#name Source: 07.js, line 298 ne() ne: '&lt;&gt;' expr; returns fct for composition Inherited From: module:Six~Functions12#ne Overrides: module:Seven~TCheck01#ne Source: 06.js, line 708 number() number: Number; returns fct Inherited From: module:Six~Functions06#number Overrides: module:Seven~TCheck01#number Source: 06.js, line 140 print() print: 'print' sums; returns fct, string arguments only Overrides: module:Seven~TCheck01#print Source: 07.js, line 177 printAny() printAny: 'print' sums; returns fct Source: 07.js, line 185 product() product: signed [{ multiply | divide }]; returns fct Inherited From: module:Six~Functions07#product Overrides: module:Seven~TCheck01#product Source: 06.js, line 185 prog() prog: [{ decl ';' }] stmts; returns executable Overrides: module:Seven~TCheck01#prog Source: 07.js, line 151 select() select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi'; returns fct Inherited From: module:Six~Functions12#select Overrides: module:Seven~TCheck01#select Source: 06.js, line 691 signed() signed: [ '-' ] term; returns fct:term Overrides: module:Seven~TCheck01#signed Source: 07.js, line 254 stmts() stmts: stmt [{ ';' stmt }]; returns fct Inherited From: module:Six~Functions12#stmts Overrides: module:Seven~TCheck01#stmts Source: 06.js, line 662 string() string: String; returns fct:string Overrides: module:Seven~TCheck01#string Source: 07.js, line 293 stringEq() stringEq: '=' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringEq Overrides: module:Seven~TCheck01#stringEq Source: 07.js, line 82 stringGe() stringGe: '&gt;=' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringGe Overrides: module:Seven~TCheck01#stringGe Source: 07.js, line 91 stringGt() stringGt: '&gt;' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringGt Overrides: module:Seven~TCheck01#stringGt Source: 07.js, line 88 stringLe() stringLe: '&lt;=' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringLe Overrides: module:Seven~TCheck01#stringLe Source: 07.js, line 97 stringLt() stringLt: '&lt;' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringLt Overrides: module:Seven~TCheck01#stringLt Source: 07.js, line 94 stringNe() stringNe: '&lt;&gt;' stringSum; returns fct for composition Inherited From: module:Seven~TCheck01#stringNe Overrides: module:Seven~TCheck01#stringNe Source: 07.js, line 85 stringSum() stringSum: stringTerm [{ stringTerm }]; returns fct Inherited From: module:Seven~TCheck01#stringSum Overrides: module:Seven~TCheck01#stringSum Source: 07.js, line 56 stringTerm() stringTerm: string | name | input | 'string' term; Inherited From: module:Seven~TCheck01#stringTerm Overrides: module:Seven~TCheck01#stringTerm Source: 07.js, line 64 subtract() subtract: '-' product; returns fct:int|float Overrides: module:Seven~TCheck01#subtract Source: 07.js, line 225 sum() sum: product [{ add | subtract }]; returns fct Inherited From: module:Six~Functions12#sum Overrides: module:Seven~TCheck01#sum Source: 06.js, line 733 sums() sums: sum [{ ',' sum }]; returns list of functions Inherited From: module:Six~Functions12#sums Overrides: module:Seven~TCheck01#sums Source: 06.js, line 681 term() term: int | float | string | name | input | 'int' term | 'float' term | 'string' term | '(' sum ')'; returns fct:term Overrides: module:Seven~TCheck01#term Source: 07.js, line 269 × Search results Close "},"module-Six.html":{"id":"module-Six.html","title":"Module: Six","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Six This module contains the classes for all examples in chapter six. Version: 2024-02-27 Author: © 2023 Axel T. Schreiner Source: 06.js, line 1 Classes Arithmetic09 Arithmetic10 Control11 Eval02 Eval03 Eval04 Functions05 Functions06 Functions07 Functions12 Machine09 Machine10 Machine11 Postfix08 × Search results Close "},"module-Six-Arithmetic09.html":{"id":"module-Six-Arithmetic09.html","title":"Class: Arithmetic09","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Arithmetic09 Six~ Arithmetic09 Example 6/09: actions to generate stack machine code. new Arithmetic09() Source: 06.js, line 265 Methods _alloc() Returns memory address for name Source: 06.js, line 279 add() add: '+' right; Source: 06.js, line 310 divide() divide: '/' signed; Source: 06.js, line 333 input() input: 'input' [ Number ]; Source: 06.js, line 350 list() list: stmt [{ ';' stmt }]; Source: 06.js, line 288 multiply() multiply: '*' right; Source: 06.js, line 326 name() name: Name; Source: 06.js, line 364 number() number: Number; Source: 06.js, line 358 signed() signed: [ '-' ] term; Source: 06.js, line 340 stmt() stmt: sum; Source: 06.js, line 298 subtract() subtract: '-' right; Source: 06.js, line 317 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Source: 06.js, line 303 × Search results Close "},"module-Six-Arithmetic10.html":{"id":"module-Six-Arithmetic10.html","title":"Class: Arithmetic10","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Arithmetic10 Six~ Arithmetic10 Example 6/10: actions to generate mnemonic stack machine code. new Arithmetic10() Source: 06.js, line 424 Extends module:Six~Machine09 Methods add() add: '+' product; Source: 06.js, line 444 divide() divide: '/' signed; Source: 06.js, line 455 input() input: 'input' [ Number ]; Source: 06.js, line 463 multiply() multiply: '*' signed; Source: 06.js, line 452 name() name: Name; Source: 06.js, line 474 number() number: Number; Source: 06.js, line 468 run() Creates stack machine Inherited From: module:Six~Machine09#run Overrides: module:Six~Machine09#run Source: 06.js, line 255 signed() signed: [ '-' ] term; Source: 06.js, line 458 stmt() stmt: sum; Source: 06.js, line 432 subtract() subtract: '-' product; Source: 06.js, line 447 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Source: 06.js, line 438 toString() Represents code as text Inherited From: module:Six~Machine09#toString Overrides: module:Six~Machine09#toString Source: 06.js, line 250 × Search results Close "},"module-Six-Control11.html":{"id":"module-Six-Control11.html","title":"Class: Control11","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Control11 Six~ Control11 Example 6/11: compile a little language into stack machine code. new Control11() Source: 06.js, line 560 Extends module:Six~Arithmetic10 Methods Do() Do: 'do'; returns address of slot for bzero to od Source: 06.js, line 606 Else() Else: 'else'; creates slot for branch to fi, returns address of else Source: 06.js, line 624 Then() Then: 'then'; returns address for bzero to else fi Source: 06.js, line 620 While() While: 'while'; returns address for branch to while Source: 06.js, line 603 add() add: '+' product; Inherited From: module:Six~Arithmetic10#add Overrides: module:Six~Arithmetic10#add Source: 06.js, line 444 assign() assign: Name '=' sum; stores and pops stack Source: 06.js, line 585 divide() divide: '/' signed; Inherited From: module:Six~Arithmetic10#divide Overrides: module:Six~Arithmetic10#divide Source: 06.js, line 455 eq() eq: '=' sum; Source: 06.js, line 629 ge() ge: '&gt;=' sum; Source: 06.js, line 635 gt() gt: '&gt;' sum; Source: 06.js, line 633 input() input: 'input' [ Number ]; Inherited From: module:Six~Arithmetic10#input Overrides: module:Six~Arithmetic10#input Source: 06.js, line 463 le() le: '&lt;=' sum; Source: 06.js, line 639 loop() loop: While cmp Do stmts 'od'; Source: 06.js, line 597 lt() lt: '&lt;' sum; Source: 06.js, line 637 multiply() multiply: '*' signed; Inherited From: module:Six~Arithmetic10#multiply Overrides: module:Six~Arithmetic10#multiply Source: 06.js, line 452 name() name: Name; Inherited From: module:Six~Arithmetic10#name Overrides: module:Six~Arithmetic10#name Source: 06.js, line 474 ne() ne: '&lt;&gt;' sum; Source: 06.js, line 631 number() number: Number; Inherited From: module:Six~Arithmetic10#number Overrides: module:Six~Arithmetic10#number Source: 06.js, line 468 print() print: 'print' sums; Source: 06.js, line 591 prog() prog: stmts; returns executable Source: 06.js, line 566 run() Creates stack machine Inherited From: module:Six~Machine09#run Overrides: module:Six~Arithmetic10#run Source: 06.js, line 255 select() select: 'if' cmp Then stmts [ Else stmts ] 'fi'; Source: 06.js, line 609 signed() signed: [ '-' ] term; Inherited From: module:Six~Arithmetic10#signed Overrides: module:Six~Arithmetic10#signed Source: 06.js, line 458 stmt() stmt: assign | print | loop | select; [replace] no op Overrides: module:Six~Arithmetic10#stmt Source: 06.js, line 582 subtract() subtract: '-' product; Inherited From: module:Six~Arithmetic10#subtract Overrides: module:Six~Arithmetic10#subtract Source: 06.js, line 447 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Inherited From: module:Six~Arithmetic10#sum Overrides: module:Six~Arithmetic10#sum Source: 06.js, line 438 sums() sums: sum [{ ',' sum }]; returns number of values Source: 06.js, line 594 toString() Represents code as text Inherited From: module:Six~Machine09#toString Overrides: module:Six~Arithmetic10#toString Source: 06.js, line 250 × Search results Close "},"module-Six-Eval02.html":{"id":"module-Six-Eval02.html","title":"Class: Eval02","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Eval02 Six~ Eval02 Example 6/02: actions to support signed numbers. new Eval02() Source: 06.js, line 11 Methods number() number: Number; Source: 06.js, line 30 signed() signed: [ '-' ] term; Source: 06.js, line 24 sum() sum: product [{ add | subtract }]; Source: 06.js, line 15 term() term: number | '(' sum ')'; Source: 06.js, line 27 × Search results Close "},"module-Six-Eval03.html":{"id":"module-Six-Eval03.html","title":"Class: Eval03","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Eval03 Six~ Eval03 Example 6/03: adds actions to support multiplication and division. new Eval03() Source: 06.js, line 35 Extends module:Six~Eval02 Methods divide() divide: '/' signed; Source: 06.js, line 51 multiply() multiply: '*' signed; Source: 06.js, line 48 number() number: Number; Inherited From: module:Six~Eval02#number Source: 06.js, line 30 product() product: signed [{ multiply | divide }]; Source: 06.js, line 42 signed() signed: [ '-' ] term; Inherited From: module:Six~Eval02#signed Source: 06.js, line 24 sum() sum: product [{ add | subtract }]; Inherited From: module:Six~Eval02#sum Source: 06.js, line 15 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Source: 06.js, line 27 × Search results Close "},"module-Six-Eval04.html":{"id":"module-Six-Eval04.html","title":"Class: Eval04","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Eval04 Six~ Eval04 Example 6/04: adds actions to support lists of numerical expressions. new Eval04() Source: 06.js, line 60 Extends module:Six~Eval03 Methods add() add: '+' product; Source: 06.js, line 73 divide() divide: '/' signed; Inherited From: module:Six~Eval03#divide Source: 06.js, line 51 list() list: sum [{ ',' sum }]; Source: 06.js, line 62 multiply() multiply: '*' signed; Inherited From: module:Six~Eval03#multiply Source: 06.js, line 48 number() number: Number; Inherited From: module:Six~Eval02#number Source: 06.js, line 30 product() product: signed [{ multiply | divide }]; Inherited From: module:Six~Eval03#product Source: 06.js, line 42 signed() signed: [ '-' ] term; Inherited From: module:Six~Eval02#signed Source: 06.js, line 24 subtract() subtract: '-' product; Source: 06.js, line 76 sum() sum: product [{ add | subtract }]; Overrides: module:Six~Eval03#sum Source: 06.js, line 68 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Source: 06.js, line 27 × Search results Close "},"module-Six-Functions05.html":{"id":"module-Six-Functions05.html","title":"Class: Functions05","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Functions05 Six~ Functions05 Example 6/05: adds actions to support variable names. new Functions05() Source: 06.js, line 88 Extends module:Six~Eval04 Methods add() add: '+' product; Inherited From: module:Six~Eval04#add Overrides: module:Six~Eval04#add Source: 06.js, line 73 divide() divide: '/' signed; Inherited From: module:Six~Eval03#divide Overrides: module:Six~Eval04#divide Source: 06.js, line 51 list() list: sum [{ ',' sum }]; Inherited From: module:Six~Eval04#list Overrides: module:Six~Eval04#list Source: 06.js, line 62 multiply() multiply: '*' signed; Inherited From: module:Six~Eval03#multiply Overrides: module:Six~Eval04#multiply Source: 06.js, line 48 name() name: Name; returns value or 0 Source: 06.js, line 114 number() number: Number; Inherited From: module:Six~Eval02#number Overrides: module:Six~Eval04#number Source: 06.js, line 30 product() product: signed [{ multiply | divide }]; Inherited From: module:Six~Eval03#product Overrides: module:Six~Eval04#product Source: 06.js, line 42 signed() signed: [ '-' ] term; Inherited From: module:Six~Eval02#signed Overrides: module:Six~Eval04#signed Source: 06.js, line 24 subtract() subtract: '-' product; Inherited From: module:Six~Eval04#subtract Overrides: module:Six~Eval04#subtract Source: 06.js, line 76 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Overrides: module:Six~Eval04#sum Source: 06.js, line 98 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Overrides: module:Six~Eval04#term Source: 06.js, line 27 × Search results Close "},"module-Six-Functions06.html":{"id":"module-Six-Functions06.html","title":"Class: Functions06","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Functions06 Six~ Functions06 Example 6/06: changes actions to support returning names, numbers, and input as functions. new Functions06() Source: 06.js, line 123 Extends module:Six~Functions05 Methods add() add: '+' product; Inherited From: module:Six~Eval04#add Source: 06.js, line 73 divide() divide: '/' signed; Inherited From: module:Six~Eval03#divide Source: 06.js, line 51 input() input: 'input' [ Number ]; returns fct Source: 06.js, line 134 list() list: sum [{ ',' sum }]; Inherited From: module:Six~Eval04#list Source: 06.js, line 62 multiply() multiply: '*' signed; Inherited From: module:Six~Eval03#multiply Source: 06.js, line 48 name() name: Name; returns fct Overrides: module:Six~Functions05#name Source: 06.js, line 146 number() number: Number; returns fct Overrides: module:Six~Functions05#number Source: 06.js, line 140 product() product: signed [{ multiply | divide }]; Inherited From: module:Six~Eval03#product Source: 06.js, line 42 signed() signed: [ '-' ] term; Inherited From: module:Six~Eval02#signed Source: 06.js, line 24 subtract() subtract: '-' product; Inherited From: module:Six~Eval04#subtract Source: 06.js, line 76 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Inherited From: module:Six~Functions05#sum Source: 06.js, line 98 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Source: 06.js, line 27 × Search results Close "},"module-Six-Functions07.html":{"id":"module-Six-Functions07.html","title":"Class: Functions07","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Functions07 Six~ Functions07 Example 6/07: changes remaining actions to support returning arithmetic expressions as functions. new Functions07() Source: 06.js, line 154 Extends module:Six~Functions06 Methods add() add: '+' product; returns fct for composition Overrides: module:Six~Functions06#add Source: 06.js, line 175 divide() divide: '/' signed; returns fct for composition Overrides: module:Six~Functions06#divide Source: 06.js, line 197 input() input: 'input' [ Number ]; returns fct Inherited From: module:Six~Functions06#input Source: 06.js, line 134 list() list: sum [{ ',' sum }]; returns executable Overrides: module:Six~Functions06#list Source: 06.js, line 156 multiply() multiply: '*' signed; returns fct for composition Overrides: module:Six~Functions06#multiply Source: 06.js, line 192 name() name: Name; returns fct Inherited From: module:Six~Functions06#name Source: 06.js, line 146 number() number: Number; returns fct Inherited From: module:Six~Functions06#number Source: 06.js, line 140 product() product: signed [{ multiply | divide }]; returns fct Overrides: module:Six~Functions06#product Source: 06.js, line 185 signed() signed: [ '-' ] term; returns fct Overrides: module:Six~Functions06#signed Source: 06.js, line 202 subtract() subtract: '-' product; returns fct for composition Overrides: module:Six~Functions06#subtract Source: 06.js, line 180 sum() sum: 'let' Name '=' sum | product [{ add | subtract }]; Overrides: module:Six~Functions06#sum Source: 06.js, line 167 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Source: 06.js, line 27 × Search results Close "},"module-Six-Functions12.html":{"id":"module-Six-Functions12.html","title":"Class: Functions12","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Functions12 Six~ Functions12 Example 6/12: compile a little language into JavaScript functions. new Functions12() Source: 06.js, line 657 Extends module:Six~Functions07 Methods add() add: '+' product; returns fct for composition Inherited From: module:Six~Functions07#add Source: 06.js, line 175 assign() assign: Name '=' sum; returns fct Source: 06.js, line 671 cmp() cmp: sum rel; returns fct Source: 06.js, line 698 divide() divide: '/' signed; returns fct for composition Inherited From: module:Six~Functions07#divide Source: 06.js, line 197 eq() eq: '=' expr; returns fct for composition Source: 06.js, line 703 ge() ge: '&gt;=' expr; returns fct for composition Source: 06.js, line 718 gt() gt: '&gt;' expr; returns fct for composition Source: 06.js, line 713 input() input: 'input' [ Number ]; returns fct Inherited From: module:Six~Functions06#input Source: 06.js, line 134 le() le: '&lt;=' expr; returns fct for composition Source: 06.js, line 728 list() list: sum [{ ',' sum }]; returns executable Inherited From: module:Six~Functions07#list Source: 06.js, line 156 loop() loop: 'while' cmp 'do' stmts 'od'; returns fct Source: 06.js, line 686 lt() lt: '&lt;' expr; returns fct for composition Source: 06.js, line 723 multiply() multiply: '*' signed; returns fct for composition Inherited From: module:Six~Functions07#multiply Source: 06.js, line 192 name() name: Name; returns fct Inherited From: module:Six~Functions06#name Source: 06.js, line 146 ne() ne: '&lt;&gt;' expr; returns fct for composition Source: 06.js, line 708 number() number: Number; returns fct Inherited From: module:Six~Functions06#number Source: 06.js, line 140 print() print: 'print' sums; returns function Source: 06.js, line 676 product() product: signed [{ multiply | divide }]; returns fct Inherited From: module:Six~Functions07#product Source: 06.js, line 185 prog() prog: stmts; returns executable Source: 06.js, line 659 select() select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi'; returns fct Source: 06.js, line 691 signed() signed: [ '-' ] term; returns fct Inherited From: module:Six~Functions07#signed Source: 06.js, line 202 stmts() stmts: stmt [{ ';' stmt }]; returns fct Source: 06.js, line 662 subtract() subtract: '-' product; returns fct for composition Inherited From: module:Six~Functions07#subtract Source: 06.js, line 180 sum() sum: product [{ add | subtract }]; returns fct Overrides: module:Six~Functions07#sum Source: 06.js, line 733 sums() sums: sum [{ ',' sum }]; returns list of functions Source: 06.js, line 681 term() term: number | '(' sum ')'; Inherited From: module:Six~Eval02#term Source: 06.js, line 27 × Search results Close "},"module-Six-Machine09.html":{"id":"module-Six-Machine09.html","title":"Class: Machine09","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine09 Six~ Machine09 Example 6/09: stack machine. new Machine09() Source: 06.js, line 246 Methods run() Creates stack machine Source: 06.js, line 255 toString() Represents code as text Source: 06.js, line 250 × Search results Close "},"module-Six-Machine10.html":{"id":"module-Six-Machine10.html","title":"Class: Machine10","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine10 Six~ Machine10 Example 6/10: stack machine with mnemonics. new Machine10() Source: 06.js, line 372 Extends module:Six~Machine09 Methods Add() stack: ... a b -&gt; ... a+b Source: 06.js, line 385 Divide() stack: ... a b -&gt; ... a/b Source: 06.js, line 388 Input() stack: ... -&gt; ... input Source: 06.js, line 391 Load() stack: ... -&gt; ... memory[addr] Source: 06.js, line 396 Minus() stack: ... a -&gt; ... -a Source: 06.js, line 399 Multiply() stack: ... a b -&gt; ... a*b Source: 06.js, line 402 Pop() stack: ... val -&gt; ... Source: 06.js, line 405 Push() stack: ... -&gt; ... result Source: 06.js, line 408 Puts() stack: ... val -&gt; ... | puts(val) Source: 06.js, line 411 Store() stack: ... val -&gt; ... val | memory[a]: val Source: 06.js, line 414 Subtract() stack: ... a b -&gt; ... a-b Source: 06.js, line 417 gen() returns code.length Source: 06.js, line 374 ins() returns instruction function Source: 06.js, line 379 run() Creates stack machine Inherited From: module:Six~Machine09#run Source: 06.js, line 255 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 × Search results Close "},"module-Six-Machine11.html":{"id":"module-Six-Machine11.html","title":"Class: Machine11","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Machine11 Six~ Machine11 Example 6/11: branches, stepping, and tracing. new Machine11() Source: 06.js, line 481 Extends module:Six~Machine10 Classes Memory Methods Add() stack: ... a b -&gt; ... a+b Inherited From: module:Six~Machine10#Add Source: 06.js, line 385 Branch() stack: ... -&gt; ... | pc: a Source: 06.js, line 529 Bzero() stack: ... bool -&gt; ... | pc: !bool? a Source: 06.js, line 532 Divide() stack: ... a b -&gt; ... a/b Inherited From: module:Six~Machine10#Divide Source: 06.js, line 388 Eq() stack: ... a b -&gt; ... a == b Source: 06.js, line 535 Ge() stack: ... a b -&gt; ... a &gt;= b Source: 06.js, line 538 Gt() stack: ... a b -&gt; ... a &gt; b Source: 06.js, line 541 Input() stack: ... -&gt; ... input Inherited From: module:Six~Machine10#Input Source: 06.js, line 391 Le() stack: ... a b -&gt; ... a &lt;= b Source: 06.js, line 544 Load() stack: ... -&gt; ... memory[addr] Inherited From: module:Six~Machine10#Load Source: 06.js, line 396 Lt() stack: ... a b -&gt; ... a &lt; b Source: 06.js, line 547 Minus() stack: ... a -&gt; ... -a Inherited From: module:Six~Machine10#Minus Source: 06.js, line 399 Multiply() stack: ... a b -&gt; ... a*b Inherited From: module:Six~Machine10#Multiply Source: 06.js, line 402 Ne() stack: ... a b -&gt; ... a != b Source: 06.js, line 550 Pop() stack: ... val -&gt; ... Inherited From: module:Six~Machine10#Pop Source: 06.js, line 405 Print() stack: ... n*val -&gt; ... Source: 06.js, line 553 Push() stack: ... -&gt; ... result Inherited From: module:Six~Machine10#Push Source: 06.js, line 408 Puts() stack: ... val -&gt; ... | puts(val) Inherited From: module:Six~Machine10#Puts Source: 06.js, line 411 Store() stack: ... val -&gt; ... val | memory[a]: val Inherited From: module:Six~Machine10#Store Source: 06.js, line 414 Subtract() stack: ... a b -&gt; ... a-b Inherited From: module:Six~Machine10#Subtract Source: 06.js, line 417 gen() returns code.length Inherited From: module:Six~Machine10#gen Source: 06.js, line 374 ins() returns instruction function Inherited From: module:Six~Machine10#ins Source: 06.js, line 379 run() Returns stack machine executable Overrides: module:Six~Machine10#run Source: 06.js, line 506 toString() Represents code as text Inherited From: module:Six~Machine09#toString Source: 06.js, line 250 trace() Returns trace function, if any Source: 06.js, line 483 × Search results Close "},"module-Six-Machine11_Memory.html":{"id":"module-Six-Machine11_Memory.html","title":"Class: Memory","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Memory Six~Machine11# Memory extends Array new Memory() Data memory. Properties: Name Type Description pc number program counter. continue boolean true if execution can be continued. toString() function represents as text. Source: 06.js, line 499 × Search results Close "},"module-Six-Postfix08.html":{"id":"module-Six-Postfix08.html","title":"Class: Postfix08","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Postfix08 Six~ Postfix08 Example 6/08: actions to convert to postfix. new Postfix08() Source: 06.js, line 213 Methods add() add: '+' right; Source: 06.js, line 217 divide() divide: '/' signed; Source: 06.js, line 228 input() input: 'input' [ Number ]; Source: 06.js, line 236 multiply() multiply: '*' right; Source: 06.js, line 225 name() name: Name; Source: 06.js, line 242 number() number: Number; Source: 06.js, line 239 signed() signed: [ '-' ] term; Source: 06.js, line 231 subtract() subtract: '-' right; Source: 06.js, line 220 × Search results Close "},"module-Ten.html":{"id":"module-Ten.html","title":"Module: Ten","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Module: Ten This module contains classes for some examples in chapter ten. Version: 2024-02-26 Author: © 2024 Axel T. Schreiner Source: 10.js, line 1 Classes Actions07 Actions09 × Search results Close "},"module-Ten-Actions07.html":{"id":"module-Ten-Actions07.html","title":"Class: Actions07","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions07 Ten~ Actions07 Example 10/07: immediate evaluation. new Actions07() Source: 10.js, line 9 Methods add() add: expr '+' expr; Source: 10.js, line 16 divide() divide: expr '/' expr; Source: 10.js, line 25 expr() expr: add | subtract | ... | '(' expr ')' | number; Source: 10.js, line 11 multiply() multiply: expr '*' expr; Source: 10.js, line 22 number() number: Number; Source: 10.js, line 31 power() power: expr '**' expr; Source: 10.js, line 28 subtract() subtract: expr '-' expr; Source: 10.js, line 19 × Search results Close "},"module-Ten-Actions09.html":{"id":"module-Ten-Actions09.html","title":"Class: Actions09","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Class: Actions09 Ten~ Actions09 Example 10/09: unary minus. new Actions09() Source: 10.js, line 35 × Search results Close "},"tutorial-00-preface.html":{"id":"tutorial-00-preface.html","title":"Tutorial: Overview","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit Overview This book is a short introduction to compiler construction using JavaScript as the implementation language, recursive descent parsing with the EBNF parser generator and SLR(1) parsing with BNF as case studies for tools, and a little programming language with several extensions as working example. Here are the topics: 1. Compiler Terminology What's in a Compiler? What's in a Parser Generator? 2. Writing Grammars What's in a Rule? A Language for Rules Summary 3. Scanning Input Terminals, Tokens, and Literals Taking Input Apart Summary 4. Recognizing Sentences What's in a Sentence? Check Before You Call! Summary 5. Translating Sentences What's in a Parse Tree? What's with the Brackets? Summary 6. Compiling Little Languages Interpret Now, Compile for Later Functions and a Stack Machine Summary 7. Language Features Type Checking Functions, Scopes, and Nesting Summary 8. Functions as Values First-Order Functions Stack versus Closure Summary 9. Compiling Grammars What's in a Parser Generator? Grammar (De-)Constructed Summary 10. Recognition Revisited Try (Almost) Everything? Conflicts and Errors Summary 11. Compiling Revisited What's in a Tree? What's with a Tree? Summary A: The Practice Page The Model Scripting and Buttons Explained B: The Stack Machine Machine Architecture Instructions C: The One-Pass Compilers The Method Browser Rules and Actions Symbol Table D: The Compiler Kit Tree Builders Visitors References All references are links. Undecorated links are references within the book itself. Decorated links reference the book's website: Examples are linked to the practice page where they are automatically loaded to be executed, studied, changed, and executed again. Classes and methods developed in the examples are linked to their documentation, to the documentation for classes and methods of the EBNF and BNF parser generators developed in the book, and to the documentation for scripting the practice page. Documentation in turn links to the appropriate files and lines with the syntax-colored source code. Some links, mostly in chapter eight, reference the method browser where one can study how the implementation of a little programming language in this book evolves. Other decorated links reference the World Wide Web: For JavaScript information, links point to the excellent MDN Web Docs, a few links point to specific web pages, such as the original announcement of JavaScript, and terminology is linked to definitions in Wikipedia so that additional information is easily available — further references should be consulted from there. Altogether, the book contains over 1100 unique links. Next: 1. Compiler Terminology × Search results Close "},"tutorial-01-overview.html":{"id":"tutorial-01-overview.html","title":"Tutorial: 1. Compiler Terminology","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 1. Compiler Terminology What's in a Compiler? What's in a Parser Generator? A compiler translates a source program into an executable. It should also check that the source program is correct — at least in some sense. The source program is written in the source language, the executable is written in the target language, the compiler itself is written in the implementation language. For this book, target and implementation language, both, are JavaScript because we will not discuss how to deal with low level languages such as assembler or machine language as target languages. However, beginning in chapter six, we will implement a small, typical programming language and target a simple stack machine which we will simulate in JavaScript. Often, source and implementation language are the same, i.e., a compiler for a language is written in that language and can compile itself. Chapter nine illustrates how self-compilation for parser generators works. Translation The source program is presented as a text string. Translation is accomplished by cooperating tools which focus on specific aspects: A scanner represents the source program as a sequence of terminals, similar to words forming a sentence, and discards, e.g., white space and comments. A parser tries to construct a syntax tree from the terminals to represent the program structure. Translation proceeds in several steps which might run sequentially or all at once: Lexical analysis is the process of running a scanner. Lexical analysis detects illegal characters which are neither terminals nor allowed to be ignored. Syntax analysis is the process of running a parser. The result is often called a parse tree or syntax tree. Syntax analysis detects syntax errors, e.g., unbalanced parentheses, unbalanced or missing keywords, bad punctuation, etc. Semantic analysis performs type checking and adds information to the parse tree, e.g., the data type produced by certain leaves or branches during execution. Semantic analysis should detect semantic errors, e.g., undefined values, illegal assignments, unsuitable function arguments, and type conflicts in general. Finally, the executable is created from the parse tree and the information collected by semantic analysis, if any. Tools Lexical and syntax analysis are fairly formal processes which are well supported by programming tools such as EBNF, BNF, and their Grammar classes: A scanner generator takes a description of terminals and constructs a scanner. The description is usually based on search patterns, also known as regular expressions. Chapter three explains how to create a scanner from regular expressions. A parser generator takes a description of a grammar and constructs a parser. Chapter two explains how to describe grammars and chapter four explains one technique to create a parser from a grammar; chapter ten discusses a more powerful technique. Chapter nine explains how to implement parser generators. Parser generators either produce trees to which semantic analysis can add annotations, or they provide a programming interface for the benefit of semantic analysis. Chapter five explains how to represent a syntax tree, and chapter six introduces a typical programming interface where semantic analysis or the creation of an executable can be attached. Grammar and Trees Syntax analysis depends on grammars and syntax trees which can be defined quite formally: A context-free grammar consists of a finite set of terminals, a finite set of non-terminals — different from terminals and among them one called the start symbol, and a finite set of rules. Each rule is an ordered pair of a non-terminal and a finite, ordered sequence consisting of terminals and non-terminals. There may be different pairs with the same non-terminal and different sequences. A context-free grammar defines a syntax tree as follows: The root node of the syntax tree is labeled with the start symbol of the grammar. All branch nodes are labeled with non-terminals, all leaf nodes are labeled with terminals. A syntax tree is an ordered tree, i.e., subtrees appear in a branch node in a fixed order. Every ordered pair consisting of the non-terminal for a branch node and the ordered sequence of labels taken from the roots of the subtrees for the branch node must be in the rules of the grammar. Language and Sentences The rules of a grammar describe the branch nodes of every syntax tree, i.e., a grammar is the finite description of a language: A sentence is the (finite) ordered sequence of terminals which are the leaves of a syntax tree. There might be more than one syntax tree for a sentence. A language is the (usually) infinite set of all sentences which use the same grammar for their syntax trees. There might be more than one grammar for the same language. Note that ordered pairs (rules) with empty sequences would result in leaf nodes which are labeled with non-terminals. They cannot be part of a sentence as defined above. Empty sequences look like a glitch in these definitions but chapter ten will illustrate that they are necessary. The previous definitions still work if a sentence is defined to consist of the leaves of a syntax tree with the exception of those leaves which are labeled with non-terminals. Previous: Overview Next: 2. Writing Grammars × Search results Close "},"tutorial-02-grammars.html":{"id":"tutorial-02-grammars.html","title":"Tutorial: 2. Writing Grammars","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 2. Writing Grammars What's in a Rule? A Language for Rules Formally, a rule is an ordered pair of two sequences of terminals and non-terminals, i.e., from the two sets of symbols in a grammar. For rules of a context-free grammars the first sequence of the ordered pair is restricted to be a single non-terminal. A grammar contains rules and describes sentences, i.e., sequences of input terminals. As an example we consider sentences which are sums of numbers such as 1 + 2 A rule to describe this sentence is, e.g., sum: '1' '+' '2'; So far, this notation for rules is inspired by the Backus-Naur form: sum is the non-terminal at left; we require that non-terminals are alphanumeric names, i.e., consist of letters, digits, and perhaps underscores, and start with a letter. The sequence of terminals on the right consists of 1, +, and 2; we enclose each in single quotes to indicate that they have to be spelled literally as shown. If we need a quote or backslash as part of a terminal we will precede it by a backslash. Finally, we require that the two parts of the rule are separated by a colon and that the entire rule is terminated by a semicolon. White space is necessary in a rule to separate non-terminal names, but it is ignored outside of terminals. It should be noted that a list of such rules implicitly defines everything there is to know about a grammar: terminals and their representations in the input, non-terminals, rules, and the start symbol, by convention the non-terminal at left in the first rule — here it is sum. Example 2/01 illustrates that this grammar can be used to recognize a sentence: Press to represent and check the grammar, and then press to perform syntax analysis, i.e., to try to recognize the sentence, i.e., to check whether a parse tree can be found. Now add or remove some spaces in the and press again to see that white space does not matter for recognition. Replace 1 and 2 in the and press again to see that other numbers cause errors as long as the rule in the requires 1 and 2. Finally, replace 1 and 2 in the and in the and press and to allow different numbers. Literals and Tokens The example shows that spelling terminals literally in grammar rules may be useful but it is too restrictive. If we want to describe sums of numbers in general the specific value of a number is not important. Therefore, we use two kinds of terminals: Literals represent themselves and are single-quoted strings using \\ only to escape single quotes and \\ itself. Tokens represent classes of similar inputs such as numbers, and are specified in rules as alphanumeric names which must be different from non-terminal names. For convenience we will use upper- and lower-case initials to immediately distinguish the two kinds of names. Tokens have to be defined separately from the grammar itself. Chapter three explains in detail that regular expressions are a very good way to describe tokens. For now it is sufficient that /[0-9]+/ describes a Number of any length which consists of one or more of the digits from 0 to 9. Based on this definition the rule sum: Number '+' Number; describes all sums of two integer numbers such as 12 + 345 Example 2/02 contains the new rule in the and the definition of Number as a property with the token name and a (non-anchored) regular expression as the value in the : Press to represent and check the grammar. As it is set up, the example will produce an error when you press to create a parser and perform syntax analysis — the area contains a bit more than a sentence. Change either the or the to avoid the error. Alternatives A more useful sum of numbers has to contain at least one number, but it should be allowed to contain any number of numbers. If the right hand side of a rule only contains terminals we would need very many rules. Here are the first three, all with the same non-terminal on the left: sum: Number; sum: Number '+' Number; sum: Number '+' Number '+' Number; There have been many extensions to the BNF notation which inspired the grammar notation used in most of this book and developed in this chapter. For alternatives, we collect all pairs with the same non-terminal at left and write instead: sum: Number | Number '+' Number | Number '+' Number '+' Number; We require that a rule name, i.e., the non-terminal at left, is unique, and we use | to concatenate separate alternative sequences for the right-hand side. Example 2/03 illustrates that the grammar above has a problem: Press to represent and check the grammar and see the error message. You can toggle to suppress ambiguity checking and thus the error message when you press , but when you press to try and recognize the content of the you will find that only one number, i.e., the first alternative of the rule, can be recognized. Check out that once is set the order of the alternatives in the rule determines how many numbers can be in a sum. In the formal definition of a grammar there are no restrictions on rules. However, it would be quite inefficient to have to try all alternatives to find one that actually confirms that an input is a sentence. Therefore, we require that we must be able to select the appropriate alternative just by looking at the very next input — this is known as one symbol lookahead and it means that we will never back up in the input. Example 2/04 shows a change to the grammar to circumvent the problem: Press to represent and check the grammar, and press to recognize the prefix and the sum with three numbers in the . Change the prefix and work with other sums in the . The example uses the following grammar: sum: 'a' Number | 'b' Number '+' Number | 'c' Number '+' Number '+' Number; A prefix from a to c determines how many numbers the sum should contain. While this works it is not exactly user-friendly... Chapter ten will show a less intuitive way to get from grammars to recognition which makes the grammar in example 2/03 perform as intended — still without backing up: The very first button should show . If not, click it until it does. Press to process the grammar — this time there is no error message. Enter sums with one, two, or three numbers in the and press to see that all are recognized without errors. You can toggle to produce a trace (to be explained in chapter ten) which indicates when input is stacked (shift) and when a rule is satisfied (reduce, always followed by goto). Recursion Real sums contain any number of numbers, and they shouldn't require an obscure prefix. Consider the following approach: a: Number | Number '+' a; This may look confusing but it is a finite description of an infinite number of sums with a number and as many additional plus signs with numbers as we choose: The first alternative states that a is a Number. Alternatively, a is a Number, a plus sign, and another a — which can be a single Number, or more... Recursion is a finite way to describe infinite things. However, the particular rule above violates the principle that one symbol lookahead should be sufficient to select the successful alternative, i.e., two alternatives should not start with the same terminal — this was already illustrated in example 2/03. The following rule seems to look better: b: Number | b '+' Number; This is another finite description of an infinite number of sums with as many numbers as we choose: The first alternative states that b is a Number. The second alternative allows us to append as many plus signs with numbers as we want. However, example 2/05 which contains both rules, a and b, shows that there might still be problems: Press to represent and check the grammar and see an error message: b is left-recursive. Remove the rule for b from the grammar and remove b as an alternative in sum. Then press again to see another error message: a has ambiguous alternatives. A rule, considered just as an ordered pair, is left-recursive if the non-terminal at left appears first in the sequence at right, either directly, or even when tracing through other ordered pairs. Example 2/06 contains a small change to b to illustrate that left recursion can involve several rules: Press to try to represent the grammar and see the error messages: this time sum is left-recursive. sum: b; b: Number | sum '+' Number; Intuitively, this grammar does look doubtful — even without ambiguities. \"One symbol lookahead\" would select the first alternative of b and that is only a single number. If the alternatives for b are interchanged and the rules are tried in order it looks like a sum is a b is a sum is a b ... will we ever start to look at the first number in the input? It all depends on the approach used to interpret the grammar. The technique explained in chapter ten can deal with left recursion. Try example 2/06 again: The very first button should show . If not, click it until it does. Press to process the grammar — this time there is no error message. Enter various sums in the and press to see that all are recognized. Optional Brackets We want to describe sums and avoid ambiguities and left recursion. Consider: sum: Number more; more: '+' sum |; A sum consists of a number and more, and more adds a plus sign and another number or eventually nothing because more has an empty alternative which stops the right recursion on sum. At the end of chapter one it was noted that empty alternatives are awkward and they can easily be overlooked in a rule. Therefore, we extend our grammar notation: sum: Number [ more ]; more: '+' sum; We use brackets to indicate that part of an alternative is optional and we forbid empty alternatives — including those which only consist of optional parts... Work with this grammar in example 2/07 to see that we can finally have any number of numbers in a sum: Press to process the grammar, enter various sums in the , and press to see that all are recognized. The grammar uses right recursion to get long sums with syntax trees such as the following: If these trees were interpreted to perform arithmetic they would compute the sums from right to left, i.e., right recursion in the grammar results in right-associative trees. This is suggested by the brackets in the output from example 2/07: [ '12' [ [ '+' [ '345' [ [ '+' [ '6789' null ] ] ] ] ] ] ] Deeper nesting occurs at right. Rules can contain alternatives. We can use this to allow addition and subtraction in the rule for more: sum: Number [ more ]; more: '+' sum | '-' sum; Brackets can contain alternatives, too. Here is another way to describe the same language, i.e., the same set of sentences, i.e., sums with any number of additions and subtractions: sum: Number [ add | subtract ]; add: '+' sum; subtract: '-' sum; In chapter six this last version will turn out to be the most useful. For now, you can experiment with the first variant in example 2/08 and the second variant in example 2/09. Either one accepts arbitrary sums and differences and even produces the same set of brackets, numbers, and operators: [ '12' [ [ '-' [ '345' [ [ '+' [ '6789' null ] ] ] ] ] ] ] Chapter five will explain what all the brackets in the output mean. For now we note that the different grammars produce the same output, but something else is more significant. Consider 12 ( - 345 ( + 6789 ) ) which is the same output with some clutter removed. Mathematical conventions dictate that the innermost parentheses have to be elaborated first, i.e., this is likely to be interpreted as add 6789 to 345 then subtract the result from 12 i.e., 12 - (345 + 6789) and that's probably not what the program 12 - 345 + 6789 intended... Therefore, it is important to note that there can be different grammars describing the same sentences and language, and if a grammar is intended to suggest meaning, such as mathematical operator precedence and associativity, rules have to be crafted with that in mind — right recursion produces right associativity and for now left recursion is not allowed for the interpretation of rules from left to right even if it would produce the commonly used left associativity. Some Braces We started with the grammar notation known as Backus-Naur Form which was created to describe the programming language Algol. Recursion was used to express any kind of iteration so that a finite grammar can describe sentences of arbitrary length. Niklaus Wirth noticed that many programmers are more comfortable with explicit constructs for iteration and proposed the first of many extensions to BNF which all offer such constructs. Assuming that a sum has at least two numbers, here is another way to define a grammar: sum: Number { '+' Number | '-' Number }; Unlike other extensions to BNF, this book uses braces to enclose alternatives which must occur one or more times, i.e., a sum conforming to this grammar contains at least two numbers. Check out example 2/10 and compare the output [ '12' [ [ '-' '345' ] [ '+' '6789' ] ] ] to the output of example 2/08 and example 2/09 shown before: [ '12' [ [ '-' [ '345' [ [ '+' [ '6789' null ] ] ] ] ] ] ] Iteration makes for simpler looking output — this will be discussed further in chapter five and six. Many Iterations What about a sum that consists of a single number or more? As part of a rule, both, brackets and braces, can contain one or more alternatives. Alternatives are on the right-hand side of rules, where braces and brackets made their appearance. Combining the ideas, this means that braces and brackets can be nested. Clearly, it is superfluous to have brackets only contain another set of brackets or braces only contain another set of braces. More importantly, we avoid empty alternatives, i.e., an alternative cannot just consist of something optional in brackets, i.e., braces cannot just contain sets of brackets. But — something in braces appears one or more times; therefore, when brackets directly contain braces, together, they indicate something that can appear zero or more times: sum: Number [{ '+' Number | '-' Number }]; Check out example 2/11 and, in particular, confirm that single numbers are recognized and compare the output for 1 + 2 [ '1' [ [ [ '+' '2' ] ] ] ] to the output for the same sum in example 2/10: [ '1' [ [ '+' '2' ] ] ] We will return to this in chapter five. Quick Summary Terminals are literals and tokens. Literals represent themselves as input and are single-quoted strings using \\ only to escape single quotes and \\ itself. Tokens represent sets of inputs, e.g., numbers, and are alphanumeric names starting with a letter — in our examples in upper case. Tokens are defined with search patterns, e.g., /[0-9]+/ for numbers. Formally, rules are ordered pairs, each consisting of a non-terminal and a sequence of terminals and non-terminals. Non-terminals are alphanumeric names starting with a letter — in our examples in lower case. The sets of non-terminal names and token names must be disjoint. Backus-Naur Form uses : to separate the non-terminal from the sequence in the rule, | to combine all alternative sequences for the same non-terminal, and ; to terminate a rule. There has to be exactly one rule for each non-terminal and we call the non-terminal name the rule name. The rule name of the first rule in the list of rules of a grammar is the name of the start symbol. Extended BNF adds notations for optional and repeated sets of alternatives. We use [ and ] (brackets) to enclose a set of optional alternatives and { and } (braces) to enclose a set of alternatives that must appear some times, i.e., one(!) or more times. We forbid empty alternatives, e.g., an empty sequence or a sequence containing only optional items. In particular, braces cannot directly contain only brackets. We allow brackets to directly contain braces because this denotes a set of alternatives which can appear many times, i.e., zero or more times. By convention, white space in a grammar and usually in input will be ignored. Recursion Revisited Example 2/12 contains a fairly comprehensive grammar describing a comma-separated list of expressions, with the typical arithmetic operators and parentheses: list: sum [{ ',' sum }]; sum: product [{ '+' product | '-' product }]; product: signed [{ '*' signed | '/' signed }]; signed: [ '-' | '+' ] term; term: Number | '(' sum ')'; This grammar shows the necessary use of recursion for balanced notations such as parentheses. This is neither left- nor right-recursion. The rule for term contains both parentheses to keep them balanced and by recursion nests a sum and thus balanced parentheses to any depth. The rule for sum uses iteration to arrange for any number of product and thus term in sequence, and they can contain balanced parentheses, but the grammar does not permit unbalanced parentheses in a sentence. Example 2/13 contains a grammar describing typical list constructs: terminated: { [ separated ] ';' }; separated: element [{ ',' element }]; element: Number | enclosed; enclosed: '(' [ separated ] ')'; A sentence is a list with one or more entries, each terminated with a semicolon. An entry itself can be empty (because seperated is optional), or it is a list of one or more elements which are separated by single commas. An element is either a Number, or a list enclosed by a balanced number of parentheses. The enclosed list consists of zero or more elements which are separated by single commas. terminated or separated are blueprints for statements in a programming language. enclosed is a blueprint for function parameters or arguments. It is instructive to investigate various sentences, e.g., ( (1,2), 3, (()) ); ; even if the output looks much messier than the sentence itself. Tokens Revisited As a final example in this chapter, example 2/14 contains the grammar from example 2/12, with one more rule added to define Number right in the grammar from single digit literals: list: ... Number: { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' }; This suggests that we might not need tokens, i.e., names for classes of input such as numbers or names. However, example 2/14 demonstrates that the result is not quite the same. As we shall see in the next chapter, our recognition process usually ignores white space in the input. With the rule above, both of the following numbers 12, 1 2 are acceptable for a sentence and the result, even for a single number, can be unexpected: [ [ [ [ null [ [ [ [ '1' ] [ '2' ] ] ] ] ] null ] null ] null ] Plus, character recognition with a grammar, while mostly automated, is much less efficient than character recognition with regular expressions, and we will use these in recognizing literals anyhow. Previous: 1. Compiler Terminology Next: 3. Scanning Input × Search results Close "},"tutorial-03-scanner.html":{"id":"tutorial-03-scanner.html","title":"Tutorial: 3. Scanning Input","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 3. Scanning Input Terminals, Tokens, and Literals Taking Input Apart Chapter one explained that lexical analysis, the first phase of the translation process in a compiler, breaks the source program — usually a string — into parts called terminals in order to simplify the job of the next phase, syntax analysis. Chapter two explained that a grammar describes sentences, i.e., sequences of terminals which conform to the rules of the grammar. Therefore, a grammar will at least describe what terminals it needs for the rules, even if it does not really need to describe what the terminals look like in an actual source program. Our grammar notation distinguishes two kinds of terminals, literals and tokens: A literal is a single-quoted string in a rule and the content of the string represents the literal in the source program. Backslashes are used to escape single quotes and backslashes in the string content in the rule. A token is just a name in a rule, different from all non-terminal names. Tokens are defined as key-value pairs (properties) of a JavaScript object where the key is the token name and the value is a regular expression (search pattern) which describes how the token is represented in the source program. If the grammar in example 2/10 is represented and checked by pressing the output is a short description of the grammar: 0 sum: Number { '+' Number | '-' Number }; literals: '+', '-' tokens: Number The description contains a numbered list of rules, a list of single-quoted literals, and a list of token names used in the rules. The token patterns are in the text of the : { Number: /[0-9]+/ } Together with the convention to ignore white space this is enough information to break the source program up into terminals: Press to represent and check the grammar and press to perform lexical analysis. The output shows how the string in the 12 - 345 + 6789 is cut into pieces: &gt; g.scanner().pattern /(\\s+)|([0-9]+)|(\\-)|(\\+)/gm &gt; g.scanner().scan(program) (1) \"12\" Number (1) '-' (1) \"345\" Number (1) '+' (1) \"6789\" Number The first line in the output displays the search pattern which is used for lexical analysis. It will be discussed below. The second line contains the JavaScript expression to create a scanner and perform lexical analysis. Each of the remaining lines in the output describes one Tuple object, consisting of a line number, a piece of the input, and a classification as a terminal: For a literal the piece of input is enclosed in single quotes. For a token the piece of input is enclosed in double quotes and the token name is shown, too. Illegal input is enclosed in double quotes and there is no token name. The output is independent of any white space which may or may not be in the . If, for example, some newline characters are inserted between the numbers and operators, only the line numbers in the Tuple objects will change. The button uses the scan() method of a Scanner object which is constructed from the grammar. This chapter explains how an object of the Scanner class chops up the input. Search Patterns Computer users always search for specific pieces of text — buried in files or among collections of file names. Even the earliest versions of operating systems such as DOS, Unix®, or Windows, provided more than \"literal\" searches — they supported search patterns. For example rm abc d?f g*i [0-9*a-z]\\* This Unix® command might not be terribly realistic, but it demonstrates the principle. It would remove the file literally named abc, all files with three-character names starting with d and ending with f, all files with names starting with g, ending with i, and containing zero or more characters in-between, and, finally, all files with a name consisting of a single digit, asterisk, or lower-case letter, followed by a literal asterisk. Search patterns are usually called regular expressions because they employ a very concise notation for regular grammars which are context-free grammars where the right-hand side of rules can only use a terminal or a terminal followed by a single non-terminal. The patterns above demonstrate that this allows for iteration, but it does not allow, e.g., for a construction that can balance parentheses. Regular expressions can have very efficient implementations based on the theory of finite state automata. One has to be cautious, however. While most modern programming languages support regular expressions for searching and text validation, neither the syntax nor the semantics of regular expressions is consistent across different languages, e.g., (a.*b)|[cde]+ should find a followed by any number of characters and then b, or find a sequence of one or more of the characters c, d, or e. However, depending on the platform, the expression might well find the first match, or the longest match, or even all matches... The EBNF module/parser generator is implemented in JavaScript; therefore these tutorials will use and discuss regular expressions as they are supported in JavaScript. Different flavors of regular expressions can be tested on the Regular Expressions 101 website. Regular Expressions 101 This section is a crash course on patterns as they are supported in JavaScript, specifically, to deal with the question how typical terminals in programming languages can be expressed through patterns. Many of the more esoteric aspects of regular expressions are not covered here. A pattern is used to recognize part of an input string. Patterns are a shorthand notation for a type of grammars; therefore, we should expect that there is a concept of literals and tokens for patterns: Letters, digits, and (very few) special characters are literals and recognize themselves. This can be used to recognize words in a programming language: if then else while do A period is a token in the language of regular expressions which recognizes any character with the exception of a line separator: . Brackets, [ and ], enclose a sequence of characters, which is termed a character class. This token recognizes any single one of its constituent characters: [0123456789] If the sequence inside brackets starts with ^ the token will recognize any single character not in the sequence — most of the time this is more than one bargains for: [^a-z] - between two characters inside the sequence denotes the inclusive range. All of this together can be used to recognize single digits, single lower-case letters, or all special characters in the ASCII character set [0-9] [a-z] [!-/:-@[-`{-~] Most non-alphanumeric characters have a special meaning in a pattern. This can be defeated by preceding a character with the \\ (backslash) character. In particular, \\\\ is the literal to recognize one backslash. Simply preceding every character in a pattern with backslash is unwise because some letters acquire special meaning when preceded by backslash. For example, this literal recognizes any single white space character, even outside the ASCII character set: \\s Chapter two explained that grammars use rules built from literals and tokens to describe more complicated sentences. Instead of rules, regular expressions use certain operators to build complicated patterns from simpler pieces. From a semantic perspective the constructs have much in common with the extensions to BNF discussed previously. To begin with, a sequence of pattern pieces recognizes a sequence of input parts each of which matches the corresponding pattern piece. For example, this sequence recognizes command language variable names $0 through $9: \\$[0-9] One should always escape $ because $ at the end of a pattern anchors recognition, i.e., it demands that recognition extend all the way to the end of input. ^ at the beginning of a pattern also anchors recognition, i.e., recognition must start at the beginning of input. For example, this pattern recognizes a string only if it consists exactly of two command variable names separated by exactly one white space character: ^\\$[0-9]\\s\\$[0-9]$ Iteration is expressed by ?, +, or * directly following a pattern piece to indicate that the piece is optional, recognized one or more times, or both, in the input. This can be used, e.g., to recognize optionally signed integer numbers (line 1 below), alphanumeric variable names starting with a letter (line 2), or such a name and number optionally surrounded and definitely separated by white space as the only input (line 3): [-+]?[0-9]+ [a-zA-Z][a-zA-Z0-9]* ^\\s*[a-zA-Z][a-zA-Z0-9]*\\s+[-+]?[0-9]+\\s*$ Patterns support alternatives: pattern pieces can be joined with the operator |. Just as in grammars, sequences take precedence over alternatives. Iterations take precedence over sequences. Here is a pattern for a number which would be interpreted as decimal, hexadecimal, or octal, depending on the prefix: [1-9][0-9]*|0[xX][0-9a-fA-F]+|0[0-7]* The order of alternatives can make a difference because JavaScript is happy with the first alternative that matches. Use the Regular Expressions 101 website to see that the previous pattern will not recognize 0xA if the last alternative is specified first, i.e., 0[0-7]*|[1-9][0-9]*|0[xX][0-9a-fA-F]+ Parentheses (?: and ) can be used to group pattern pieces and thus change precedence and nest alternatives into sequences and both into iterations. Here is a pattern for a non-empty, single-quoted string which uses backslash to escape a single quote, backslash, or newline (represented as \\n): '(?:\\\\['\\\\\\n]|[^'\\\\\\n])+' Admittedly, JavaScript patterns also allow simple parentheses; however, simple parentheses introduce capture groups which serve a very special purpose that is critical for the scan() method developed in the next section. We have already seen the patterns needed to describe most of the tokens for a typical programming language. Among them, strings are the most complicated but the last example showed how escape conventions and newlines can be handled. Slightly more complicated is the removal of comments from input. Patterns cannot balance nests of leading and trailing sequences; therefore, patterns cannot deal with nested comments. Other than that: Line comments are simple — they range from a leading sequence to the end of a line or of the input. \\/\\/[^\\n]*(?:\\n|$) JavaScript uses // for the lead of a comment and also uses / to enclose regular expressions; therefore, the pattern above for JavaScript comments escapes the leading '//'. Comments enclosed by unique single characters use the same design. E.g., Pascal encloses comments in braces and allows multiple lines in a comment: {[^}]*} Finally, comments enclosed in overlapping sequences, such as /* and */ in JavaScript, require careful specification: \\/\\*(?:[^*]|\\*+[^/*])*\\*+\\/ Here, zero or more character groups follow the opening /* and one or more asterisks precede the closing slash. Each character group consists of any single character but an asterisk, or of one or more asterisks followed by a single character which is neither a slash nor an asterisk. Use the Regular Expressions 101 website to see that, e.g., /***/ is recognized but /*/ is not. As far as possible, example 3/01 contains all the pattern examples in this section. Press to represent and check the grammar, and then press to see what tuples are found in the . Some definitions in the are not used in the grammar. Why not? Note that if you click on the label of a text area the area will expand. Shift-click will restore the default layout, and alt/option-click tries to open a separate, non-editable window with syntax highlighting. scan() Given the literals and descriptions for tokens, how does the scan() method perform lexical analysis, i.e., take an input string and return the list of Tuple objects which describe the terminals in the string? JavaScript represents regular expressions as objects of the class RegExp. An object can be constructed by enclosing a pattern in single slashes, or it can be constructed from a string — but then, backslash and quotes would have to be escaped according to string rules before they play their role in a pattern. The exec() method for a RegExp object accepts a string. If the regular expression matches the string somewhere the method returns an array, otherwise it returns null. The first element in the array is that part of the string which was matched. The remaining elements in the array, if any, contain the components of the matched part which the capture groups in the regular expression, if any, matched. This gets tricky if capture groups are nested, but here is a simple example which should suggest how exec() can be set up to do the job of lexical analysis. Consider a string with the alphabet abcdefghijklmnopqrstuvwxyz and consider a pattern with three capture groups ([a-f]+)(.*)([u-z]+) Matches are greedy, i.e., the first group matches the beginning of the alphabet, and it will grab all of the letters abcdef, the third group only matches the end of the alphabet, i.e., in this case z, because the second group is greedy, too, and matches all the letters in-between. Therefore, the JavaScript function call /([a-f]+)(.*)([u-z]+)/.exec('abcdefghijklmnopqrstuvwxyz') returns an array with four elements of length 26, 6, 19, and 1. The pattern would also match the string JavaScript because the first capture group is happy with the first a, the second group can match nothing, and the third group matches v. The resulting array again contains four strings, containing JavaScript, a, nothing, and v — check it out on the Regular Expressions 101 website. exec() can be configured by appending certain flags to the pattern, such as g (global) arranges that exec() can be called multiple times to find all matches of the pattern in the string. m (multiline) allows the anchors ^ and $ to match line feeds in the string. A capture group extracts a piece of input and classifies it in the resulting list by the group's position in the pattern — extraction and classification is what lexical analysis has to do. Example 3/02 creates the following pattern with four alternatives, each a capture group, namely white space, \"names\" (which include literals like if), \"numbers\", and the operator &lt;=: &gt; g.scanner().pattern = /(\\s+)|([a-z]+)|([0-9]+)|(\\&lt;\\=)/gm Depending on the string matched against the pattern, exactly one group will capture something — unless the entire match fails. As for lexical analysis: If nothing is matched or if the match does not start at the beginning of the input string there are illegal characters in the input. They can be represented by a specific Tuple object which does not classify the input. A match of the first group has to be trimmed off the input — the scanner skips, e.g., white space. The next set of groups consists of the tokens of the grammar which might have to be screened further. In this example, these are sequences of lower-case letters (\"names\") and sequences of digits (\"numbers\"). Note that something like iffy should be recognized as a name and not as the literal if followed by the name fy. The last set of groups consists of the literals of the grammar which are not matched by the tokens, in this case &lt;=. The lexical analysis pattern can be composed as alternatives of capture groups with one pattern for white space and comments, one pattern for each token, and finally one pattern for each literal in order of decreasing length so that, e.g., &lt;= is recognized before &lt;. Patterns for literals which are matched by a token pattern can be omitted. This assumes that white space and token patterns all match different input, and that the result of a token match such as \"names\" is screened, e.g., by looking the matched input up in a map of literal values which take precedence over the token. In general, overlapping patterns can cause problems. It is not possible to check that the patterns are \"different\" enough when the Scanner is constructed but example 3/01 and example 3/02 show how a grammar and some input can be used to test lexical analysis thoroughly: The grammar should contain all tokens and literals as simple alternatives. Press to represent the grammar. The should contain representations of all tokens and literals to be tested — the input does not have to be a sentence. Press to see what tuples are found. Example 3/03 illustrates that the token patterns may have to be ordered. Consider integer constants, represented as digit strings, and floating point constants, required to contain a decimal point: Int: /0|[1-9][0-9]*/, Real: /(?:0|[1-9][0-9]*)\\.[0-9]*/ The input string in the is 1 2.3 If the scanner() places the Int pattern before the Real pattern lexical analysis will find three Int tokens and one illegal character: &gt; g.scanner().pattern = /(\\s+)|(0|[1-9][0-9]*)|((?:0|[1-9][0-9]*)\\.[0-9]*)/gm &gt; g.scanner().scan(program) (1) \"1\" Int (1) \"2\" Int (1) \".\" (1) \"3\" Int As a crutch to fix this problem, the token patterns are sorted by name before they are combined for the lexical analysis pattern. In example 3/04 the token name is changed from Real to Float. Press to prepare the grammar, and press to test the lexical analysis pattern. Now the order of the token patterns is interchanged, Float before Int. The floating point pattern will find the floating point number and the output consists of two tuples: &gt; g.scanner().pattern = /(\\s+)|((?:0|[1-9][0-9]*)\\.[0-9]*)|(0|[1-9][0-9]*)/gm &gt; g.scanner().scan(program) (1) \"1\" Int (1) \"2.3\" Float Note that 0. and 0.1 are valid but .1 is not. This could be changed with an alternative in the Float pattern. Screening Many programming languages use reserved words, i.e., they forbid that literals such as if, then, and else are used as variable names — these literals should always indicate a control structure. From the perspective of a grammar for a programming language, variable names are a class of inputs, i.e., they are a token in the grammar, and the scanner must not report a reserved word like if as the particular token for variable names. Screening prevents that. A grammar is represented as a Grammar object. The scanner() method is called with an optional pattern argument which describes the parts of input which should be ignored, by default white space. scanner() returns a Scanner object which contains the lexical analysis pattern described above and a list, terminals, of the unique Lit and Token objects corresponding by position to the capture groups of the pattern. The scan() method of this Scanner object takes an input string, applies the lexical analysis pattern, and classifies the matching part of the input as a literal or token, represented as a Lit or Token object, by using the index of the capture group and the terminals list. If the scan() method proposes a part of the input as a token while it could be a literal it is used as an index into a map of literals with which the token overlaps — this should be an efficient operation in JavaScript. If the string is found, the result is the corresponding Lit object in place of the proposed Token object. Thus, literals masquerading as tokens are detected and lexical analysis can report them properly. Screening slows input processing down and should be used only if really necessary; e.g., a token for numbers will not require screening if all reserved words in the language consist of letters and all operators consist of special characters. To streamline the process all literal values which can appear in the input are checked against all token patterns when the Scanner object is constructed. If a literal value is classified as a token the corresponding Lit object is added to a map .screen for the Token object. If this map exists, it is consulted during scan() as described above. Additionally, the literal value is dropped from the lexical analysis pattern because it would not match anything on its own. Example 3/05 shows that things can go really wrong if a token pattern partially overlaps a literal. Patterns for \"numbers\" and alphabetic \"names\" would both overlap the literal 'Formula1'. Fortunately, this case is rare in the world of programming languages but the scanner() method has an optional parameter so that the pattern pieces can be sorted explicitly. The parameter can be used in a JavaScript program; example 3/05 would be corrected as follows: import * as EBNF from 'modules/ebnf.js'; const EBNF = await import(\"./ebnf.js\"); const grammar = \" examples: Name | Number | 'Formula1'; \", tokens = { Name: /[A-Za-z]+/, Number: /[0-9]+/ }, program = \" Formula 1 \\n Formula1 \"; const g = new EBNF.Grammar(grammar, tokens); g.check(); console.log(g.toString()); console.log(g.scanner().pattern); console.log(g.scanner().scan(program).join('\\n')); // the mistake const terminals = [ g.lit(\"'Formula1'\"), g.token('Name'), g.token('Number') ]; const s = g.scanner(/\\s+/, terminals); // the correction console.log(s.pattern); console.log(s.scan(program).join('\\n')); // the intended output In Node.js this produces the intended output: &gt; console.log(s.pattern); /(\\s+)|(Formula1)|([A-Za-z]+)|([0-9]+)/gm &gt; console.log(s.scan(program).join('\\n')); // the intended output (1) \"Formula\" Name (1) \"1\" Number (2) 'Formula1' Alternatively, an alphanumeric Name Name: /[A-Za-z][A-Za-z0-9]*/ would overlap Formula1 completely and screening would resolve Formula1 correctly as a literal. Quick Summary Lexical analysis breaks input into parts represented by the literals and tokens used in a grammar. It skips the irrelevant parts of the input — usually white space and comments. Sequences of one or more unrecognized input characters are also reported. Regular expressions (search patterns) are the tool of choice to describe literals and tokens and they are the basis for automatic implementation of lexical analysis. scanner() creates a Scanner object with a scan() method which accepts an input string and returns a list of Tuple objects describing the input parts. scan() uses a RegExp composed of the patterns for all tokens and some literals in the grammar, plus a pattern for input parts to be skipped. The order of patterns is important: (usually) tokens, sorted by name, before literals, literals sorted by length in reverse order. Overlapping token patterns may cause issues, in particular, if a token pattern partially overlaps a literal. As a last resort, the pattern order can be set explicitly when the Scanner object is created. Some tokens, such as the class of identifiers in a programming language, might hide reserved words, i.e., literals such as if then else which have a special meaning as a control structure. Such tokens are marked when the Scanner object is created and matched input is checked against a token-specific map of hidden literals so that the input part can be reported correctly. The Regular Expressions 101 website is great for testing. Example 3/01 contains many patterns for terminals used in programming languages. A few of these are too general to be used in the example... Previous: 2. Writing Grammars Next: 4. Recognizing Sentences × Search results Close "},"tutorial-04-parser.html":{"id":"tutorial-04-parser.html","title":"Tutorial: 4. Recognizing Sentences","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 4. Recognizing Sentences What's in a Sentence? Check Before You Call! Chapter two explained how to write grammars and chapter three explained how to extract terminals from input. This chapter discusses how to decide if an input string, i.e., a sequence of terminals delivered by lexical analysis, is a sentence of a language described by a grammar. Chapter one called this syntax analysis and it should result in a syntax tree for the sentence. A grammar contains all the information required to create a Parser object with a method parse() which implements syntax analysis — as long as the grammar is up to the job. This chapter also shows how to check a grammar to see if it can be used to create a Parser. Both, this implementation of syntax analysis and the corresponding grammar check, are very intuitive and the technique is called LL(1) — left-to-right parsing with leftmost derivation. Chapter 10 discusses SLR(1) — left-to-right with rightmost derivation — an approach which is not quite as intuitive but which can use a larger class of grammars. Trees Here is a grammar for a sum of at least two, optionally signed numbers: sum: term [{ more }]; more: '+' term | '-' term; term: [ '+' | '-' ] Number | '(' sum ')'; The following input is in fact a sentence: 1 - (2 + - 3) Arithmetic expressions such as this sum are often represented as expression trees where branch nodes are labeled with operators and leaf nodes are the numbers and variables in the expression. The levels of such an expression tree imply precedence, i.e., evaluation order; parentheses will not appear in an expression tree. Similarly, we can visualize the rules of a grammar as trees. Here is sum: Recall that the right-hand side of a rule such as sum consists of one or more alternatives. Each of these is a sequence. In this case there is only one and it consists of a reference term to another rule and something in braces to be repeated one or more times. Braces, in turn, contain alternatives, and each of those is again a sequence. In this case there is one alternative, namely a sequence consisting of a reference more to another rule. Here is the tree for the rule more: more has two alternatives. Each must again be a sequence. One contains the literal '+', the other contains '-', and each sequence then references the third rule, term: term also has two alternative sequences. One contains brackets with signs and a Number token, the other contains literals with parentheses enclosing a reference to a sum. Brackets indicate something optional and contain alternatives, just as braces do. In this case there are two sequences and each only contains a literal with a sign. Recognition For the purpose of recognition, rules can be viewed as functions. The diagrams suggest that the rule trees consist of objects which belong to a small set of classes each of which can have methods. At the top level, the parse() method of the Parser object generated by the parser() method from the grammar delegates the recognition problem to the start rule sum by calling a parse() method on the Rule object which is the root of the tree: Within the sum rule, there is only one alternative and that sequence delegates to its first element, which references and delegates to the rule term: term has two alternatives — time to look at the first terminal provided by lexical analysis. The proposed sentence is 1 - (2 + - 3) and it starts with 1. This Number only fits the first alternative of term, and only after the optional part of the sequence is skipped. We are on our way to building the syntax tree which will prove that the input is a sentence. The process can be viewed in example 4/01: Prepare the grammar by pressing and press to see what tuples lexical analysis creates. Next toggle and press to watch how syntax analysis, i.e., the parse() method of the Parser object and the parse() methods in the rule tree, consume the tuples — one up front, and a next one whenever syntax analysis reaches the current terminal: &gt; g.config.lookahead = true &gt; g.parser().parse(program) parser lookahead: (1) \"1\" Number Number lookahead: (1) '-' '-' lookahead: (1) '(' '(' lookahead: (1) \"2\" Number Number lookahead: (1) '+' '+' lookahead: (1) '-' '-' lookahead: (1) \"3\" Number Number lookahead: (1) ')' ')' lookahead: end of input Back in the sum, after term has found Number 1, the sequence advances to the next element which requires finding more one or more times: While there are two alternatives, the next input, literal '-', only fits the second alternative and we get a little further in building the parse tree: Syntax analysis continues, the parse() methods keep calling. The next input is literal '(' which rule term can match with the second alternative: Next, the sequence in term calls sum recursively before it will eventually match the trailing literal ')'. Here is the result, where the rule calls and the terminals have been colored for emphasis: The leaf nodes are all terminals, i.e., literals or tokens, and they match the proposed sentence 1 - (2 + - 3) in order, i.e., we have found a parse tree and confirmed that the input is a sentence! Strictly speaking, the diagram only shows that the input is a sequence of terminals (turquoise nodes) which are the leaves of an ordered tree. The definition of a syntax tree in chapter one requires that each branch node is labeled with a rule name and that the rule name and the sequence of subtrees (branch nodes and leaves) correspond to an ordered pair among the rules of the grammar. Chapter two extended the grammar notation and the extensions account for the white nodes in the diagram — sequences and the iteration constructs with brackets [ opt ] and braces { some }. Still, the red and white branch nodes interpreted together as extended notation must appear in the grammar. Parser and parse() How do the Parser's parse() method and the other parse() methods work? The grammar diagrams in the preceding section showed that the job can be elegantly distributed among the nodes in the grammar trees for the rules sum, more, and term: The colors suggest that the nodes belong to the following classes: object class purpose Rule represents a rule with a name and sequences as alternative descendants. Seq represents a sequence with terminals, rule references, braces, and brackets as descendants. NT represents a reference to a rule. Some represents braces with sequences as alternative descendants which are used one or more times. Lit represents a literal. Token represents a token. Opt represents brackets with sequences as alternative descendants which are optional. For convenience there are two more classes: Lit and Token extend the class T which represents terminals in general. Rule, Some, and Opt extend the class Alt which deals with alternative sequences in general. We require that the branch nodes Rule, Seq, Some, and Opt, always have one or more descendants, and that Seq cannot only have Opt as descendants. This means that every parse() method will eventually find something. Syntax analysis is implemented as parse() methods in six of the nine classes, the remaining three, Opt, Lit, and Token, simply inherit. The methods share a Parser object which owns the input tuples; the next() method is called to move on to the next tuple and it can trace lookahead. The actual implementation of syntax analysis is fairly simple: The Grammar's parser() method creates the Parser object and it's parse() method is the function which will be called with the input string to create the tuples, check that the start rule can handle the first tuple, and call the parse() method for the start rule. parse() for a Rule delegates to the superclass — chapter five explains what else the method can do to create a convenient representation of the sentence. The superclass Alt delegates to the particular descendant which can actually deal with the current tuple. Such a descendant exists — otherwise the method calls would not have reached this point. parse() for a Some, i.e., for braces, delegates to the superclass Alt until there is no longer a descendant which can deal with the current tuple — the next section explains how this is determined. parse() for a Seq delegates to one descendant after another — after first checking that the descendant can handle the current tuple and throwing an error if not — with one exception: a descendant Opt is skipped if it cannot deal with the current tuple. parse() for a non-terminal delegates to the referenced rule. Finally, parse() for literals and tokens calls the next() method to move on to the next tuple. Yes, all of this is just a lot of delegating the work — with the requirement to \"check before you call.\" Alt and Seq perform some traffic control and literals and tokens nudge the scanner when they are reached. The process can be observed in detail in example 4/01: represent and check the grammar by pressing . Toggle and and press to watch how syntax analysis proceeds: &gt; g.config.lookahead = true &gt; g.config.parse = true &gt; g.parser().parse(program) parser lookahead: (1) \"1\" Number sum| Rule parse { sum| super(sum: term [ { more } ];) parse { sum| Seq(term [ { more } ]) parse { sum| NT(term) parse { term| Rule parse { term| super(term: [ '+' | '-' ] Number | '(' sum ')';) parse { term| Seq([ '+' | '-' ] Number) parse { term| Token(Number) parse { Number lookahead: (1) '-' term| Token(Number) parse }: '1' term| Seq([ '+' | '-' ] Number) parse }: [ null '1' ] term| super(term: [ '+' | '-' ] Number | '(' sum ')';) parse }: [ null '1' ] term| Rule parse }: [ null '1' ] sum| NT(term) parse }: [ null '1' ] Each line of output is prefixed with the rule name which has been called, nested rule calls are indented. Each line contains the class name of the node in the rule tree — or super for a call to the superclass, e.g., Rule to Alt (line 6) — and the rule fragment corresponding to the node. If a line ends with { it traces a call, otherwise it ends with }: and the return value — which will be explained in chapter five. The above shows in complete detail how the function created by the parser() method calls on sum (line 5) which calls on term (line 9) to recognize the Number 1 (line 12). In particular, lines 12 to 14 above show that Token advances to the next tuple. expect \"Check before you call\" seems like excellent advice, but just exactly what needs to be checked? The parse() methods described in the previous section could be implemented in an error-tolerant fashion so that every alternative could be tried before syntax analysis throws the towel when it really cannot determine that some input is in fact a sentence. This works if there is no left recursion, but it is horribly inefficient, and it would usually require to move backwards in the input in order to try some other alternative. Instead, each rule tree object contains a Set, called expect, of terminals, one of which the object wants to see as next tuple — the lookahead — when the object's parse() method is called. This can be seen in the output above and demonstrated in example 4/01 as suggested above. Initially, the function created by the parser() method sets the first lookahead up, and once the shared parse() method for Lit and Token is reached it calls the next() method to move on to the next lookahead. \"Check before you call\" only allows to call parse() on an object if the current lookahead is in the object's expect set. Obviously, terminals expect themselves, i.e., expect for literals and tokens are singleton sets which can be defined during construction. What about the other objects in the rule tree? Naively a sequence should get expect from its first descendant, expect sets from alternative sequences should be merged, rules, braces and brackets, i.e., Rule, Some and Opt, let the superclass Alt of alternative sequences worry about expect, and we are done? Almost. Rule references, i.e., NT, have to take expect from their rules, and there things can get recursive... Therefore, computing expect takes two algorithms: shallow is applied to all rules, one after another, and proceeds along a sequence only far enough to determine expect for the sequence. It will detect (and fail for) left recursion. deep is applied to the start rule, down to all descendants, and along each sequence to the end, to determine expect for all nodes in the entire rule tree. deep cannot fail after shallow succeeded, and it detects rules that cannot be reached from the start rule. All objects representing rules have expect sets. Therefore, all classes representing rules define expect and two methods shallow() and deep(). Representing expect is easy: all literal names are strings, single-quoted, and different, all token names are strings, not quoted, and different. expect is a JavaScript map from a name to true indicating presence in the set. For convenience, this is encapsulated in a dedicated class Set because the built-in class Set currently does not provide the operations needed here. The rule tree classes implement shallow() as follows: class shallow() LitToken set expect to a singleton set with the terminal's name. Alt delegates to all descendant sequences and merges their expect sets. NT delegates to Rule and detects undefined rules. Rule marks, avoids, and complains about recursion, delegates to superclass Alt. Seq proceeds from left to right merging descendant's expect until the descendant is not Opt; note that we require that there will be such a descendant. The remaining classes Opt and Some inherit from Alt. The rule tree classes implement deep() as follows: class deep() Alt needs to delegate and merge again to get to the end of all sequences. NT delegates to Rule again and might detect more undefined rules. Rule marks a rule as reached from the start rule, delegates to superclass Alt again to finish all sequences; recursion cannot happen. Seq proceeds completely from right to left merging descendant's expect while the descendant is Opt; the last expect is set for the sequence. For Lit and Token there is nothing to do. Opt and Some again inherit from Alt. The effects of shallow() and deep() can be seen in example 4/01: Toggle or and press to watch how each algorithm proceeds. Note that the algorithms are only applied once — during grammar checking. shallow() processes each rule, starting with sum: The (shortened) output shows that term has to be analyzed before the result for sum is known: &gt; g = new EBNF.Grammar(grammar, tokens, { shallow: true }) &gt; g.check() sum| Rule shallow { sum| super(sum: term [ { more } ];) shallow { sum| Seq(term [ { more } ]) shallow { sum| NT(term) shallow { term| Rule shallow { ... term| Rule shallow }: '+', '-', Number, '(' sum| NT(term) shallow }: '+', '-', Number, '(' sum| Seq(term [ { more } ]) shallow }: '+', '-', Number, '(' sum| super(sum: term [ { more } ];) shallow }: '+', '-', Number, '(' sum| Rule shallow }: '+', '-', Number, '(' As before, each line of output is prefixed with the rule name which has been called, nested rule calls are indented. Each line contains the class name of the node in the rule tree — or super for a call to the superclass, e.g., Rule to Alt (line 4) — and the rule fragment corresponding to the node. If a line ends with { it traces a call, otherwise it ends with }: and the elements of the resulting set. The output shows that two alternative sequences have to be merged for more(line 11 below): more| Rule shallow { more| super(more: '+' term | '-' term;) shallow { more| Seq('+' term) shallow { more| Lit('+') shallow { more| Lit('+') shallow }: '+' more| Seq('+' term) shallow }: '+' more| Seq('-' term) shallow { more| Lit('-') shallow { more| Lit('-') shallow }: '-' more| Seq('-' term) shallow }: '-' more| super(more: '+' term | '-' term;) shallow }: '+', '-' more| Rule shallow }: '+', '-' The output for sum also shows that deep() is required to compute expect for the sequence in sum hidden under the Some node at right. Here is the (shortened) output from deep: &gt; g = new EBNF.Grammar(grammar, tokens, { deep: true }) &gt; g.check() sum| Rule deep { sum| super(sum: term [ { more } ];) deep { sum| Seq(term [ { more } ]) deep { sum| Opt([ { more } ]) deep { sum| Seq({ more }) deep { sum| Some({ more }) deep { sum| Seq(more) deep { sum| NT(more) deep { more| Rule deep { ... more| NT(term) deep { term| Rule deep { ... term| Rule deep }: '+', '-', Number, '(' more| NT(term) deep }: '+', '-', Number, '(' ... more| Rule deep }: '+', '-' sum| NT(more) deep }: '+', '-' sum| Seq(more) deep }: '+', '-' sum| Some({ more }) deep }: '+', '-' sum| Seq({ more }) deep }: '+', '-' sum| Opt([ { more } ]) deep }: '+', '-' sum| NT(term) deep { term| Rule deep { term| Rule deep }: '+', '-', Number, '(' sum| NT(term) deep }: '+', '-', Number, '(' sum| Seq(term [ { more } ]) deep }: '+', '-', Number, '(' sum| super(sum: term [ { more } ];) deep }: '+', '-', Number, '(' sum| Rule deep }: '+', '-', Number, '(' The computation happens in lines 7 to 22 above. In a Seq, deep() proceeds from right to left, i.e., in this case more is entered in line 10 before sum references term. However, more depends on term, i.e., term will be processed in lines 14 to 16 before more is done in line 19. Later, when sum needs term in line 25, deep() does not have to enter the rule a second time. Of course, deep() does not change expect for any of the rules themselves — that has been computed by shallow(). Ambiguity Clearly, expect is essential for the \"check before you call\" policy of calling a parse() method only if the callee expects the next input symbol. Unfortunately, this is not the whole story as example 4/02 demonstrates. Here, the grammar has a new start rule sums which should allow input to consist of more than one sum of signed numbers: sums: { sum }; sum: term [{ more }]; more: '+' term | '-' term; term: [ '+' | '-' ] Number | '(' sum ')'; The following input contains three sums: 1 - (2 + - 3) 4 + 5 - 6 - 7 It looks as everything works just fine: Toggle to avoid the ambiguity check and represent the grammar by pressing . Then toggle and and press to watch how syntax analysis proceeds. There is voluminous output and there are no error messages. Chapter five will explain why the output contains so many brackets. However, upon closer inspection (and considerable pruning) the output reveals a surprise: &gt; g.config.lookahead = true &gt; g.config.parse = true &gt; g.parser().parse(program) parser lookahead: (1) \"1\" Number sums| Rule parse { ... sum| Rule parse { ... ')' lookahead: (2) \"4\" Number ... sum| Rule parse }: [ [ null '1' ] [ [ [ [ '-' [ '(' [ [ null '2' ] [ [ [ [ '+' [ [ '-' ] '3' ] ] ] ] ] ] ')' ] ] ] ] ] ] ... sum| Rule parse { ... more| Rule parse { ... term| Token(Number) parse { Number lookahead: (3) '-' term| Token(Number) parse }: '5' ... more| Rule parse }: [ '+' [ null '5' ] ] 1 - (2 + - 3), the first sum, is recognized as before (line 11), and 4 + 5, the second sum, is found as well. Unfortunately, more is happy to see '-' as a lookahead and continues to gobble up - 6 - 7 as part of a longer second sum: ... sum| Rule parse }: [ [ null '4' ] [ [ [ [ '+' [ null '5' ] ] ] [ [ '-' [ null '6' ] ] ] [ [ '-' [ null '7' ] ] ] ] ] ] Surprise: expect is consulted before descendants of Some or Opt are asked to parse(), but the process is greedy, i.e., whatever follows in a sequence containing Some or Opt only gets a chance if those two let go. A grammar is called ambiguous if different parse trees can be constructed for the same sentence. In this example, the rule sum could succeed three times 1 - (2 + - 3) 4 + 5 - 6 - 7 as the three lines of input might suggest. However, the three lines are just one long string — white space is skipped by lexical analysis — and the output above shows that sum can recognize 4 + 5 - 6 - 7 as a longer second sum. Overall, there are two different parse trees, with two or three top-level rule:sum nodes. This grammar is ambiguous — a typical issue when two arithmetic expressions with signed numbers can follow each other. It is easy to repair, check out example 4/03. will complain about ambiguities — unless suppresses the follow() and check() algorithms which normally are part of preparing the grammar. We have ambiguity issues if two or more alternative sequences have overlapping expect sets, or if braces, i.e., a Some object, and their successor in a sequence have overlapping expect sets, or if brackets, i.e., an Opt object, and their successor in a sequence have overlapping expect sets. Another ambiguity issue would arise if a sequence had a way to avoid getting to any terminal — in this case the expect of the sequence could overlap with whatever can follow the sequence. This is why our grammar definitions do not permit a sequence to only consist of brackets. In all these cases \"check before you call\" has a choice within the overlaps, and blind trust in the closest expect set is not advisable. follow() How do we check for these ambiguities? Overlapping expect sets among alternative sequences are easy to find, but the other cases involve two successive items in a sequence. Unfortunately, already in example 4/02 of multiple sums sums: { sum }; sum: term [{ more }]; more: '+' term | '-' term; term: [ '+' | '-' ] Number | '(' sum ')'; it is not obvious which expect sets overlap. Rather than hunting for successive items, the follow() algorithm computes an individual follow set for each object in the grammar rules. The set contains all terminals which can directly follow in the input after whatever the object itself recognizes during syntax analysis. Given the follow set, we can reason about ambiguities on a per-object basis. Just like shallow() and deep(), the follow() algorithm is implemented as a method in the various classes which are used to represent grammar rules. The method is called for an object with the Set of all terminals that can follow the object as a parameter. The first step is that nothing can follow the start rule — at least at the top level. Therefore we call follow() for the start rule with an empty set to get things started. class follow(set) Alt sends the incoming set to all descendant sequences because the set can follow each descendant. Some adds its own expect set to the incoming set and sends the result to the descendant sequences because each descendant can be repeated and thus follow any other. Seq processes all descendants from right to left: it sends the current set to a descendant and sends its expect to the next one — moving from the end to the beginning of the sequence. If the current descendant is an Opt, its expect is merged with the current set and sent to the predecessor because Opt's expect and Opt's follow, i.e., the current set, both, can follow the predecessor. NT adds the parameter to the referenced rule, but only if that changes something. Rule and Opt inherit from their superclass Alt. There is nothing to do for Lit and Token because they don't require checking. NT is tricky: obviously it has to send the parameter to the referenced Rule because all the terminals in the incoming set can follow the rule. But at this point, e.g., the start rule might find out that there are more terminals which can follow and the entire process has to start over. Therefore, NT will only send the parameter to the referenced rule if the parameter really is bigger than the current follow of the referenced rule. This prevents infinite recursion because all sets can at most contain the finite number of terminals which the grammar has. It should be noted that there is a more efficient way to compute follow: If the immediate follow relationship between any two items in all rules is noted in a matrix, Warshall's algorithm is an efficient way to compute the \"infinite\" product of that matrix with itself and the resulting matrix describes the so-called transitive closure of the follow relation, which is just what we need. Brackets and braces, however, complicate the specification of the first matrix. check() The expect sets enable syntax analysis to \"check before you call\" and avoid trial and error. The follow sets are used once during grammar preparation to ensure that \"check before you call\" always gets a unique answer, i.e., that syntax analysis cannot get greedy and must produce a unique parse tree. A context-free grammar is called LL(1) if syntax analysis can be performed by processing input left to right, looking for the left-most derivation, i.e., starting with the start rule of the grammar, and with one terminal lookahead. The approach is also called top-down because it starts with the root of the syntax tree, i.e., the start rule of the grammar. The following check() determines if a grammar is LL(1). It is based on the expect and follow sets and is again distributed over the classes for the objects representing the grammar rules. class check() Seq each descendant must be checked. Alt the alternatives' expect sets must not overlap. Opt expect and follow must not overlap. Some expect and follow must not overlap. NT does nothing(!) because check() is applied to every rule, not just recursively to the start rule. In Alt, check() is very simple to implement: an Alt node has its own expect set which is the union of all alternatives. Therefore, the sum of the number of elements in the alternatives' expect sets and the number of elements in the Alt node's own expect set must be the same. Ambiguity Revisited An ambiguous grammar might still be useful — as long as it recognizes only what is intended. Example 4/04 illustrates an if statement: stmt: Text | if; if: 'if' Text 'then' stmt [ 'else' stmt ] 'fi'; This grammar is not ambiguous and it recognizes for example the following program: if a then if b then c else d fi fi Press to represent and check the grammar and press to perform syntax analysis. The output can be reformatted [ [ 'if' 'a' 'then' [ [ 'if' 'b' 'then' [ 'c' ] [ 'else' [ 'd' ] ] 'fi' ] ] null 'fi' ] ] and shows that else d is recognized as part of the inner if statement. It turns out that this is due to the fact that in the grammar above 'if' and 'fi' are balanced. Example 4/05 illustrates a more typical if statement without fi: if a then if b then c else d This grammar is reported to be ambiguous: Press to represent and check the grammar. Toggle to suppress ambiguity checking, press to represent and check the grammar again, and press to perform syntax analysis. Again, the output can be reformatted for clarity [ [ 'if' 'a' 'then' [ [ 'if' 'b' 'then' [ 'c' ] [ 'else' [ 'd' ] ] ] ] null ] ] Obviously, the output no longer contains the literal 'fi' but it is otherwise unchanged! Recognition is greedy, i.e., if it can accept an else because there is an if to be continued it will not check if there might be an outer if. Fortunately, this is how programming languages like to interpret else clauses, and in this particular case an ambiguous grammar does the right thing. Quick Summary Syntax analysis receives terminals from lexical analysis and determines if the input is a sentence conforming to a grammar. Grammar rules can be viewed as functions performing recognition, and syntax analysis starts \"top-down\" by calling the start rule of the grammar. A grammar rule can be represented as a tree of nodes, i.e., objects of a few classes such as Rule. Algorithms, such as syntax analysis, are distributed as methods over these classes, such as parse(). Top-down, deterministic syntax analysis is based on the principle of \"check before you call\": parse() can only be called on a node if the lookahead, i.e., the next input symbol, matches what the node expects. \"check before you call\" is possible if a grammar is LL(1) (and therefore not ambiguous). This needs to be checked once when the rules are represented as trees. The algorithms shallow() and deep() compute for each tree node the set expect of terminals which can be in the lookahead. The algorithm follow() computes for each tree node the set of terminals that can follow the input that the node recognizes. The algorithm check() compares these sets for each tree node and determines if a grammar is LL(1) and can be used for this style of syntax analysis. Ambiguity is not always a bad thing; however, recognition based on an ambiguous grammar would have to be very carefully tested before it can be accepted for a project. Wherever classes and methods are mentioned in this book they are linked to the documentation and from there to the (syntax-colored) source lines. Programming Note: Set Implementing specific set operations for LL(1) checking and syntax analysis in JavaScript (rather than using the built-in Set class) turns out to be very easy. A Set is represented as an object with terminal names as properties which have an arbitrary value, e.g., true, just to denote their presence in the set. Note that token and literal names cannot overlap because literal names are single-quoted and tokens are not. match() uses the operator in to check if a terminal belongs to a set. Object.assign imports the elements of a second set. Object.keys returns the terminal names as an array, e.g., to count how many belong to the set. every can be used to check if one set contains another: Object.keys(other.set).every(key =&gt; key in this.set) reduce can be used to create a set of elements belonging to two sets: Object.keys(this.set).reduce((result, key) =&gt; { if (key in other.set) result.set[key] = true; return result; }, new Set()); One word of caution: these sets are objects and, therefore, passed by reference. A new set has to be constructed, e.g., when a Some node adds its own expect and follow sets to send them to the descendants... Programming Note: trace() A prudent approach to programming is to assume a priori that something will go wrong and to always instrument code so that algorithms can be observed. Unfortunately, this is likely to hide the actual algorithm behind obscure scaffolding which should not be there for production runs, e.g., if (debug) console.debug('some label', 'about to compute'); // compute something here if (debug) console.debug('some label', 'something to see'); In the object-oriented approach to syntax analysis described here, algorithms such as parse(), shallow(), deep(), follow(), and check() are distributed as methods of the classes involved in representing grammar rules. The job of each method is quite small but the methods call each other recursively across the classes and the return values get more and more complicated. Example 4/01 illustrates how instructive it is to see method calls and return values. Toggle some of , , and , then press and watch how the expect and follow sets are put together. Next toggle , then press and watch how the parse() methods call on each other. Tracing function calls and return values amounts to function composition: the algorithm is carried out by a method, a tracer proxy announces the method call and arguments, calls the algorithm method, reports the end of the method call and the result values, and returns the method's results. Methods are functions stored in a class' prototype, i.e., a method can be cached and replaced by a tracer proxy which informs about and internally calls the cached method, e.g. const cache = class_.prototype.method; // cache class_.prototype.method = function (...arg) { // proxy console.debug('about to call', class_.name, cache.name); const result = cache.call(this, ...arg); console.debug('result:', result); return result; } trace() manages caching and reporting for the essential algorithms of syntax analysis. Previous: 3. Scanning Input Next: 5. Translating Sentences × Search results Close "},"tutorial-05-lists.html":{"id":"tutorial-05-lists.html","title":"Tutorial: 5. Translating Sentences","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 5. Translating Sentences What's in a Parse Tree? What's with the Brackets? Chapter four explained that syntax analysis tries to build a parse tree to show that a sequence of input terminals is a sentence conforming to a grammar. Output from the examples suggests that, indeed, something gets built, and it contains strings related to the input terminals. However, the output seems to consist mostly of brackets, and it is very hard to see that the output models the parse tree as very deeply nested JavaScript lists. This chapter explains how the lists come about and how syntax analysis can be augmented with Action methods to translate input into something more convenient. Lists Trace output from example 5/01 demonstrates that the parse() method of the Parser object generated by the grammar's parser() method collects a list containing the input strings from the which correspond to the terminals in the grammar rule. Here is a sequence of eight examples, 5/01 through 5/08, which illustrate how rules, brackets, and braces collaborate to create nested lists. Each time press to represent and check the grammar; toggle and press to watch how syntax analysis builds the nested lists. grammar output example sum: Number '+' Number; [1 + 2] 01: sum creates a list sum: term '+' Number;term: Number; [[1] + 2] 02: term creates a list sum: term '+' term;term: Number; [[1] + [2]] 03: term creates lists sum: Number [ '+' Number ]; [1 null][1 [+ 2]] 04: brackets createnull or a list sum: term [ '+' term ];term: Number; [[1] null][[1] [+ [2]]] 05: term creates lists sum: Number { '+' Number }; [1 [[+ 2]]][1 [[+ 2] [+ 3]]] 06: braces create list oflists, one inner list periteration sum: term { '+' term };term: Number; [[1] [[+ [2]]]] 07: term creates lists sum: Number { more };more: '+' term;term: Number; [1 [[[+ [2]]]]] 08: more creates anextra list Terminals produce strings in the nested lists. In the actual output on the practice page this is emphasized because strings are quoted there; in the output column above the quotes had to be omitted to save space. In summary: The parse() algorithm calls the parse() methods for objects selected during a top-down traversal of the rule trees of the grammar. By default, most of these methods produce lists. The fundamental branch node in a rule tree is a Seq object which always produces a list containing the values which the branch node's subtrees produce. Alternatives show up in a rule tree as branch nodes represented as Rule, Opt, and Some objects. A Rule selects one of it's Seq descendants which produces a list for the rule's alternative matching the input. The list will contain exactly one entry for each item (terminal, rule reference, brackets, or braces) in the selected sequence. Brackets are represented as an Opt object in the rule tree which again has Seq descendants for the alternatives. If an alternative of Opt (i.e., brackets) matches the input, it's Seq will produce a list, otherwise the brackets themselves produce null. Braces are represented as a Some object in the rule tree which again has Seq descendants for the alternatives. Some will match at least one alternative, but it might be able to match several times in a row — the same or a different alternative. Therefore, Some (i.e., braces) will return a list of one or more inner lists, one for each iteration. Each inner list corresponds to one matched alternative and it is produced by the Seq object representing the alternative in the rule tree. The Parser's parse() method returns the nest of lists produced by the rule tree while syntax analysis recognizes a sentence. List nesting is completely under control of the grammar and the list nesting principles described above are uniform and relatively simple; however, as the arithmetic expressions in example 2/12 or a simplified version just for sums in example 4/03 showed, while this result of syntax analysis is well-formed it is usually so overwhelming that it hardly invites further processing. Action Methods Fortunately, there is a way to interact with list creation whenever a rule completes recognition. As discussed in chapter four, syntax analysis is performed by the Parser's parse() method which calls on the parse() methods of the various classes involved in representing a grammar as a rule tree. Each grammar rule can be considered to be a function which has to recognize a part of the input which is described and structured according to the rule's right-hand side. This function is the parse() method associated with the Rule object representing the rule in the grammar's rule tree. As described above, by default this parse() method creates a list containing whatever the descendants' parse() methods return. The \"check before you call\" policy ensures that there is no backing up and re-creating — recognition cannot be undone. The real power of considering a grammar rule as a function stems from the fact that each rule can be associated with an Action method written in JavaScript which is called when the parse() method is done collecting, which receives the list collected by parse() as individual arguments, and which returns a value which parse() returns in place of the collected list. Thus far we have not specified any Action methods — this is why we have seen deeply nested lists as results of syntax analysis. The Parser's parse() method accepts an optional argument: a (singleton) object with methods names equal to some rule names, or a class which the parser instantiates to create such an object; the constructor is called with a reference to the parser to facilitate error reporting. Example 5/09 contains different Action methods to manipulate a sequence of non-whitespace characters using the following grammar: chars: { char }; char: Char; For example, the Action methods char (ch) { return ch; } chars (some) { return some.reduceRight((rev, list) =&gt; rev += list[0], ''); } reverse the order of the characters of the palindrome .ein.Esel.lese.nie! Press to represent and check the grammar, and press to see the output. Uncomment one action for char and/or one for chars in the to see how the output changes. Toggle and/or and press to watch how input is found and converted by the Action methods. In particular, if there is no Action method for char the trace shows that the rule returns a list containing a single character which the Action method for chars concatenates to a string... Erase either the methods or everything in the and press to see that without action methods the lists are generated. Example 5/10 with the same grammar shows how a property in the class can be used to communicate among the Action methods: class Actions { #queue = []; char (ch) { this.#queue.unshift(ch); } chars () { return this.#queue.join(''); } } Initially, this.#queue is an empty array. Syntax analysis proceeds from the start rule of the grammar down to the terminal nodes which collect the input terminals from left to right. unshift() stuffs arguments in front of a target array and returns the new length (which is not used in this case). Because of unshift() the action method for char stuffs the non-whitespace input characters into the array in reverse order. The action method for the start rule chars returns the collected array elements as a string. The following chapters illustrate with a few larger examples what Action methods can do: we interpret arithmetic and compile a little language in chapter six, we perform some type checking and add functions and block structure in chapter seven, and we implement first-order functions in chapter eight. Finally, we create a parser generator in chapter nine which implements lexical and syntax analysis for grammars — and which we have used all along. Error Checking Rules and Action methods are very loosely coupled but by default the parser tries to check the number of values collected by parse() against the number of parameters defined for the action method: The test is omitted if the action method has no parameters. Rest parameters affect the count of expected parameters; in particular, the test is omitted if the entire parameter list is one rest parameter. The test can be suppressed by setting no args. Idioms for Actions Each rule presents structured data to it's Action method. The Action method for the rule will receive one argument for each top-level item in the rule. Consider the grammar in example 5/11: rule: 'literal' Number ref; ref: Number; There are two ways to write the parameter list for the Action method, namely using rest parameter syntax or using individual parameter names. rule (...val) { /* ... */ } With the rest parameter syntax the array val will contain three values because there are three items in rule: val[0] is the string value 'literal' itself, parseInt(val[1], 10) is the decimal number computed from the string matched by the token Number, and val[2] contains the value returned by the Action method, if any, for the referenced rule ref, or it contains the list of arguments which would have been presented to the referenced rule's Action method. A more convenient parameter list for an Action method for rule uses different parameter names for the different argument values: rule (literal, number, ref) { /* ... */ } and in this case literal is the string value literal itself, parseInt(number, 10) is the converted Number, and ref contains the value returned by the Action method, if any, for the referenced rule ref, or it contains the list of arguments which would have been presented to the referenced rule's Action method. Note that if there is no Action method for a rule, the rule returns a list containing the collected values. Without an Action method the rule ref above collects a string matched by the token Number and returns it in an array. Therefore, if there is no Action method for ref, the Action method for rule can compute the decimal value as parseInt(ref[0], 10). Consider the following Action methods for rule and ref: rule (literal, number, ref) { /* ... */ } ref (number) { return parseInt(number, 10); } Now the Action method for rule receives the decimal value in the parameter ref because the rule for ref has an Action method which returns that value. Brackets and braces in a rule amount to unnamed rules which cannot have Action methods, i.e., they contain alternatives which in turn contain sequences. If such a sequence matches input it collects a list. The following sections explain how to drill down to access the values. [ optional ] — maybe The following rule accepts the string literal, optionally followed by either maybe or not, and either of those followed by a number, check example 5/12: rule: 'literal' [ 'maybe' Number | 'not' '!' Number ]; With explicit parameter names — one per top-level item in the rule — rule (literal, opt) { /* ... */ } here is how to get to the pieces: literal will contain the string value literal and opt will contain a list. opt[0] will contain one of the strings maybe or not, and opt[1] or opt[2], respectively, will contain the string value collected for the Number. However, opt receives the result produced by one of the alternatives in the brackets, and that need not match any input — in which case opt is null. Therefore, an Action method to display the decimal values in the output area could be class Actions { // rule: 'literal' [ 'maybe' Number | 'not' '!' Number ]; rule (literal, opt) { if (opt) switch (opt[0]) { case 'maybe': puts(opt[0], parseInt(opt[1], 10)); break; case 'not': puts(opt[0], parseInt(opt[2], 10)); } } } To switch or not to switch ... Lexical analysis partitions the input into terminals. Syntax analysis collects the terminals in rules. It is inefficient if Action methods have to use switch or if to deal with terminal strings again. Example 5/13 accepts the same input as example 5/12 but two rules have been added to simplify the corresponding Action methods: class Actions { // rule: 'literal' [ maybe | not ]; rule (literal, opt) { if (opt) puts(opt[0]); } // maybe: 'maybe' Number; // returns Number value maybe (m, number) { return parseInt(number, 10); } // not: 'not' '!' Number; // returns Number value not (n, exclamation, number) { return parseInt(number, 10); } } Brackets and braces can contain alternatives. It is often easier to make each alternative a separate rule to simplify the Action methods and avoid inspecting terminals explicitly. { some } — at least once Example 5/14 contains a typical grammar for a list of statements, each terminated by a semicolon: list: { item ';' }; item: dec | hex; dec: 'dec' Decimal; hex: 'hex' ref; ref: Hex; list accepts one or more numbers, each is preceded by dec or hex and followed by a semicolon. There are tokens for decimal and hexadecimal numbers; note that the token patterns overlap — hence the prefixes in the rules: { Decimal: /[0-9]+/, Hex: /[0-9a-fA-F]+/ } Press to represent and check the grammar, erase the , and press to see the nested lists. Why does the input hex0; cause an error? Without Action methods the input dec 10; hexBad; dec 20; produces [ [ [ [ [ 'dec' '10' ] ] ';' ] [ [ [ 'hex' [ 'Bad' ] ] ] ';' ] [ [ [ 'dec' '20' ] ] ';' ] ] ] If there are no Action methods the outermost list (lines 1 and 7) is produced by the sequence for list. The next list (lines 2 and 6) is produced by the braces (some) and contains one list for each iteration — the outer lists in lines 3 through 5. The inner lists in lines 3 and 5 are produced by the sequence for dec or hex and item adds one more list to these. Bad is in one more list, produced by the sequence for ref (line 4). Trick question: Why are the blanks following dec in the program necessary, whereas Bad can immediately follow hex? With explicit parameter names here is how to untangle a pair of braces using Action methods: class Actions14 { /** `dec: 'dec' Decimal ';';` returns value */ dec (_, decimal) { return parseInt(decimal, 10); } /** `hex: 'hex' ref ';';` returns value */ hex (_, ref) { return parseInt(ref[0], 16); } /** `item: dec | hex;` returns `[ value ]` `list: { item ';' };` displays value ... */ list (some) { puts(... some.map(list =&gt; list[0][0])); } } dec() and hex() decode the numbers. There is no need for an Action method for ref if hex() extracts the input string from the list returned from the ref rule by default (line 6). Reload the example and press to represent and check the grammar. Toggle , and press to see how the numbers are extracted. list() is now concerned with a list of lists which contain one number and a semicolon each. map() is used to convert this nest into a simple list and the spread syntax converts that into individual arguments for puts() to display (line 10). [{ many }] — zero or more times Example 5/15 is very similar, but for the fact that the statements are separated by commas. list: item [{ ',' item }]; item: dec | hex; dec: 'dec' Decimal; hex: 'hex' ref; ref: Hex; The program dec 10, hex Bad, dec 20 produces &gt; run = g.parser().parse(program, actions) [ 10 2989 20 ] With explicit parameter names here is how to untangle a comma-separated list of items, i.e., one dec or hex item followed by zero or more items, with a comma preceding each item but the first: class Actions15 extends Five.Actions14 { /** `item: dec | hex;` returns `[ value ]` `list: { item ';' };` returns `[ value ... ]` */ list (item, many) { return item.concat(many ? many[0].map(list =&gt; list[1][0]) : []); } // alternative solution // list (item, many) { // return (many ? many[0] : []).reduce( // (result, list) =&gt; (result.push(list[1][0]), result), item); // } } Press to represent and check the grammar. Toggle , and press to see how the numbers are extracted. item is defined by a separate rule (comment in line 2); without an Action method for item the parameter item (line 4) will receive a list containing the first value. This list is concatenated either with a list of further values or with an empty list (which is discarded). If the parameter many (line 4) is not null, it is a list containing the list of values for the alternatives created by the braces. many[0] is the inner list and map() converts that into a list of values that can be concatenated with the first value. The callback for map() (line 5) each time receives a list produced by the sequence ',' item and list[1][0] drills down to the value in the second element of that list. An alternative solution employs reduce() (lines 9 to 12): If the parameter many is null, i.e., if there is only one item, reduce() is applied to an empty list and returns the start value, i.e., the parameter item. Otherwise, each time the callback function receives a list, extracts a value, and appends that to the item parameter. The result is the same; however, the solution with concat() works on list lengths known a priori whereas the alternative solution dynamically extends the list passed as a parameter, i.e., one would opt for the solution with concat(). Example 5/16 has the same grammar, tokens, and program as example 5/15, but this time the list action returns the sum of the numbers, i.e., the list of items has to be processed into a single result: class Actions16 extends Five.Actions14 { // convoluted solution // list (item, many) { // return item.concat(many ? many[0].map(list =&gt; list[1][0]) : []). // reduce((sum, value) =&gt; sum + value, 0); // } /** `item: dec | hex;` returns `[ value ]` `list: [{ ',' item }];` returns `value +...` */ list (item, many) { return (many ? many[0] : []).reduce( (result, list) =&gt; result += list[1][0], item[0]); } } A convoluted solution would use map() as before to create a list of values (line 4) and follow up with reduce() to produce the sum (line 5). In this situation it is better to only apply reduce(), either to the list of additional items or to an empty list (line 11), initialize with the first value and add the others on the fly (line 12). This avoids unneccesary dynamic list creation. Extending Action Classes The last three examples in this chapter share some grammar rules and the corresponding Action methods: example 5/14 defines item, dec, hex, and ref, and examples 5/15 and 5/16 can just extend the action class defined for example 5/14 to inherit those methods and only overwrite the Action method for list where the corresponding rule has been changed and/or a different algorithm should be applied. The practice page supports this as follows: If class names end in digits, such as Actions14 in example 5/14, the classes are exported from modules which are part of the environment provided by the practice page. The module names are global, e.g., Five for chapter five, so that, e.g., example 5/15 can inherit methods: class Actions15 extends Five.Actions14 { ... } It should be noted, however, that overwriting does not remove code. For example, Actions15 contains it's own list method and super.list(), i.e., the method from Actions14, is still available, even if it is not used. Chapter eleven discusses how with careful planning mix-ins can be used to avoid dead code. The following chapters will rely on modules in order to focus on the Action methods that are new or overwritten in a sequence of related examples. (Unfortunately, the practice page will not copy any other text — rules, tokens, or programs — from one example to another...) Error Checking A subclass inherits methods from the superclass and it can delegate to a method in the superclass using super in place of this. Argument checking as described above applies implicitly if an action method is inherited, and it is explicitly applied if a call such as super.method(arg1, .., argn) is replaced by this.parser.call(this, super.method, arg1, .., argn) using the method call() defined in the parser — assuming that the action object stores a reference to parser which is provided during construction. Quick Summary The Parser's parse() method can be called with a class or a (singleton) object with Action methods matched to the rule names in the grammar. Grammar rules plus their Action methods, if any, are applied to the input. Calls proceed top-down, beginning with the start rule. Once a rule matches input an Action method is selected which has the same name as the rule. The Action method receives arguments corresponding to the alternative of the rule which matched the input, exactly one argument for each item (terminal, rule reference, brackets, or braces) in the alternative. Each set of brackets in the alternative produces either null or a list of values for the alternative in the brackets which matches the input. Each set of braces in the alternative produces a list which contains one inner list of values for each iteration. The iteration itself produces the (inner) list for the alternative in the braces which matches input during this iteration. The result value of the Action method is received by the parent rule's Action method or returned by the Parser's parse() method. If there is no Action function the result value is a list of all argument values which the Action method would have received. Previous: 4. Recognizing Sentences Next: 6. Compiling Little Languages × Search results Close "},"tutorial-06-compile.html":{"id":"tutorial-06-compile.html","title":"Tutorial: 6. Compiling Little Languages","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 6. Compiling Little Languages Interpret Now, Compile for Later Functions and a Stack Machine Chapter two discussed how to write grammars and example 2/12 presented a typical grammar for a comma-separated list of arithmetic expressions: list: sum [{ ',' sum }]; sum: product [{ '+' product | '-' product }]; product: signed [{ '*' signed | '/' signed }]; signed: [ '-' | '+' ] term; term: Number | '(' sum ')'; Chapter three and chapter four explained that a grammar, token patterns, and the classes of the EBNF module are all it takes to implement lexical and syntax analysis for sentences conforming to the grammar, in this case to recognize comma-separated lists of arithmetic expressions. Chapter five introduced Action methods (which we will just call actions from now on) to interact with syntax analysis and produce useful output rather than deeply nested lists. This chapter looks at actions to evaluate arithmetic expressions or to translate them into different representations more suitable for interpretation, etc. Many examples reuse actions; all classes are available from the module Six which is built into the practice page. Arithmetic expressions are at the core of programming languages. This chapter also presents a grammar for a little language, actions to compile the language into JavaScript functions, and actions to compile the language for execution on a stack machine which will be simulated in JavaScript. Immediate Evaluation It makes sense to add a few more rules to the grammar above because they provide hooks for actions. For example, there is no point in letting syntax analysis distinguish addition and subtraction, only to have to check for + or - a second time when it comes to evaluation. Example 6/01 recognizes the same list of arithmetic expressions: Press to represent and check the grammar and press to perform syntax analysis; compare to the original grammar in example 2/12 to see that the additional rules result in more deeply nested lists. Here is the modified grammar: list: sum [{ ',' sum }]; sum: product [{ add | subtract }]; add: '+' product; subtract: '-' product; product: signed [{ multiply | divide }]; multiply: '*' signed; divide: '/' signed; signed: [ '-' ] term; term: number | '(' sum ')'; number: Number; The goal is to immediately evaluate arithmetic expressions, i.e., each action should return the value which the corresponding rule has recognized. This results in obvious actions for the last three rules: class Eval02 { // list: sum [{ ',' sum }]; /** `sum: product [{ add | subtract }];` */ sum (product, many) { puts(g.dump(product)); } // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; /** `signed: [ '-' ] term;` */ signed (minus, term) { return minus ? - term : term; } /** `term: number | '(' sum ')';` */ term (...val) { return val.length == 1 ? val[0] : val[1]; } /** `number: Number;` */ number (number) { return parseInt(number, 10); } } Because of the placeholder for sum (line 5) very simple expressions can already be tested in example 6/02: Press to represent and check the grammar and press to perform syntax analysis and invoke the actions. Toggle and press again to see how the values are computed by the actions. Why is so much output undefined? Why are some numbers followed by commas in the output? The next three actions are tricky but representative for any evaluation based on this kind of a grammar: class Eval03 extends Six.Eval02 { // list: sum [{ ',' sum }]; // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; /** `product: signed [{ multiply | divide }];` */ product (signed, many) { return (many ? many[0] : [ ]). reduce((product, list) =&gt; list[0](product), signed); } /** `multiply: '*' signed;` */ multiply (_, right) { return left =&gt; left * right; } /** `divide: '/' signed;` */ divide (_, right) { return left =&gt; left / right; } // signed: [ '-' ] term; // term: number | '(' sum ')'; // number: Number; } Multiplication and division are left-associative operations, i.e., they are evaluated from left to right by reduce() in the action for product (line 10 above). Therefore, the multiply and divide actions have to return functions which will take a left argument, combine it with the right argument which the multiply and divide rules have recognized and evaluated, and return the result of the computation (lines 14 and 17). The product action gets a first signed value which the signed rule has already evaluated, and it gets many of these functions for the remainder of the chain of products (line 9). The chain has to be processed as discussed in the Idioms in chapter five using reduce(): If there are no functions, the first signed value is the result. Otherwise the callback function (line 10) is applied from left to right and each time applies a multiplication or division to the previous product, starting with signed. Again, it might be a good idea to try this stage in example 6/03: Press to represent and check the grammar and press to perform syntax analysis and invoke the actions. It seems to work at first, but 2 / (3*4) produces the unexpected outputs 12 and NaN. Toggle and press again to see how the values are computed. Where do the two lines of output 12 and NaN come from? Which action has to be repaired? Check out the complete immediate expression evaluation in example 6/04. Addition and subtraction use the same pattern as multiplication and division: class Eval04 extends Six.Eval03 { /** `list: sum [{ ',' sum }];` */ list (sum, many) { puts(sum); if (many) many[0].forEach(seq =&gt; puts(seq[1])); } /** `sum: product [{ add | subtract }];` */ sum (product, many) { return this.product(product, many); } /** `add: '+' product;` */ add (_, right) { return left =&gt; left + right; } /** `subtract: '-' product;` */ subtract (_, right) { return left =&gt; left - right; } // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: number | '(' sum ')'; // number: Number; } sum is used recursively inside parentheses, i.e., it needs to return a value and it cannot output the final result. Therefore, the action for the start rule has to display each top-level sum (lines 3 to 6 above). Functional Evaluation Returning functions for some arithmetic operations suggests that the entire evaluation could be delayed — every action returns a function, the result is stored as an \"executable\" and can be evaluated (executed) several times over. This is more useful if simple variables are added to the grammar in example 6/05. There has to be a token for names: Name: /[a-z]+/ There has to be a rule to recognize a name name: Name; and the rule for term has to recognize a name just like a number: term: number | name | '(' sum ')'; The action for name (lines 27 to 30 below) has to return a value. For now, a local object memory maps names to values (line 29) and it is generated if needed (line 28). class Functions05 extends Six.Eval04 { #parser; // for error messages get parser () { return this.#parser; } constructor (parser) { super(); this.#parser = parser; } // list: sum [{ ',' sum }]; /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ // arg [1] [3] [0] [1] sum (... arg) { if (arg.length &lt; 4) return this.parser.call(this, super.sum, arg[0], arg[1]); if (!this.memory) this.memory = { }; return this.memory[arg[1]] = arg[3]; } // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: number | name | '(' sum ')'; // number: Number; /** `name: Name;` returns value or `0` */ name (name) { if (!this.memory) this.memory = { }; return name in this.memory ? this.memory[name] : 0; } } This is only useful if there is a way to assign a value to a name. Therefore, the rule for sum is modified as shown in the comment (line 9 above). The action for sum defers to the superclass for simple sums (line 12) or it creates memory if needed (line 13) and performs the assignment (line 14). Check this stage out in example 6/05: Press to represent and check the grammar and press to evaluate the expressions in the . let x = 3, (x + 1) / (y - 2) * 3, y + (x + 1) / ((let y = 1) - 2) * 3 The assignment in line 1 returns 3. So far, y is undefined, i.e., zero; therefore, line 2 produces -6. In line 3, y is set to 1 but only once the denominator is evaluated, i.e., the output is -12 and not -11. At this point, expressions are evaluated as they are recognized and the top-level list action returns undefined to the Parser's parse() method which returns it to be shown in the output area. If every action returns a function rather than a value we can execute the top-level function more than once. This is interesting if there is input during execution; therefore, example 6/06 adds input as a \"reserved\" variable name, optionally with a default value: term: input | number | name | '(' sum ')'; input: 'input' [ Number ]; Here are the first few modified actions which return functions: class Functions06 extends Six.Functions05 { // sum: product [{ add | subtract }]; // add: '+' product; // subtract: '-' product; // product: signed [{ multiply | divide }]; // multiply: '*' signed; // divide: '/' signed; // signed: [ '-' ] term; // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` returns fct */ input (_, number) { const dflt = String(number !== null ? number[0] : 0); return () =&gt; parseInt(prompt('input', dflt), 10); } /** `number: Number;` returns fct */ number (number) { const result = parseInt(number, 10); return () =&gt; result; } /** `name: Name;` returns fct */ name (name) { return memory =&gt; name in memory ? memory[name] : 0; } } The number action returns a function returning a constant value. The action optimizes and converts the string only once (line 19 above). The returned function takes advantage of a closure (line 20). The name action returns a function which checks memory at run time, i.e., it expects to receive memory when the executable is run (line 25). Finally, the input action returns a function which invokes prompt() and converts the resulting string to a number if possible (line 14); parseInt() returns NaN if it cannot convert. The term action can be inherited because now it juggles functions: the action of every descendant of the rule must deliver a function and the term action picks it out of the list produced by recognition. If sum and product recognize a single descendant they will just pass on whatever the descendant's action returns, i.e., if sum is the start rule the actions can be inherited and one simple expression such as input will be compiled into a JavaScript function. Again, it might be a good idea to try this stage in example 6/06: Press to represent and check the grammar and press to perform syntax analysis and invoke the actions, i.e., to compile simple programs such as 10 or (input). Press to execute the compiled program. Note that a program consisting only of a variable name such as x is compiled into a function which expects memory as an argument, i.e., execution with will fail: &gt; run = g.parser().parse(program, actions) memory =&gt; name in memory ? memory[name] : 0 &gt; run() memory is not an Object. (evaluating 'name in memory') Example 6/07 converts the remaining actions so that they return functions. The action for signed is patterned after those for term and name: class Functions07 extends Six.Functions06 { // ... signed (minus, term) { return minus ? memory =&gt; - term(memory) : term; } If there really is a sign change, there has to be a new function, otherwise the old function will do. All of these functions have to accept memory because term could be the function created by name and, therefore, require that argument. Actions for add, subtract, multiply, and divide again are tricky, for example: multiply (_, right) { return left =&gt; memory =&gt; left(memory) * right(memory); } multiply expects two functions, left and right, each with an argument memory, to return the left and right operand value for the multiplication. The function right is handed to the multiply action as the result of recognizing the right operand, i.e., it is the result of the signed action and as such expects memory as argument. The multiply action returns a function which expects a function left as an argument and returns the function which expects memory as an argument and produces the result of the multiplication, i.e., a function which fits the pattern of signed and name. This complicates the product and sum actions a bit, for example: product (signed, many) { const c = (a, b) =&gt; b(a); // function composition return (many ? many[0] : []). reduce((product, list) =&gt; c(product, list[0]), signed); } The action for product fits the idiom discussed in chapter five: there is one function signed and there can be many more. The functions have to be composed with reduce() and the callback function (line 2) has to compose two functions: a is a function which expects memory as an argument, i.e., a function like the one returned by the action for signed. b is a function which expects something like a as an argument, i.e., a function like the one returned by the action for multiply. As discussed for multiply above, b(a) is in fact a function. The result of reduce() is the last function produced with the composition c(), i.e., it is a function which can be applied to memory to carry out the calculations required to evaluate the product. Note that reduce() is executed at compile time, not at run time. The actions for divide, add, and subtract follow the pattern of multiply. The action for sum either produces a function to implement the assignment or it delegates to the action for product: sum (... arg) { if (arg.length == 4) return memory =&gt; memory[arg[1]] = arg[3](memory); else return this.product(arg[0], arg[1]); } Finally, the action for list has to return the executable, i.e., a function which does not accept an argument and displays the result of each sum in the comma-separated list: list (sum, many) { const list = [ sum ]. concat(many ? many[0].map(seq =&gt; seq[1]) : [ ]); return () =&gt; { const memory = { }; puts(... list.map(fct =&gt; fct(memory))); } } } The list of functions to be called can be produced during recognition (lines 2 and 3 above) based on the idiom discussed in chapter five. The executable creates memory (line 5), uses map() to produce an array of results, and uses spread syntax to display it on one line, i.e., with a single call to puts() (line 6). Try the functional expression compiler in example 6/07: Press to represent and check the grammar and press to perform syntax analysis and invoke the actions, i.e., to compile a program such as let x = input 3, (x + 1) / (y - 2) * 3, y + ((let y = 2) + 1) / (x - 2) + y Press and execute the program for different inputs. Stack Evaluation In this section arithmetic expressions are compiled into code for a stack machine. Example 6/08 contains new actions for the single expression grammar from example 6/06 which simply output the operation to be performed: class Postfix08 { // sum: product [{ add | subtract }]; /** `add: '+' right;` */ add (_, r) { puts('add'); } /** `subtract: '-' right;` */ subtract (_, r) { puts('subtract'); } // product: signed [{ multiply | divide }]; /** `multiply: '*' right;` */ multiply (_, r) { puts('multiply'); } /** `divide: '/' signed;` */ divide (_, r) { puts('divide'); } /** `signed: [ '-' ] term;` */ signed (minus, t) { if (minus) puts('minus'); } // term: input | number | name | '(' sum ')'; /** `input: 'input' [ Number ];` */ input (i, n) { puts('input'); } /** `number: Number;` */ number (number) { puts(number); } /** `name: Name;` */ name (name) { puts(name); } } There are no actions for sum, product, and term. The program (x + 1) / (input - -2) * 3 produces the output (one item per line) x 1 add input 2 minus subtract divide 3 multiply This is known as Reverse Polish Notation — operators follow their operands and no parentheses are needed as long as it is clear how many operands belong to each operator. This notation can be viewed as machine language for a stack machine: operands are pushed onto the stack, operators are applied to the top entries on the stack, pop the entries off the stack, and push the result onto the stack. The example suggests that syntax analysis with a grammar should make it near trivial to produce stack machine code to evaluate an arithmetic expression. Example 6/09 shows how to generate \"code\" and simulate a stack machine in JavaScript. The grammar from example 6/07 can be used but the start rule has to be modified to avoid collecting all results of sum on the stack: list: stmt [{ ';' stmt }]; stmt: sum; sum: 'let' Name '=' sum | product [{ add | subtract }]; A program is a list of statements, a statement is a sum and can start with an assignment prefixed by let to avoid an ambiguity. In the list above, statements are semicolon-separated. Alternatively list: { stmt ';' }; would make statements semicolon-terminated. Here is a small program: let x = let y = input 4; (x + 1) / (y - 2) * 3; y + ((let y = 2) + 1) / (x - 2) + y Note that assignment is right-associative because it involves right recursion. It turns out to be a good idea to encapsulate the infrastructure for a stack machine as a class to separate it from the compiler: class Machine09 { code = [ ]; // holds the instructions /** Represents `code` as text */ toString () { return this.code.map((f, n) =&gt; n + ': ' + f).join('\\n'); } /** Creates stack machine */ run (memorySize) { return () =&gt; { const memory = Array(memorySize).fill(0); // create memory this.code.forEach(code =&gt; code(memory)); // execute return memory; }; } } A program is compiled into an array code[] of JavaScript functions (line 2 above) which simulate the instructions of the stack machine. The method toString() can be used to display the instructions (line 5). The method run() creates and returns the stack machine interpreter (line 10) which must be a parameterless function. Runtime values are stored in an array memory[] which contains the variables' values followed by the stack. Thankfully, JavaScript imposes no restrictions on array length. memory[] is created when the stack machine starts (line 12) and manipulated by the JavaScript functions which simulate the instructions of the stack machine (line 13). At this point, each instruction in code[] is executed sequentially just once. The actions need access to the stack machine infrastructure and to a symbol table which maps variable names to memory addresses. The actions class has construction parameters so that future subclasses can extend the machine infrastructure and/or the symbol table: class Arithmetic09 { #parser; // for error messages get parser () { return this.#parser; } #machine; // handles execution get machine () { return this.#machine; } #symbols = new Map(); // symbol table, maps names to addresses get symbols () { return this.#symbols; } constructor (parser, machine = new Machine09 ()) { this.#parser = parser; this.#machine = machine; } // ... Every variable has an address that is determined at compile time, i.e., during syntax analysis, and stored in the symbol table. The symbol table is managed by a method _alloc() which assigns new addresses to as yet unknown names: /** Returns memory address for name */ _alloc (name) { let addr = this.symbols.get(name); // known name? if (typeof addr == 'undefined') this.symbols.set(name, // new name addr = this.symbols.size); // allocate, starting at 0 return addr; } With all of this in place, the actions for the operands are easy to write: /** `input: 'input' [ Number ];` */ input (_, number) { const dflt = String(number !== null ? number[0] : 0); this.machine.code.push( memory =&gt; memory.push(parseInt(prompt('input', dflt), 10)) ); } /** `number: Number;` */ number (number) { const result = parseInt(number, 10); this.machine.code.push(memory =&gt; memory.push(result)); } /** `name: Name;` */ name (name) { const addr = this._alloc(name); this.machine.code.push(memory =&gt; memory.push(memory[addr])); } The input action creates a machine instruction which uses prompt() to obtain a string, converts it to a number, and pushes the value onto the stack (line 5 above). The number action \"compiles\" the numerical value of the string collected by the token (line 11 above) and stores a machine instruction as generated code which will push this numerical value onto the stack (line 12). The name action consults _alloc() for the address of the variable in memory[] (line 17) and creates a machine instruction to push the value of the variable onto the stack (line 18). Moving on to the arithmetic operations: /** `add: '+' right;` */ add (_, r) { this.machine.code.push( memory =&gt; memory.splice(-2, 2, memory.at(-2) + memory.at(-1)) ); } The add action is a typical example. The machine instruction has to add the top two values on the stack and replace them by the single result value — a simple job for the splice() method. Just as in example 6/08 there are no actions for term and product because their results are already on the stack, but sum has to implement the embedded assignment, if any: /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */ sum (...val) { if (val.length &lt; 4) return; const addr = this._alloc(val[1]); this.machine.code.push(memory =&gt; memory[addr] = memory.at(-1)); } _alloc() finds or creates an address (line 4 above) and the machine instruction copies the value from the top of the stack to that address in memory[] (line 5). Note that the value remains on top of the stack. The action for stmt generates a machine instruction to display the result of a top-level sum (or assignment) as it is popped off the stack (line 13 below). The action for the start rule list is executed after all statements have been compiled. It displays the results of the compilation (lines 3 to 7) and calls run() to create the stack machine function (line 8): /** `list: stmt [{ ';' stmt }];` */ list (s, many) { puts(this.machine.toString()); // show code this.symbols.forEach( // show variables (value, name) =&gt; puts(name, 'at', value)); const size = this.symbols.size; // number of variables puts('stack starts at', size); return this.machine.run(size); // stack machine } /** `stmt: sum;` */ stmt (s) { // print and clear stack this.machine.code.push(memory =&gt; puts(memory.pop())); } } The compiler is complete but it consist of two classes. The has to evaluate to a single class or object with the Action methods for the parser. It takes a little trick to accomplish this: (() =&gt; { // define and immediately use an anonymous function class Machine09 { ... } class Arithmetic09 { ... } return Arithmetic09; }) () The two class definitions are placed into an anonymous function where return delivers the actual value for the actions (line 4) and the anonymous function is called immediately after being defined (line 5). It is instructive to see the actual code. For example a - - b compiles into &gt; run = g.parser().parse(program, actions) 0: memory =&gt; memory.push(memory[addr]) 1: memory =&gt; memory.push(memory[addr]) 2: memory =&gt; memory.splice(-1, 1, -memory.at(-1)) 3: memory =&gt; memory.splice(-2, 2, memory.at(-2) - memory.at(-1)) 4: memory =&gt; puts(memory.pop()) a at 0 b at 1 stack starts at 2 The output shows the machine instruction functions but not the variable addresses because the functions use closure to capture the addresses computed by _alloc(). Try out example 6/09: Press to represent and check the grammar, press to compile the program in the , and press to execute the stack machine. The output shown above is created by converting the values in code[] from JavaScript functions to strings, i.e., the output shows the actual JavaScript functions which simulate what hardware instructions would do to memory[]. As such, the output is precise but a bit hard to read. Example 6/10 is a slightly modified version of example 6/09 which makes the generated machine instructions easier to read. The following output, again for a - - b, still consists of JavaScript functions converted to strings, but it looks like it is closer to the reverse Polish notation introduced at the beginning of this section: &gt; run = g.parser().parse(program, actions) 0: memory =&gt; this.Load(0)(memory) 1: memory =&gt; this.Load(1)(memory) 2: memory =&gt; this.Minus(memory) 3: memory =&gt; this.Subtract(memory) 4: memory =&gt; this.Pop(memory) a at 0 b at 1 stack starts at 2 The infrastructure for the stack machine is extended. In Machine10 the machine instructions are defined using methods so that they are more meaningful when displayed as strings, for example: class Machine10 extends Six.Machine09 { // ... /** `stack: ... a b -&gt; ... a-b` */ Subtract (memory) { memory.splice(-2, 2, memory.at(-2) - memory.at(-1)); } /** `stack: ... -&gt; ... memory[addr]` */ Load (addr) { return memory =&gt; memory.push(memory[addr]); } } code[] is local to the Machine10 object and contains the functions shown in the output above where this refers to the Machine10 object because the stack machine executable is defined in the run() method as an arrow function, i.e., it inherits this and uses it when interpreting code[]. As a result, this.Subtract(memory) acts just like a simple function with memory as argument (lines 3 to 5 above). this.Load(0)(memory) (line 2) is more costly because it generates the function to manipulate memory during execution (line 8) — the price to pay for the mnemonic display — but the address argument is computed at compile time. Actions generate code as follows: class Arithmetic10 extends Six.Arithmetic09 { constructor (parser, machine = new Machine10()) { super(parser, machine); } // ... /** `subtract: '-' product;` */ subtract () { this.machine.gen('Subtract'); } /** `name: Name;` */ name (name) { this.machine.gen('Load', this._alloc(name)); } } Arithmetic10 uses Machine10 unless a subclass should decide otherwise (line 2 above). Code generation is implemented in Machine10 as a method gen() (line 2 below) which takes the instruction name and an optional list of values, calls the method ins() to produce the machine instruction, and then adds the function to code[]: /** returns `code.length` */ gen (name, ... args) { return this.code.push(this.ins(name, ... args)); } /** returns instruction function */ ins (name, ... args) { return args.length ? eval(`memory =&gt; this.${name}(${args.join(', ')})(memory)`) : eval(`memory =&gt; this.${name}(memory)`); } The operations on memory are still the same JavaScript functions, but they are wrapped into outer functions with expressive names. ins() uses eval() (lines 9 and 10 above) to perform closure so that, e.g., the address used in a Load instruction is visible when the function is converted into a string for display purposes. Using the Function constructor would be safer; however, the resulting function then has no display name. Unfortunately, extending to Arithmetic10 and Machine10 results in a lot of unused code: All machine instruction functions have been copied from Arithmetic09 into Machine10. All actions have been overwritten in Arithmetic10, only _alloc() has been inherited. This could have been avoided if the mnemonic display of the instructions had been introduced immediately. Control Structures In this section arithmetic expressions will be extended with typical control structures and implemented for the stack machine. Changes to the grammar can be seen on this page, new stack machine and action method classes can be seen in the method browser: press show to see the methods, sorted alphabetically, press by class or mix-in to sort by module, class or mix-in, and finally method name, select individual classes and/or methods to see less. Thus far the stack machine used forEach() to process the machine instructions in code[] just once, one after another. Real machines have a program counter which is advanced as an instruction is fetched from memory. Here is an idea for a modification to the stack machine: run (size, startAddr) { // create stack machine return () =&gt; { memory.pc = startAddr; // initialize program counter ... Once properties are added to memory to simulate machine registers such as a \"program counter\" there can be simulated branch instructions, for example: class Machine11 extends Six.Machine10 { // ... Branch (a) { // stack: ... -&gt; ... | pc: a return memory =&gt; memory.pc = a; } Bzero (a) { // stack: ... bool -&gt; ... | pc: !bool? a return memory =&gt; { if (!memory.pop()) memory.pc = a; } } If this.Branch(a)(memory) is executed the stack machine takes the next instruction from address a. If this.Bzero(a)(memory) is executed the stack is checked and popped, and if the top value was zero the stack machine takes the next instruction from address a. It is helpful if the stack machine can display instructions as they are executed, and if tracing can be controlled from within a program, e.g., tracing could be unconditional or depend on the current value of a variable. Machine11 adds a method trace() which accepts true to create an unconditional tracing function (lines 3 to 5 below) or a numerical memory address to create a function which traces if the current value in memory[address] is non-negative (lines 6 to 10): /** Returns trace function, if any */ trace (address) { if (address === true) // unconditional trace return (memory, pc) =&gt; // traces instruction at pc puts(memory.toString(), pc+':', this.code[pc].toString()); if (typeof address == 'number') // address of control variable? return (memory, pc) =&gt; { // traces instruction at pc if (memory[address] &gt;= 0) // variable at addr non-negative? puts(memory.toString(), pc+':', this.code[pc].toString()); }; } get Memory () { return this.#Memory ??= class extends Array { toString () { return '[ ' + this.join(' ') + ' ]'; } }; } #Memory; Either function displays the instruction stored in code[pc]. Each trace output includes a display of the current memory contents produced by a locally modified toString() method (lines 13 to 17 above). Eventually, memory[] will be more than just a linear list and toString() can be overwritten again. The stack machine interpreter, i.e., the executable returned by run(), still creates memory[] and initializes the variables to zero but it now has to consider the program counter and tracing: run (size, startAddr = 0, traceAddr) { let t; // [closure] trace function, if any const StackMachine = (memory, steps) =&gt; { if (!memory) { // initialize? if (steps) t = this.trace(true); // steps? permanent trace else { // no steps: don't suspend t = this.trace(traceAddr); steps = Infinity; } memory = new this.Memory(size).fill(0); // create memory memory.pc = startAddr; // initialize program counter t &amp;&amp; puts(memory.toString()); // initial memory } while (steps -- &amp;&amp; memory.pc &lt; this.code.length) { // steps? const pc = memory.pc ++; // advance program counter this.code[pc](memory); // execute at previous pc t &amp;&amp; t(memory, pc); // trace executed instruction } memory.continue = memory.pc &lt; this.code.length; // again? return memory; }; return (memory, steps) =&gt; StackMachine(memory, steps); } run() is called with the size of the initialized part of memory, the start address for the program counter, and an address to control tracing if any (line 1 above). The resulting StackMachine accepts two optional arguments, the memory[] array and steps, the number of instructions to execute (line 3), and eventually returns the modified memory[] (line 19). StackMachine() will create memory[] and run without limit. StackMachine(null, 10) will create memory[] and execute and trace 10 instructions. StackMachine(memory, 10) will then execute another 10 instructions. Initialization happens if there is no memory[] (line 4): Permanent tracing is set up if steps is defined and not zero (line 5), otherwise tracing depends on the control address handed to run() and there is no limit on steps (line 7). memory[] is created and zero-filled (line 9), the program counter at memory.pc is initialized (line 10), and the initial memory[] is shown if there is tracing (line 11). Instructions are executed as long as there are steps left and if the program counter does not point beyond code[] (line 13). The program counter is incremented (line 14), the instruction is executed (line 15) and traced if tracing was set up (line 16). Once there are no more steps, a property is set to indicate if more steps could be executed (line 18) and memory[] is returned. These modifications do not change the basic behavior of the stack machine, i.e., arithmetic expressions from example 6/09 — but for embedded assignment — can be part of a little language that has control structures. Example 6/11 uses Euclid's algorithm to compute the greatest common divisor of two numbers with a trace of one of the subtractions: x = input 36; y = input 54; while x &lt;&gt; y do if x &gt; y then x = x - y else y = y - x fi od; print x Press to represent and check the grammar, press to perform syntax analysis and generate code, and press to execute the program, reply 36 and 54 to the requests for input, and see the output: &gt; run() 18 [ 18 18 ] The program requires that the grammar from example 6/09 is extended to support control structures: prog: stmts; stmts: stmt [{ ';' stmt }]; stmt: assign | print | loop | select; assign: Name '=' sum; print: 'print' sums; sums: sum [{ ',' sum }]; loop: While cmp Do stmts 'od'; While: 'while'; Do: 'do'; select: 'if' cmp Then stmts [ Else stmts ] 'fi'; Then: 'then'; Else: 'else'; sum: ... This grammar makes a clear distinction between statements (stmt), expressions (sum), and conditions (cmp). This avoids a possible ambiguity between an expression and an assignment: without let both can start with a variable name. This grammar for control structures uses terminating literals to avoid ambiguity issues like the dangling else problem presented in example 4/05. Some control structure literals such as 'while' have been turned into simple rules so that actions can be attached — this is discussed below. Conditions could be about as complex as arithmetic expressions; however, for the little language comparisons will suffice, e.g., cmp: eq | ne; eq: sum '=' sum; ne: sum '&lt;&gt;' sum; Unfortunately, these rules are ambiguous because both alternatives start with sum. Here is a better approach: cmp: sum rel; rel: eq | ne | gt | ge | lt | le; eq: '=' sum; ne: '&lt;&gt;' sum; gt: '&gt;' sum; ge: '&gt;=' sum; lt: '&lt;' sum; le: '&lt;=' sum; While this is patterned after sum and product, this grammar does not allow cascading comparisons (which, e.g., JavaScript does). Here is the action for one of the comparisons: class Control11 extends Six.Arithmetic10 { constructor (parser, machine = new Machine11()) { super(parser, machine); } /** `eq: '=' sum;` */ eq () { this.machine.gen('Eq'); } The extended actions class requires additional machine instructions and, therefore, inserts Machine11 during construction (line 2 above). Here is one of the comparison instructions in Machine11: Eq (memory) { // stack: ... a b -&gt; ... a == b memory.splice(-2, 2, memory.at(-2) == memory.at(-1)); } This instruction will replace the top two values on the stack with the result of the comparison, i.e., true or false. Technically, these are very special values in the little language. The syntax does not permit them to be assigned to variables. Instead, they will be consumed by branch instructions for the control structures. Just like compiling sums, compiling comparisons also amounts to reverse Polish notation, i.e., the rules rel and cmp require no actions. However, the assign and print statements consume sums and require actions: /** `assign: Name '=' sum;` stores and pops stack */ assign (name, e, s) { this.machine.gen('Store', this._alloc(name)); this.machine.gen('Pop'); } /** `print: 'print' sums;` */ print (_, sums) { this.machine.gen('Print', sums); } /** `sums: sum [{ ',' sum }];` returns number of values */ sums (sum, many) { return 1 + (many ? many[0].length : 0); } The machine instructions Store and Pop were already defined in Machine10, i.e., in example 6/10. The assign action generates them to copy the top value on the stack into the memory location for the variable (line 3 above) and to clear the stack at the end of the statement (line 4). A print statement displays a list of sum values. It receives all arguments on the stack. The number of arguments is counted at compile time (line 11) and compiled into the Print instruction (line 8). At run time the Print instruction pops the arguments off the stack and hands them to puts() for display: Print (n) { // stack: ... n*val -&gt; ... return memory =&gt; puts(... memory.splice(- n)); } This little language supports control structures. The actions for loop, While, and Do have to implement the following branch structure: label code While: cmp Do: branch if zero to 'od' stmts branch to 'While' od: This explains what the actions have to do: /** `While: 'while';` returns address for branch to `while` */ While (w) { return this.machine.code.length; } /** `Do: 'do';` returns address of slot for bzero to `od` */ Do (d) { return this.machine.code.push(null) - 1; } /** `loop: While cmp Do stmts 'od';` */ loop (While, _, Do, s, o) { const od = this.machine.gen('Branch', While); this.machine.code[Do] = this.machine.ins('Bzero', od); } The While action just returns the next address in the generated code (line 2 above). The Do action allocates a slot in the generated code and returns the address of the slot (line 5) because push() always returns the new array length. Finally, loop puts it all together: the action adds an unconditional branch from the end of the loop body back to While (line 9) and populates the slot allocated by Do with a conditional branch to od to terminate the loop (line 10). Yes, the conditional branch at Do fails each time through the loop until it succeeds only once, at the end of the loop. An obvious optimization is to reverse the order of the loop body and the condition in the generated code and cut the number of branch executions in half; however, moving code when syntax analysis generates it directly is not really an option — absolute branches like the ones used here would break. select is a little harder because there are two possibilities: label code with else code without else cmp cmp Then: branch if zero to 'Else' branch if zero to 'fi' stmts stmts branch to 'fi' Else: stmts fi: The actions have to create the appropriate branch instructions: /** `Then: 'then';` returns address for bzero to `else` `fi` */ Then (t) { return this.machine.code.push(null) - 1; } /** `Else: 'else';` creates slot for branch to `fi`, returns address of `else` */ Else (e) { return this.machine.code.push(null); } /** `select: 'if' cmp Then stmts [ Else stmts ] 'fi';` */ select (i, c, Then, s, Else, f) { const fi = this.machine.code.length; // address of 'fi' if (Else) { Else = Else[0]; // address after branch to 'fi' this.machine.code[Then] = this.machine.ins('Bzero', Else); this.machine.code[Else - 1] = this.machine.ins('Branch', fi); } else this.machine.code[Then] = this.machine.ins('Bzero', fi); } The Then action allocates a slot in the generated code and returns the address of the slot (line 2 above). The Else action, if called, also allocates a slot in the generated code (for a branch to bypass the else clause) but it returns the address following the slot (line 6). Finally, the select action checks if there is an argument created by else (line 11) and creates and inserts the branch instructions as described in the pseudo code above. Code generation is complete. The top-level action for prog shows the generated code and provides tracing if a variable trace is in the program: /** `prog: stmts;` returns executable */ prog (_) { const size = this.symbols.size, // number of variables traceAddr = this.symbols.get('trace'); // if a variable named if (typeof traceAddr != 'undefined') { // ...'trace' exists puts(this.machine.toString()); // show code this.symbols.forEach( // show variable addresses (addr, name) =&gt; puts(`${name} at ${addr}`) ); puts('stack starts at', size); } return this.machine.run(size, 0, traceAddr); // stack machine } If the variable exists (lines 4 and 5 above) the generated code and variable addresses are shown (lines 6 to 10). The run() method of Machine11 discussed earlier is called (line 12) to create the stack machine. In example 6/11 Press to represent and check the grammar, press to perform syntax analysis and generate code, and press , , or to step through the program: &gt; memory = run(null, 1) 0:[ 0 0 ] [ 0 0 36 ] 0: memory =&gt; this.Input(memory) &gt; memory = run(memory, 1) [ 36 0 36 ] 1: memory =&gt; this.Store(1)(memory) ... Add statements like trace = -1 or trace = 1 to display the generated code and to turn tracing off and on within the program: trace = -1; x = input 36; y = input 54; ... Again, press to perform syntax analysis and generate code: &gt; run = g.parser().parse(program, actions) 0: memory =&gt; this.Push(1)(memory) 1: memory =&gt; this.Minus(memory) 2: memory =&gt; this.Store(1)(memory) ... program counter at 0 trace at 1 x at 2 y at 3 stack starts at 4 (memory, steps) =&gt; StackMachine(memory, steps) Now press to execute the program and see the trace: &gt; run() 0:[ 0 0 0 ] [ 0 0 0 1 ] 0: memory =&gt; this.Push(1)(memory) [ 0 0 0 -1 ] 1: memory =&gt; this.Minus(memory) 18 [ -1 18 18 ] The stack is cleared at the end of each statement because the value of each sum is assigned or printed and then popped of the stack or two sums are compared and popped and the result of the comparison is tested and popped, i.e., the stack will grow and shrink during expression evaluation but it cannot grow out of bounds. However, the little language can still be used to crash the practice page — just program an infinite loop and don't step execution... Functional Programming Fans of functional programming — especially in JavaScript — should enjoy example 6/12, the implementation of the little language in the style of the functional evaluation of arithmetic expressions as discussed previously. Functional programming can be very elegant, but — unlike the stack machine \"instructions\" — functions created by composition cannot be decomposed for display. At least, can be toggled to see what functions the actions create. The grammar is almost the same as in example 6/11 — the extra rules for the keywords in loop and select are not needed: loop: 'while' cmp 'do' stmts 'od'; select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi'; The actions for sum and all the other rules for arithmetic expressions remain unchanged from example 6/07 discussed previously. Comparisons are implemented just like add, and they return functions which compute the right operand and still need a function to compute the left operand value (lines 9 to 11 below): class Functions12 extends Six.Functions07 { /** `cmp: sum rel;` returns fct */ cmp (sum, rel) { return memory =&gt; rel[0](sum)(memory); } // rel: eq | ne | gt | ge | lt | le; /** `eq: '=' expr;` returns fct for composition */ eq (_, right) { return left =&gt; memory =&gt; left(memory) == right(memory); } The grammar does not allow cascading comparisons. Therefore, the action for cmp is a single function composition and does not require reduce() (line 4 above). Compiling into functions is particularly elegant for control structures. Instead of returning addresses and inserting branch instructions later, the control structures of the little language are simply turned into JavaScript control structures inside functions. Here is the action for loop: /** `loop: 'while' cmp 'do' stmts 'od';` returns fct */ loop (w, cmp, d, stmts, o) { return memory =&gt; { while (cmp(memory)) stmts(memory); }; } The action for select returns one of two functions depending on the presence of else: /** `select: 'if' cmp 'then' stmts [ 'else' stmts ] 'fi';` returns fct */ select (i, cmp, t, stmts, opt, f) { return opt ? (memory =&gt; cmp(memory) ? stmts(memory) : opt[1](memory)) : (memory =&gt; { if (cmp(memory)) stmts(memory); }); } If else is present, the returned function uses conditional evaluation (line 4 above), otherwise it uses an if statement in JavaScript (line 5). loop and select are the only places where the result of the cmp action is used. No matter which type JavaScript uses to represent the result of a comparison in the compiled comparisons, the use of this type is consistent with the intent of the compiled control structures — the joy of translating from one language to another... Assignment now is a statement; therefore, the action for sum is overwritten (to omit assignment there) and a new action for assign creates the function to perform assignment: /** `assign: Name '=' sum;` returns fct */ assign (name, e, sum) { return memory =&gt; memory[name] = sum(memory); } The stack machine implementation had to pop the sum off the stack, but there is no stack in the functional implementation. The action for sums creates a list of functions (line 8 below) and the action for print creates a function which elaborates the list to get the values and display them with puts() (line 3): /** `print: 'print' sums;` returns function */ print (p, sums) { return memory =&gt; puts(... sums.map(fct =&gt; fct(memory))); } /** `sums: sum [{ ',' sum }];` returns list of functions */ sums (sum, many) { return [ sum ].concat(many ? many[0].map(seq =&gt; seq[1]) : []); } The action for stmts uses reduce() and the comma operator to create a function which will execute the statement functions, one after another: /** `stmts: stmt [{ ';' stmt }];` returns fct */ stmts (stmt, many) { return (many ? many[0] : []). reduce((left, list) =&gt; memory =&gt; (left(memory), list[1][0](memory)), stmt[0]); } As before, all the functions expect a memory object as an argument which is used to map names to values. The start rule of the grammar has to create this object. stmts is referenced in loop and select; therefore, there is an extra top-level start rule to create memory in a parameter-less executable: /** `prog: stmts;` returns executable */ prog (stmts) { return () =&gt; stmts({ }); } Check out example 6/12: Press to represent and check the grammar and press to compile the program. Toggle and press again to see some of the functions created by the actions. Quick Summary Action methods can be used in syntax analysis to interpret — rather than just recognize — a sentence. For example, an arithmetic expression can be translated into reverse Polish notation or evaluated while it is recognized. Variable values (or their descriptions) can be stored as properties of a JavaScript object or in a Map. Programming languages contain control structures and interpretation of a program requires an intermediate representation so that loops can be interpreted more than once and selections can be partially skipped. A stack machineB: The Stack Machine is both, very easy to simulate, and very easy to generate code for. It can use a fixed-size array as program storage and a variable-size array as data stack. A program counter can be a property of either array. Global variables can be persistent at the beginning of the data stack. Machine instructions are JavaScript functions which manipulate the data stack, fetch and store variable values in that array, and change the program counter for branching. Alternatively, composition of JavaScript functions can also be used as an executable intermediate representation. Unlike the stack machine, however, the internals of this representation cannot be displayed as text. Previous: 5. Translating Sentences Next: 7. Language Features × Search results Close "},"tutorial-07-features.html":{"id":"tutorial-07-features.html","title":"Tutorial: 7. Language Features","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 7. Language Features Type Checking Functions, Scopes, and Nesting Chapter six explained how to use actions to interpret or compile arithmetic expressions. Simple variables, input, output, and control structures were added, resulting in a little language which was compiled into JavaScript functions, or into machine instructions for a stack machine simulated in JavaScript. This chapter adds specific language features to the little language and shows how to implement them, primarily for the stack machine. All classes are available from the module Seven which is built into the practice page. Syntactic Type Checking The result types of arithmetic and other operations depend on both, the operators, and the types of the operand values. Dynamically typed languages such as JavaScript tend to allow operators to combine fairly arbitrary types and let variables store values of different types at different times. The results can be surprising: Strings and numbers can be compared in JavaScript, but the string is first converted to a number, i.e., 'A' &gt; '1' is true (string comparison) and 'A' &gt; 1 is false (number comparison). Strings and numbers can be added in JavaScript, but the number is converted to a string and strings are concatenated with the + operator, i.e., 1 + '2' is '12' (string sum) rather than 3 (number sum). These effects are more surprising if variables are involved. Strongly typed languages such as Java determine the types of all values at compile time so that they can select the most efficient machine instructions for implementation. This requires either explicitly declaring or implicitly deducing the data types which variables may store, and flagging every operation which does not use compatible data types. Example 7/01 shows that strong type checking can be accomplished with a restrictive grammar where type mismatches will be reported as syntax errors. Press to represent and check the grammar, and press to perform syntax analysis: &gt; run = g.parser().parse(program, actions) error: at (4) '-': in sequence, Lit.parse(): expects 'fi' Here is line 4 of the program: x = x - y A deep dive into the grammar will reveal that a Name such as x is recognized as a stringTerm which cannot appear adjacent to the operator -, i.e., the error message is right on target — but hardly helpful. Constants in a program tend to exhibit their data type by their looks: integers are represented as digit strings, floating point numbers require a decimal point, an exponent, or both, strings are enclosed in quotes, Boolean constants usually are symbols such as true and false, etc. Fortran considered a variable to be \"integer\" if the name started with one of the letters I through N and \"floating point\" otherwise, but this idea of implicit typing has long since been abandoned. Instead, variable names are usually declared and typed before use, i.e., usually there is only one token for variable names { Number: /0|[1-9][0-9]*/, String: /'(?:[^'\\\\]|\\\\['\\\\])+'/, Name: /[a-z]+/ } and the type of a variable is determined by actions which interpret declarations. Numbers can be converted to strings; therefore, this little language requires all variables to be strings. Example 7/01 more or less duplicates the rules for cmp and sum from example 6/12 to separate string and number operations and fuse comparisons and terms: cmp: sum rel | stringSum stringRel; term: number | '(' sum ')' | 'number' stringTerm; stringRel: stringEq | stringNe | stringGt | stringGe | stringLt | stringLe; stringEq: '=' stringSum; ... stringSum: stringTerm [{ stringTerm }]; stringTerm: string | name | input | 'string' term; string: String; name: Name; input: 'input' String String; cmp requires that numbers are compared to numbers, and strings to strings (line 1 above) because all comparison rules have been duplicated for strings (lines 5 to 7) and only allow stringSum operands (lines 1 and 6). sum still recognizes arithmetic with numbers, but name and input have been moved from a (numerical) term (line 3) to a stringTerm (line 10), i.e., name and input only allow strings. input uses two String tokens to specify a prompt text and a default input value (line 13). A stringTerm can be converted to a number by preceding it with the literal number as a cast operation (line 3) and a (numerical) term similarly can be converted to a string (line 10). A stringSum allows concatenation using one or more stringTerm (line 9); there is no explicit operator to mark this operation. Example 7/01 still implements Euclid's Algorithm: x = input 'x' '36'; y = input 'y' ' 54'; while x &lt;&gt; y do if x &gt; y then x = x - y else y = y - x fi od; print '\\'gcd\\': ' x It is unchanged but for some extra strings for input and print (lines 1 and 9 above). There are essentially three errors in the program, the last one serious enough to crash the practice page: number Conversions are required before y can be subtracted from x and vice versa (lines 4 and 6). string Conversions are required before the results can be assigned back to x and y (lines 4 and 6). The default strings for x and y are not equal (line 1) but string comparison would consider any positive or negative number in x to be greater than y (line 3) because of the leading blanks in the default input (line 1) and 'x' would be set to ever more negative numbers — the program loops! The last error demonstrates that strong typing will not necessarily catch serious flaws in a program. It should also be noted that this syntactic approach to type checking requires that there are few types and that operations are well separated. The actions from Example 6/12 can be extended in example 7/01 to compile this little language into JavaScript functions: class TCheck01 extends Six.Functions12 { // ... /** `stringEq: '=' stringSum;` returns fct for composition */ stringEq (_, right) { return this.parser.call(this, super.eq, _, right); } /** `stringSum: stringTerm [{ stringTerm }];` returns fct */ stringSum (term, many) { const c = (a, b) =&gt; memory =&gt; a(memory) + b(memory); return (many ? many[0] : []). reduce((sum, list) =&gt; c(sum, list[0]), term); } The string comparisons can delegate to the numerical comparisons (line 4 above) because the target language JavaScript is dynamically typed. stringSum implements string concatenation in the callback function for reduce() (line 4). // term: number | '(' sum ')' | 'number' stringTerm; // [0] [1] [1] term (...val) { switch (val.length) { case 1: return val[0]; case 3: return val[1]; case 2: return memory =&gt; parseInt(val[1](memory), 10); } } /** `stringTerm: string | name | input | 'string' term;` */ // [0] [0] [0] [1] stringTerm (...val) { return val.length == 1 ? val[0] : memory =&gt; String(val[1](memory)); } term has to be overwritten to return a function if a program calls for an explicit conversion (line 7 above). Similarly, stringTerm has to implement a conversion to a string value if needed (line 15). /** Removes quotes and backslash */ _unq (s) { return s.slice(1,-1).replace(/\\\\([\\\\'])/g, \"$1\"); } /** `string: String;` returns fct */ string (s) { return () =&gt; this._unq(s); } /** `input: 'input' String String;` [replace] returns fct */ input (i, prmpt, dflt) { return () =&gt; prompt(this._unq(prmpt), this._unq(dflt)); } Finally, the string and input actions have to convert a single-quoted string literal in the program into the corresponding string value. A helper method _unq() removes the outer quotes and interprets backslashes if any (line 3 above). Just like the number action, the string action has to return a function which will return a constant, literal string value (line 7). input is overwritten to use the prompt and default strings and to not perform implicit conversion of the incoming string value into a number (line 11). Type Checking by Interpretation In this section the functional implementation of the little language with control structures from chapter six will be extended with strings and floating point and integer numbers. Changes to the grammar can be seen on this page, new action methods can be seen in the method browser. The best conclusion from the previous section is that syntax analysis, i.e., sentence structure, and semantic analysis, i.e., sentence meaning, require separate mechanisms. If variables are declared before use, type checking amounts to symbolic interpretation of a program — with types taking the place of values. Chapter six showed how to implement interpretation, i.e., immediate evaluation at compile time — at least for arithmetic expressions without variables. Example 7/02 shows how to interpret types while translating a program into JavaScript functions. Variables have to be declared before use and there are integer and floating point variables with mixed arithmetic, strings with input, printing, and concatenation, strict comparisons and assignments, implicit conversion only for numerical operations, and explicit type casting operations. Here is the typed version of Euclid's algorithm: int x, y; x = int (input 'x' '36'); y = int (input 'y' '54'); while x &lt;&gt; y do if x &gt; y then x = x - y else y = y - x fi od; print '\\'gcd\\': ' + x Press to represent and check the grammar, press to perform syntax and semantic analysis and generate an executable, and press to execute the compiled program. Toggle and press again to see what JavaScript functions are created. In this kind of type checking, actions immediately interpret types similar to values while generating and returning JavaScript functions to the parent rules and actions. The new action class is mostly concerned with type interpretation. Almost all function generation is inherited from example 6/12 and example 7/01. TCheck02 first defines some infrastructure: class TCheck02 extends Seven.TCheck01 { /** For error messages */ get parser () { return this.#parser; } #parser; /** Symbol table, maps names to types */ get symbols () { return this.#symbols; } #symbols; /** For symbolic computing with types */ get stack () { return this.#stack; } #stack = [ ]; constructor (parser, symbols = new Map()) { super(); this.#parser = parser; this.#symbols = symbols; } /** Returns type of name, message if undefined */ _type (name) { const type = this.symbols.get(name); if (type) return type; this.parser.error(name + ': undeclared'); // return undefined } Error messages require access to the parser (lines 3, 12, and 14 above). There have to be a map from variable names to their types (lines 6, 12, and 15) and a stack (lines 9 and 10) where actions such as number, string, etc., will push a type and actions such as product, sum, etc., will pop and combine operand types and push result types. _type() expects to find and return the type declared for a variable name in the symbol table (lines 20 and 21). If not, the method displays an error message (line 22) and returns undefined. If a Name is recognized, the name action determines the type, pushes it onto the compile time type stack (line 3 below), and delegates to the superclass(es) to generate an appropriate JavaScript function (line 4). /** `name: Name;` returns `fct:_type(name)` */ name (name) { this.stack.push(this._type(name)); return this.parser.call(this, super.name, name); } This pattern is typical for int — which pushes 'int' and delegates to number — and string and input — which push 'string'. The float action has to generate a new function: /** `float: Float;` returns `fct:float` */ float (float) { this.stack.push('float'); return () =&gt; parseFloat(float); } The first heavy lifting happens when a term contains an explicit conversion (line 12 below): // term: int | float | string | name | input // [0] // | 'int' term | 'float' term | 'string' term // [0] [1] // | '(' sum ')'; // [1] term (...val) { switch (val.length) { case 1: return val[0]; case 3: return val[1]; } const to = val[0], from = this.stack.pop(); this.stack.push(to); return this._cast(val[1], from, to); } In this case the term action is called with two arguments, namely the target type val[0] which is stored as to and the function val[1] which will produce the value which may have to be converted. The type of this value from is popped off the type stack (line 12 above). The result type of the explicit conversion will be to and it is pushed onto the type stack (line 13). Conversions might be applied elsewhere; therefore, it is the job of a new method _cast() to compose a suitable JavaScript function: /** Converts `fct:from` into `fct:to` if needed */ _cast (fct, from, to) { switch (`${to} &lt;- ${from}`) { default: this.parser.error('impossible cast from', from, 'to', to); case 'int &lt;- int': case 'float &lt;- float': case 'string &lt;- string': case 'float &lt;- int': return fct; case 'int &lt;- float': return memory =&gt; Math.round(fct(memory)); case 'int &lt;- string': return memory =&gt; parseInt(fct(memory), 10); case 'float &lt;- string': return memory =&gt; parseFloat(fct(memory)); case 'string &lt;- int': case 'string &lt;- float': return memory =&gt; String(fct(memory)); } } Nothing needs to be done in four of the nine possible cases (lines 7 to 9 above) because three cases are identities, and integers and floating point values, both, are represented as numbers in the implementation language. The five other cases are handled by composing four new functions which involve Math.round(), parseInt(), parseFloat(), and String(). The latter, again, works for both, integers and floating point values. Arithmetic operations allow integers and floating point arguments, e.g.: /** `subtract: '-' product;` returns `fct:int|float` */ subtract (_, right) { const [ l, r ] = this.stack.splice(-2, 2); if (l == 'string' || r == 'string') this.parser.error(\"cannot apply '-' to string\"); this.stack.push(l == 'int' &amp;&amp; r == 'int' ? 'int' : 'float'); return this.parser.call(this, super.subtract, _, right); } The types of the left and right operand are on the stack (line 3 above). Subtraction and most other operations flag strings as errors (lines 4 and 5) and replace the operand types by the result type — 'int' only if all operands are integers (line 6). Division always produces 'float'. Code generation is always delegated to the superclass (line 7). /** `add: '+' product;` returns `fct:string|int|float` */ add (_, right) { const [ l, r ] = this.stack.splice(-2, 2); this.stack.push(l == 'string' || r == 'string' ? 'string' : l == 'int' &amp;&amp; r == 'int' ? 'int' : 'float'); return this.parser.call(this, super.add, _, right); } The operator + specifies concatenation if a string is involved and addition otherwise — this determines the result type (lines 4 and 5 above). This makes no difference for the generated function (line 6) because JavaScript has the same semantics. /** `cmp: sum rel;` returns fct */ cmp (sum, rel) { const [ l, r ] = this.stack.splice(-2, 2); if ((l == 'string' || r == 'string') &amp;&amp; l != r) this.parser.error('must compare strings to strings'); return this.parser.call(this, super.cmp, sum, rel); } cmp flags comparisons between strings and numbers (lines 4 and 5 above). The action discards the operand types because the parent rule is a statement and can only be select or loop which need no additional checking. Assignment insists that variable and value type are equal (lines 3 to 6 below) and pops the value's type, clearing the stack at the statement level (line 4): /** `assign: Name '=' sum;` returns fct */ assign (name, _, sum) { const type = this._type(name), r = this.stack.pop(); if (type != r) this.parser.error(`assigning ${r} to ${type} ${name}`); return this.parser.call(this, super.assign, name, _, sum); } print accepts only string values and pops all their types: /** `print: 'print' sums;` returns fct, string arguments only */ print (p, sums) { if (! this.stack.splice(- sums.length, sums.length). every(type =&gt; type == 'string')) this.parser.error('can only print strings'); return this.parser.call(this, super.print, p, sums); } As an alternative, printAny(), is an action for the same rule which implicitly converts all arguments to strings using the _cast() method described above: /** `printAny: 'print' sums;` returns fct */ printAny (p, sums) { // implicitly casts non-string arguments sums.reverse().map((sum, n) =&gt; { // check each argument const type = this.stack.pop(); // requires reverse order if (type != 'string') { sum = this._cast(sum, type, 'string'); // apply conversion puts(`print argument ${sums.length - n} was ${type}`); } return sum; // returns fct:string }).reverse(); return this.parser.call(this, super.print, p, sums); } sums, the list of functions computing the values to be printed, is reversed so that the order matches the type stack top-down. For each function a type is popped off the stack (line 4 above). If the type is not 'string' already an implicit conversion is applied (line 6). Finally, the resulting list of functions is reversed again (line 10) just before delegation to print() in the superclass (line 11) to generate code for the actual print operation. Essential for type checking in example 7/02 is that variables have to be declared before they are used. The rule for prog is revised to include declarations before statements (line 1 below). The action has to be overwritten to send the function generated for stmts to the superclass (line 2): /** `prog: [{ decl ';' }] stmts;` returns executable */ prog (many, stmts) { return this.parser.call(this, super.prog, stmts); } /** `decl: type Name [{ ',' Name }];` */ decl (type, name, many) { [ name ].concat(many ? many[0].map(list =&gt; list[1]) : []). forEach(name =&gt; { if (this.symbols.has(name)) this.parser.error(`${name}: duplicate`); this.symbols.set(name, type[0]); }); } } Each name in each declaration is checked to catch duplicate declarations (line 8 above) and it's type is recorded in the symbol table (line 10). In example 7/02 Press to represent and check the grammar. Replace + in the last line in the with a comma so that there are two arguments to print and press to perform syntax and semantic analysis to determine that print only permits string arguments. Replace the name print in two(!) rules by printAny in the to use the alternative action, press to represent and check the changed grammar, and press to perform syntax and semantic analysis again to see that there now is an implicit conversion. Semantic analysis is done. It should be noted that the little language is more restrictive than the implementation language but benefits from some shortcuts due to dynamic typing and powerful implicit conversions in JavaScript. All error messages show the typical dilemma: an action method could throw an error and forcibly terminate syntax analysis, but then only one error would be detected. Usually, it is better to continue syntax analysis with incorrect code generation and mark the executable as defective. Error reporting through the parser counts errors and reports them at the end of recognition. It is also quite apparent that implementing semantic analysis points out design choices that were made for the little language. They may be a matter of taste, but they can surprise or annoy users endlessly... Example 7/03 uses the same compiler Seven.TCheck02 and contains statements with a number of semantic errors. Press to represent and check the grammar, press to perform syntax and semantic analysis. Repair the semantic errors, e.g., by deleting the offending statements, and recompile with . Finally, press to execute the compiled program. The last two lines of output should be 3 and 4. Functions In this section the little language with control structures will be extended with functions which can be called recursively. Changes to the grammar can be seen on this page, new stack machine and action methods can be seen in the method browser. Just like control structures, functions depend either on language features of the implementation language, i.e., functions in JavaScript to which the source language functions can be mapped, or on branch instructions which capture return information. This section looks at an implementation of functions without parameters for the stack machine. Example 7/04 contains two mutually recursive functions which together implement Euclid's algorithm without an explicit loop: var x, y; function fa; function fb; function main begin x = input 36; y = input 54; fa; print x; x = 90; y = 72; return fb; print 99 end; function fa begin if x = y then return x fi; if x &gt; y then x = x - y else y = y - x fi; fa = fb end; function fb begin if x = y then fb = x else if x &gt; y then x = x - y else y = y - x fi; fb = fa fi end; The program starts in main, inputs decimal values for x and y, calls the algorithm, and prints the result (lines 6 and 7 above). It then sets x and y to other values, calls the algorithm again, and returns the result. 99 will not be printed (line 9). Press to represent and check the grammar, press to create the executable, press to execute, and input two arbitrary positive integers for the first call to the algorithm. The second output (line 3 below) is the greatest common divisor of 90 and 72. It is returned from main (line 9 above) and printed by the caller. After execution memory contains the values 18 for the variables x and y (line 4). &gt; run() 0 18 [ 18 18 ] A program consists of global variable definitions followed by function definitions; one of the functions must be called main. When the executable is run main is called implicitly and the result is printed. Functions must be declared before they can be used, i.e., mutual recursion requires a declaration of function fb (line 3 in the program above) before it can be used in the definition of function fa (lines 12 to 16). If function fb is declared it must later be defined (lines 18 to 23). return terminates function execution (lines 9 and 13) and can arrange for a result to be delivered to the point of call. The result value of a function is either specified explicitly for return or it is assigned to the function name, or it is zero. Technically, there is no need for a return statement because a result value can be assigned to the function name within the function body (lines 15, 19 and 21); however, return can be convenient for early termination (e.g., line 13 for fa). Functions can be called in the context of expressions or as statements. If a function is called in a statement (line 7) the result value is discarded; otherwise the result value can be used in an expression. E.g., return fb in the definition of main (line 9) first makes a call to fb and then terminates the (implicit) call to main and returns the result of the call to fb as result of the call to main. This step in the evolution of the little language requires a bit of semantic analysis: Variables are global and need not be declared. A variable cannot be called as if it were a function. Functions must be declared or defined before they can be used. A function cannot be declared after it has already been defined. Assignment to a function name is only allowed in the function body. Grammar Modifications A program consists of an optional list of global variables followed by one or more function declarations and definitions, each terminated by a semicolon. A function declaration has no body (line 5 below): prog: [ vars ] funs; vars: 'var' names ';'; names: Name [{ ',' Name }]; funs: { fun }; fun: head [ 'begin' stmts 'end' ] ';'; head: 'function' Name; There are only two more extensions to the grammar: stmt: assign | print | return | loop | select; assign: Name [ '=' sum ]; return: 'return' [ sum ]; A procedure call has to be recognized as an assignment where the actual assignment operation is omitted (line 2 above). return is added as a new statement. All other changes are semantic in nature, i.e., they concern the fact that a Name can refer to a function or a variable. Machine Instructions The stack machine needs three new instructions: class Machine04 extends Six.Machine11 { /** `stack: ... -&gt; ... old-pc | pc: addr` */ Call (addr) { return memory =&gt; (memory.push(memory.pc), memory.pc = addr); } /** `stack: ... old-pc -&gt; ,,, 0 old-pc` */ Entry (memory) { memory.splice(-1, 0, 0); } /** `stack: ... old-pc -&gt; ... | pc: old-pc` */ Return (memory) { memory.pc = memory.pop(); } /** `stack: ... x old-pc result -&gt; ... result old-pc result` */ ReturnValue (memory) { memory.splice(-3, 1, memory.at(-1)); } } Functions are control structures and require a machine instruction which remembers the address to return to. Recursive calls are possible as long as this address is deposited on the stack. Call(addr) pushes the stack machine's current program counter onto the stack and places addr into the program counter (line 4 above). Return undoes the effect of Call: It expects the function result value on top of the stack and the return address just below. It removes the return address from the stack and assigns it to the program counter (line 8). This leaves the function result value on top of the stack. ReturnValue(memory) expects the function result value on top of the stack, just above the return address and the slot for the function result. It copies the result value from the top of the stack into the result slot (line 12). Depending on context the value may then have to be popped off the stack. Infrastructure The symbol table now contains descriptions of variables and functions; therefore, a separate counter size is needed to allocate variable addresses (lines 3 and 4 below): class Functions04 extends Six.Control11 { /** Manages next (global) variable address */ get size () { return this.#size; } set size (size) { this.#size = size; } #size = 0; /** Describes current function */ get funct () { return this.#funct; } set funct (sym) { this.#funct = sym; } #funct; funct contains the symbol description of the current function (lines 8 and 9 above). Getters and setters are used because they can be overwritten in subclasses and they cannot be mistaken for action methods. Symbol descriptions will change as the little language evolves. All of them contain a name and a reference to the actions class which uses them, i.e., they are best represented by inner classes which have this.Symbol as the common base class: get Symbol () { return this.#Symbol ??= class { owner; // surrounding class name; // variable/function name constructor (owner, name) { this.owner = owner; this.name = name; } }; } #Symbol; this.Var is the class to represent variables. This kind of symbol description must be created with a new global address (line 5 below): get Var () { return this.#Var ??= class extends this.Symbol { addr; // memory address constructor (owner, name, addr) { super(owner, name); this.addr = addr; } load () { // generate load instruction this.owner.machine.gen('Load', this.addr); } storeOk () { return true; } // always permit assignment store () { // generate store instruction this.owner.machine.gen('Store', this.addr); } toString () { return `${this.name} at ${this.addr}`; } }; } #Var; The class has a few convenience methods to create instructions to copy the variable value to the stack (line 8 above) and back (line 12) and to format information about the symbol (line 14). this.Fun is the class to represent functions and has similar convenience methods for code generation: get Fun () { return this.#Fun ??= class extends this.Symbol { start = false; // start address, not yet set calls = []; // forward references to entry returns = []; // forward references to exit entry () { // defines start address, arranges slot for result this.start = this.owner.machine.gen('Entry') - 1; } undo () { // ends a declaration, undoes entry() this.owner.machine.code.length = this.start; this.start = false; } call () { // create Call or save address for slot for Call if (typeof this.start == 'number') this.owner.machine.gen('Call', this.start); else this.calls.push(this.owner.machine.code.push(null) - 1); } return () { // create slot for Branch, save address this.returns.push(this.owner.machine.code.push(null) - 1); } storeOk () { // ok to store result value? if (this == this.owner.funct) return true; this.owner.parser.error(`${this.name}: ` + `assigned to outside function`); return false; } store () { // store top of stack as result value this.owner.machine.gen('ReturnValue'); } end () { // resolve calls and returns if any, exit() const call = this.owner.machine.ins('Call', this.start); this.calls.forEach(c =&gt; this.owner.machine.code[c] = call); this.calls.length = 0; const br = this.owner.machine.ins('Branch', this.owner.machine.code.length); this.returns.forEach(c =&gt; this.owner.machine.code[c] = br); this.returns.length = 0; this.exit(); } exit () { // generates code to return from function call this.owner.machine.gen('Return'); } toString () { return `function ${this.name} start ${this.start}`; } }; } #Fun; A function result value is zero by default; therefore, the slot for the function result is created at the beginning of a function by pushing zero onto the stack (line 7 above). Function declarations and definitions look more or less alike and both will cause a call to entry() which a declaration can undo by calling undo() (line 9). Because of function declarations a function can be called before it is defined; therefore, a method call() might create an empty slot for a Call instruction (line 17) and a method end() is called when the function definition is complete to fill these slots (lines 32 to 34). Similarly, return() directs all function returns to the end of the function code (line 20) and end() inserts the necessary forward branch instructions (lines 36 to 39). storeOk() checks if a function result is assigned within the current function definition (line 23) and displays an error message if not. store() codes the ReturnValue instruction which sets the function result (line 29). end() delegates to exit() to code the Return instruction which ends function execution (line 43). All of these methods are designed to be overwritten if function setup and cleanup have to be changed. All three symbol classes are defined using getters so that they can be overwritten in action subclasses. The result values of the getters are memoized using the ??= operator so that tests like symbol instanceof this.Fun produce the intended result. _find() and _dcl() manage the symbol table, _alloc() allocates addresses for new variables: /** Returns symbol description for name, if any */ _find (name, report) { const sym = this.symbols.get(name); if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); return sym; } /** (Re-)defines and returns `sym`, cannot be undefined */ _dcl (sym, report) { if (report &amp;&amp; this.symbols.get(sym.name)) this.parser.error(`${sym.name}: duplicate`); this.symbols.set(sym.name, sym); return sym; } /** Returns new `Var` at next global address. */ _alloc (name) { return new this.Var(this, name, this.size ++); } _find() returns a symbol description for a name and can optionally report that the symbol is undefined. _dcl() enters a symbol description into the symbol table and can optionally report that this is a duplicate definition. Actions Given functions, Name can refer to either a function or a variable; therefore, actions have to be created or revised for all rules involving Name. // names: Name [{ ',' Name }]; names (name, some) { const dcl = name =&gt; this._dcl(this._alloc(name), true); dcl(name); if (some) some[0].forEach(list =&gt; dcl(list[1])); return 1 + (some ? some[0].length : 0); } names creates variable descriptions for a list of names and uses _dcl() to enter them into the symbol table and report duplicates. // name: Name; name (name) { const sym = this._find(name, true); if (sym instanceof this.Fun) sym.call(); else if (sym) sym.load(); } In an expression, a Name can trigger a function call (line 4 above) which will eventually leave the result on top of the stack, or it can cause the current value of a variable to be pushed onto the stack (line 5). Code generation for either case is handled by the symbol description as discussed above. If a name is undefined _find() reports an error and no code is generated (line 5). // assign: Name [ '=' sum ]; assign (name, sum) { const sym = this._find(name, true); if (sym) { if (sym instanceof this.Var) if (sum &amp;&amp; sym.storeOk()) sym.store(); // variable = sum else this.parser.error(`${name}: cannot call a variable`); else if (!sum) sym.call(); // function call else if (sym.storeOk()) sym.store(); // function = sum this.machine.gen('Pop'); // clear stack } } In an assignment statement Name can refer to a function or a variable. Code is only generated if _find() provides a description and does not report an error (line 4 above). If it is a variable (line 5) and if there is something to assign sym.store() is called to generate the Store instruction (line 6). Otherwise there is an error because a variable cannot be called (line 7). If it is a function name and nothing to assign sym.call() takes care of the Call instruction (line 8). If there is something to assign sym.store() can be called if the name refers to the current function, i.e., if the assignment is in the function body (line 9); otherwise sym.storeOK() reports the assignment to the function name as an error. Finally, the stack has to be popped to discard the assigned value or the function result (line 10). // return: 'return' [ sum ]; return (r, sum) { if (sum &amp;&amp; this.funct.storeOk()) (this.funct.store(), this.machine.gen('Pop')); this.funct.return(); } If a return statement includes a value, the current function's store() method will assign it as a function result and then the value has to be popped off the stack (line 4 above). Function termination is arranged by the function description's return() method (line 5). Functions can be declared so that they can be called before they are defined: funs: { fun }; fun: head [ 'begin' stmts 'end' ] ';'; head: 'function' Name; head is recognized before fun and the function body if any, i.e., the action for head happens first: // head: 'function' Name; head (f, name) { let sym = this._find(name); if (! (sym instanceof this.Fun)) { if (sym instanceof this.Var) this.parser.error(`${name}: used as variable and function`); sym = this._dcl(new this.Fun(this, name)); } if (typeof sym.start == 'number') { this.parser.error(`${name}: duplicate`); sym = this._dcl(new this.Fun(this, name)); // patch } sym.entry(); // generate code for function entry return this.funct = sym; // in function } First there is some semantic analysis: A variable name cannot be a function name (line 5 above); to allow further processing it is redeclared as a function (line 7). An undefined name is declared as a function (line 7). A function cannot be defined more than once (line 9) — sym.start will contain an address once there is code for the function. head may be the beginning of a function definition; therefore sym.entry() is called to generate the code to start the function (line 13). Finally, the current function is posted in this.funct and returned (line 14). Once code generation for the function body is complete — or immediately if there is no body — the fun action performs some cleanup: // head [ 'begin' stmts 'end' ] ';'; fun (head, opt, _) { if (opt) head.end(); // function definition: wrap up else head.undo(); // function declaration: discard entry code this.funct = null; // not in function } head provides access to the function description. If there is a function body the end() method described previously inserts Call and Branch instructions and generates the code to return from the function call (line 3 above). Otherwise this was only a function declaration and undo() removes the effect of entry() in the head action (line 4). Finally, this.funct is set to null to signal that code generation has left the body of the function (line 5). All actions for functions and their consequences are in place. Expressions can be retained from the previous (untyped) version of the little language, i.e., from example 6/11. The prog action performs some final cleanup and generates the stack machine: // prog: [ vars ] funs; prog (v, f) { const main = this._check_defs(this.symbols), // flag undefined startAddr = this.machine.code.length, // at startup code trace = this._find('trace'), // does variable 'trace' exist? traceAddr = trace instanceof this.Var ? trace.addr : false; if (main) this._startup(main); // generate call to main else this.parser.error('main: undefined'); if (traceAddr !== false) { // if 'trace' exists puts(this.machine.toString()); // show code, this.symbols.forEach(s =&gt; puts(s.toString())); // symbols, puts('stack starts at', this.size); // variable memory size if (main) puts('execution starts at', startAddr); } return this.machine.run(this.size, startAddr, traceAddr); } Just as before tracing depends on the existence of a symbol named trace (line 5 above) but trace has to be a variable (line 6). If so, the generated code, the symbols, and the initial memory size are shown (lines 9 to 14). The stack machine generator creates the executable as before (line 15); however, functions definitions have to be checked (line 2) and the initial call to main has to be generated (line 7) which will determine the start address of the executable. _check_defs() checks all symbols to make sure that all functions have a defined start address and it returns the description for main if it is a defined function: _check_defs (map) { let main = undefined; map.forEach(sym =&gt; { if (sym instanceof this.Fun) if (typeof sym.start != 'number') this.parser.error(`${sym.name}: undefined function`); else if (sym.name == 'main') main = sym; }); return main; } If main was defined, startup() generates instructions to call the function and print the result and returns the start address of the instructions. _startup (main) { this.machine.gen('Call', main.start); // call main function this.machine.gen('Print', 1); // print and pop } } Tracing was introduced in chapter six. Check out how a function is called and how it returns a result in example 7/04: Press to represent and check the grammar, press to create the executable, and repeatedly press to execute one step at a time. Alternatively, add statements trace = -1, trace = 1, or trace = input to turn tracing off and on, or add trace to the list of global variables (which are initialized to zero) to trace everything. Example 7/05 demonstrates 13 semantic errors: var a, a; function undefined; function a; function g begin g = 1 end; function f begin f = 2; g = 3; v = 4 end; function v; function f begin return; v = 5; v; undef; f = 6 end; function g; duplicate global variable names (in line 1 above), a name a which is defined as a variable and forward declared as a function (line 3), a function names g and v which are assigned to outside the function definitions (lines 5 and 9), an undefined variable name 'v' (line 5), a duplicate function definition (line 7), a function undef which is used but not declared (or defined) (line 9), forward declarations for functions a, v, and undefined which are never defined (lines 2, 3, and 6), a forward declaration for g after the function has been defined (line 11), and no definition for a main function. Local Variables In this section the little language with functions will be extended with local variables. Changes to the grammar can be seen on this page, new stack machine and action methods can be seen in the method browser. Frames Real functions have parameters and local variables. This complicates the code when entering and exiting a function: At entry, argument values are connected to parameter names and memory is allocated for local variables. At exit, cleanup is required so that Return only leaves a result behind — this is why a return inside a function body is coded as a branch to the exit code. Recursion complicates access to parameters and local variables even more because the values exist once for each level of recursion and the names refer to the latest activation of each function. Rather than just stacking a return address and a result value slot as in example 7/04, now frames, also called activation records, have to be stacked which additionally contain argument values and local variables: Memory use evolves: Initially there are global variables. Once function a is called and itself calls function b there are two locals frames. If there is a recursive call from b to a there are three locals records. The locals are chained on a dynamic link so that the exit code and Return can clean them up in reverse order. Addressing also gets more complicated: Global variables have absolute addresses, determined at compile time. Local variables have relative addresses, i.e., offsets within their frame, which have to be added to the base address where the frame begins at run time. The offset is determined at compile time but — as the graphic indicates — the base address depends on the call history. In summary, if parms is the number of parameters of a function, a frame contains the following: offset content +0... argument values for the parameters, if any +parms the return address for the function +parms +1 a slot for the dynamic link,i.e., the address of the frame of the caller +parms +2 a slot for the function result +parms +3... values for the local variables The Memory class from example 7/04 is extended with a frame pointer register, represented as a property .fp (line 4 below), and toString() is overwritten to display the stack as a sequence of frames: class Machine06 extends Seven.Machine04 { get Memory () { return this.#Memory ??= class extends super.Memory { fp = 0; // global frame starts at 0 frames = [ 0 ]; // toString(): list of number of parameters toString () { let fp = this.fp, // begin of (top) frame to = this.length; // end of (top) frame return this.frames.map((parms, n) =&gt; { try { return `${fp}:[ ${this.slice(fp, to). map(slot =&gt; this.mapSlot(slot)).join(' ')} ]`; } catch (e) { throw e; // shouldn't happen } finally { to = fp; // end and begin of previous frame if (n == this.frames.length-1) fp = 0; // globals else fp = this[fp + parms + 1]; // previous frame } }).reverse().join(' '); } mapSlot (slot) { // hook to interpret slots return typeof slot == 'undefined' ? 'undefined' : slot; } }; } #Memory; The frames can be displayed by following the dynamic link which at this point depends on the number of parameters in each frame. At this point this is stored in a list represented as a property .frames[] (line 5 above). The top frame on the stack extends from .fp to the current end of the memory array (lines 8 and 9). In a loop over the frames (line 10) a frame is accessed using slice() (line 12) and each slot is represented as a string using a function mapSlot() which might be overwritten (lines 13 and 24). Machine Instructions Argument values are pushed onto the stack before a function is called. The Entry instruction at the beginning of each function has to initialize the frame as described above, given that parms is the number of parameters of the function and size is the memory requirement of the new frame: /** `stack: ... arguments old-pc -&gt; ... arguments old-pc old-fp result locals` */ Entry (parms, size) { return memory =&gt; { const locals = size - parms - 3, // local variables fp = memory.length - parms - 1; // new frame's base memory.push(memory.fp, 0); // push old-fp, result if (locals) // push local variables, if any memory.push(... Array(locals).fill(0)); memory.fp = fp; // new dynamic link memory.frames.unshift(parms); // push frames stack for trace }; } The frame contains a slot for the function result, initialized to 0 (line 7 above). This slot can be treated just like a local variable but for the fact that it is only assigned to. The Exit instruction at the end of each function reverts to the previous frame pointer (line 6 below) and removes all but the return address and result value from the stack as the Return instruction expects it (lines 7 and 8): /** `stack: ... arguments old-pc old-fp result locals -&gt; ... result old-pc` */ Exit (parms) { return memory =&gt; { const fp = memory.fp; // current frame memory.fp = memory[fp + parms + 1]; // restore dynamic link memory.splice(fp, Infinity, // pop frame, push result old-pc memory[fp + parms + 2], memory[fp + parms]); memory.frames.shift(); // pop frames stack (trace) }; } return statements within the body of the function are coded as branches to the Exit instruction. Parameters and local variables have to be addressed relative to the frame pointer using two new instructions: /** `stack: ... -&gt; ... frame[addr]` */ LoadFP (addr) { return memory =&gt; memory.push(memory[memory.fp + addr]); } /** `stack: ... val -&gt; ... val | frame[addr]: val` */ StoreFP (addr) { return memory =&gt; memory[memory.fp + addr] = memory.at(-1); } } Grammar Modifications To enable semantic analysis in the actions of syntax analysis, functions have to be declared before use, and a design decision is necessary to determine the scope of declarations in a way that is compatible with the activation record stack: A function should not have access to the local variables and parameters of a different function because its frame might not exist. Functions may have access to global variables. Local names may shadow global names. For example, \"declare before use\" for variables could be done prior to functions and at the beginning of function bodies, and missing declarations could be considered errors: prog: GLOBAL { fun }; fun: head [ 'begin' [ LOCAL ] stmts 'end' ]; head: 'function' Name '(' [ parms ] ')'; parms: Name [{ ',' Name }]; Alternatively, in the absence of GLOBAL and LOCAL above, unknown names could be resolved in the closest scope, i.e., enclosing function. In this case there could be GLOBAL import declarations so that functions could share some global variables: fun: head [ 'begin' [ GLOBAL ] stmts 'end' ]; As a third alternative, unknown names could be resolved in the global scope, i.e., visible to any function unless shadowed by parameter names. In this case there could be LOCAL definitions as above so that functions can have local variables in addition to parameters. The design choice among these alternatives depends on perceived convenience vs. the wish to prevent errors due to scope violations. The little language in example 7/06 requires strict \"declare before use\" and uses global and local declarations: prog: [ vars ] funs; vars: 'var' names ';'; names: Name [{ ',' Name }]; funs: { fun }; fun: head parms [ block ] ';'; head: 'function' Name; parms: '(' [ names ] ')'; block: 'begin' [ vars ] stmts 'end'; names before all functions define global variables (lines 1 to 3 above), names in a block define local variables (line 8), and names in parms declare parameter names local to the function (line 7). begin and end delimit a block (line 8) to avoid an ambiguity between a semicolon separating statements and a semicolon terminating a function definition. On the other hand, the semicolons terminating function and variable declarations are not required to disambiguate — they are punctuation in the spirit of end, fi, and od. A forward declaration omits the function body (line 5). The number of parameters in a forward declaration has to match the function definition, the parameter names need not. A Name can be assigned to or called with function arguments in a statement, or it can be referenced and called with function arguments in an expression. The common aspects can be emphasized by changes to the grammar: assign: symbol action; action: store | call; store: '=' sum; call: args; args: '(' [ sums ] ')'; name: symbol [ args ]; symbol: Name; In addition to distinguishing the use of variable and function names, semantic analysis now has to check that the numbers of parameters and argument values agree and that a forward declaration of a function specifies as many parameters — irrespective of the actual names — as the function definition. Example 7/07 contains all semantic errors: var f, dup, dup; function undefined (); function a (); function a (dup) begin var dup; dup = 1 end; function a (x) begin var y; y = 1 end; function b () begin b = 2 end; function f () begin f = 3; g = 4 end; function main () begin a(); a = 5; undef(); dup() end; a global variable dup defined more than once (line 1), a function a declared forward with no parameters but defined with one (lines 3 and 4), a local variable dup with the same name as a parameter (line 4), a second definition for the function a (line 5), a function f with the same name as a global variable (line 7), an undefined variable g (line 7), a call to a where the number of arguments and parameters differ (line 9), an assignment to the function name a outside the function definition (line 10), an undefined function undef (line 11), a function call to the variable dup (line 12), and a forward declared function undefined (line 2) which is not defined. Infrastructure Local names can shadow global names, i.e., attributes such as type or address can differ. Therefore, a function needs a local symbol table (line 5 below): class Parameters06 extends Seven.Functions04 { get Fun () { return this.#Fun ??= class extends super.Fun { parms; // number of parameters addr; // offset of function result slot in frame #locals = new Map(); // maps local names to descriptions get locals () { return this.#locals; } set locals (locals) { this.#locals = locals; } #size = 0; // next address, frame size get size () { return this.#size; } set size (size) { this.#size = size; } Fun, the class of function descriptions in the symbol table, is extended (line 2 above). It now contains the number of parameters (line 3), the relative address of the function result in the frame (line 4), the symbol table for parameters and local variables (lines 5 to 7), and the size of the frame (lines 8 to 10). Getters and setters are used so that further restrictions on the visibility of names can be added. Code generation for functions has to be modified and extended: entry () { // defines start address, arranges slot for Entry this.start = this.owner.machine.code.push(null) - 1; } setParms () { // frame: parms, old-pc, old-fp, result if (typeof this.parms != 'undefined' &amp;&amp; this.parms != this.size) this.owner.parser.error(`${this.name} parameters: ` + `previously ${this.parms}, now ${this.size}`); this.parms = this.size; // set number of parameters this.size += 2; // leave room for old pc and old fp this.addr = this.size ++; // leave slot for result } undo () { this.locals = new Map(); // undefine parameters this.size = 0; // reset next address, frame size super.undo(); } store () { // use `StoreFP` this.owner.machine.gen('StoreFP', this.addr); } exit () { // fills Entry, generates Exit and Return this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, this.size); this.owner.machine.gen('Exit', this.parms); this.owner.machine.gen('Return'); } toString () { const names = []; this.locals.forEach(sym =&gt; names.push(sym.name)); return `function ${this.name} start ${this.start} ` + `parms ${this.parms} size ${this.size} ` + `[ ${names.join(' ')} ]`; } }; } #Fun; entry() leaves room for an Entry instruction (line 2 above). This instruction can only be created by exit() once the number of parameters and the frame size are known (lines 22 and 23). setParms() will be called once the names in the parameter list, if any, have been declared. The method ensures that declarations match (line 6), records the number of parameters, leaves room for the old frame pointer and function result in the frame, and records the address of the function result (lines 9 to 11). setParms() is called for both, a forward declaration and a definition of a function. undo() is called for a forward declaration and is extended to remove the symbol table in order to discard the parameter names in the declaration and reset the frame size so that nothing has been allocated in the frame yet (lines 14 and 15). The ReturnValue instruction is no longer used. store() uses a StoreFP instruction to copy the function result from the stack into the slot at .addr reserved by setParms() (line 19). As before, exit() generates a Return instruction, but it is also responsible for inserting the Entry and Exit instructions which require information about parameters and frame size (lines 22 to 25). Needless to say, on real hardware there would be boilerplate instruction sequences for function entry and exit which exit() would still generate. Variables can be local in a frame or global, and different instructions are needed to access their values. Therefore, Var, the class of variable descriptions in the symbol table, has to be extended, too: get Var () { return this.#Var ??= class extends super.Var { depth; // 0: global, else local constructor (owner, name, addr, depth) { super(owner, name, addr); this.depth = depth; } load () { // generate load instruction if (this.depth) // local this.owner.machine.gen('LoadFP', this.addr); else // global this.owner.machine.gen('Load', this.addr); } store () { // generate store instruction if (this.depth) // local this.owner.machine.gen('StoreFP', this.addr); else // global this.owner.machine.gen('Store', this.addr); } toString () { return `${this.name} at ${this.depth ? '+' : ''}${this.addr}`; } }; } #Var; A new property .depth differentiates between local and global variables (line 2 above). It has to be set when the variable is created (lines 4 and 5). load() and store() consult the property to create the appropriate instruction for local and global access. /** Replace: returns new `Var` at next local/global address. */ _alloc (name) { if (this.funct) // create local variable return new this.Var(this, name, this.funct.size ++, 1); else // create global variable return new this.Var(this, name, this.size ++, 0); } /** Extend: checks local then global map, returns `sym` */ _find (name, report) { let sym; if (this.funct &amp;&amp; (sym = this.funct.locals.get(name))) return sym; // local return super._find(name, report); // global } /** Replace: sets innermost map, returns `sym` */ _dcl (sym, report) { const map = this.funct ? this.funct.locals : this.symbols; if (report &amp;&amp; map.get(sym.name)) this.parser.error(`${sym.name}: duplicate`); map.set(sym.name, sym); return sym; } funct contains the description of a function exactly while the function is compiled. _alloc() uses funct to create a local variable in the frame described by funct (line 4 above) or a global variable (line 6). In each case a new address is created from the corresponding size counter. _find() uses funct to check for local names before global names (line 12). This implements shadowing. Similarly, _dcl() uses funct to declare a name in a local or global symbol table (line 19) and report duplicates, if any. _startup (main) { for (let p = 0; p &lt; main.parms; ++ p) this.machine.gen('Push', 0); super._startup(main); } Finally, _startup() has to be extended to allocate room for the parameters of the main() function (lines 2 and 3 above) before the function can be called to start execution. Statements While the grammar now unifies the use of a Name in an assignment statement and in an expression, the rule changes described earlier create a problem: assign: symbol action; action: store | call; store: '=' sum; call: args; args: '(' [ sums ] ')'; name: symbol [ args ]; symbol: Name; An assign statement operates on a symbol, i.e., a Name (lines 1 and 8 above). However, there are two possible operations (line 2): either a value is assigned to a variable (line 3) or a function is called with an argument list (line 4). Similarly, in the context of an expression, either a variable value is pushed onto the stack or — again — a function is called with an argument list (line 7). Recognition starts top-down with the start rule of the grammar, but the rules call their actions from leaf nodes such as symbol back to the start rule. It is predictable from the grammar in which exact order recognition will complete: symbol: Name; store: '=' sum; args: '(' [ sums ] ')'; call: args; action: store | call; assign: symbol action; name: symbol [ args ]; Given the order in which the actions are called, it easy to design what each action should do: rule action symbol: Name; find description store: '=' sum; if variable generate Store args: '(' [ sums ] ')'; generate code to stack each valuefinally call function call: args; nothing to do action: store | call; nothing to do assign: symbol action; pop stack name: symbol [ args ]; if variable generate Loadelse nothing to do However, there is a lack of information flow while assign is recognized, e.g., the action for symbol finds a description but the action for store will not receive it as a parameter. Similarly, the action for args seems to have no access to the description of the function to be called. Example 5/10 demonstrated that action methods should use the actions class as context to communicate with each other, i.e., symbol needs to put the description somewhere into this so that store and args — one of which is called later — can access it. this.context has to be a stack because the store and args rules both involve sum which in turn could involve another name and symbol... Therefore, this.context is implemented with get and set: get context () { if (this.#contexts.length) return this.#contexts.at(-1); throw 'no context'; //can't happen } set context (context) { // push a value, pop with null if (context) this.#contexts.push(context); else this.#contexts.pop(); } #contexts = []; The action for symbol creates a context entry (line 5 below), // symbol: Name; symbol (name) { let sym = this._find(name, true); if (!sym) sym = this._dcl(this._alloc(name)); // patch this.context = { symbol: sym }; // push symbol description return sym; } The actions for store and args access the context entry: // store: '=' sum; store (_, sum) { if (this.context.symbol.storeOk()) this.context.symbol.store(); } // args: '(' [ sums ] ')'; args (lp, sums, rp) { const sym = this.context.symbol, // to apply args to nargs = sums ? sums[0] : 0; // # of arguments if (!(sym instanceof this.Fun)) this.parser.error(`${sym.name}: not a function`); else if (nargs != sym.parms) this.parser.error(`${sym.name} arguments: ` + `expected ${sym.parms}, specified ${nargs}`); else sym.call(); // call function } Calling storeOk() ensures that assignment is allowed and store() generates the appropriate code (lines 3 and 4 above). args() ensures that a function is called (line 11) and that the numbers of parameters and argument values match (line 13) before call() is used to generate code (line 17). Finally, the actions for assign and name delete the context entry (lines 3 and 13 below): // assign: symbol action; assign (symbol, action) { this.machine.gen('Pop'); this.context = null; // pop context } // name: symbol [ args ]; name (sym, args) { if (!args) if (sym instanceof this.Fun) this.parser.error(`${sym.name}: no argument list`); else sym.load(); // variable reference this.context = null; // pop context } name() marks a function reference without arguments as an error (line 9 above). The grammar guarantees that the context stack remains balanced at all times. Just One More Next up on the way to the start rule of the grammar are function definitions. Semantic analysis and code generation for functions consist of five steps: declare a function with a local symbol table, declare parameters, define local variables, generate code for the function body, and wrap up. An action happens after all input required by the corresponding rule has been recognized. If something has to happen earlier, the rule is split into several rules to get the proper timing for the actions: fun: 'function' Name '(' [ names ] ')' [ 'begin' [ 'var' names ';' ] stmts 'end' ] ';'; This rule would have a single action — plus more for names and stmts — and it could not handle the timing of the five steps as described above. Instead: head: 'function' Name; names: Name [{ ',' Name }]; parms: '(' [ names ] ')'; vars: 'var' names ';'; block: 'begin' [ vars ] stmts 'end'; fun: head parms [ block ] ';'; This amounts to the same rule but the steps can now be assigned to different actions, here in the order in which they will happen: rule action return head [inherited] create function description, set funct symbol names [inherited] declare parameters in funct.locals count parms call setParms() to layout frame names [inherited] declare variables in funct.locals count stmts [inherited] generate code block nothing to do fun [inherited] call funct.end() or funct.undo(), pop funct It turns out that there is only one new action: parms() calls funct.setParms() to record the number of parameters and layout the function's frame. Tracing in example 7/06 confirms the order: Enter only function main(a) begin var b; print 1 end; into the . Press to represent and check the grammar, toggle , and press . Here is the redacted output: head('function', 'main') returns { function main start 0 parms undefined size 0 [ ] } names('a', null) returns 1 parms('(', [ 1 ], ')') returns undefined names('b', null) returns 1 ... fun(...) returns undefined prog(...) returns (memory, steps) =&gt; StackMachine(memory, steps) Everything is in place, we have reached the top-level rules of the grammar which remain unchanged from the previous version of the little language: prog: [ vars ] funs; vars: 'var' names ';'; names: Name [{ ',' Name }]; funs: { fun }; The actions remain unchanged, too. At the top level, funct is null; therefore _dcl() defines the variable names in the global symbol table. Example 7/08 contains mutually recursive functions just as in example 7/04, but this time one version of Euclid's algorithm takes advantage of function parameters. Tracing It is often useful to see how the frames are laid out, and what they contain when the program executes, as well as the machine instructions before and during execution. In example 7/06: Add var trace; before the definition of euclid in the to define the global variable. As usual, press to represent and check the grammar, and press to compile the executable and show the extra information: &gt; run = g.parser().parse(program, actions) 0: memory =&gt; this.Entry(2, 5)(memory) 1: memory =&gt; this.LoadFP(0)(memory) 2: memory =&gt; this.LoadFP(1)(memory) 3: memory =&gt; this.Gt(memory) ... 30: memory =&gt; this.Entry(0, 3)(memory) 31: memory =&gt; this.Input(36)(memory) 32: memory =&gt; this.Input(54)(memory) ... 42: memory =&gt; this.Call(30)(memory) 43: memory =&gt; this.Print(1)(memory) trace at 0 function euclid start 0 parms 2 size 5 [ x y ] function main start 30 parms 0 size 3 [ ] stack starts at 1 execution starts at 42 (memory, steps) =&gt; StackMachine(memory, steps) press to execute. Global variables such as trace are initialized to 0, i.e., execution will be traced: &gt; run() 0:[ 0 ] 0:[ 0 43 ] 42: memory =&gt; this.Call(30)(memory) 0:[ 0 ] 1:[ 43 0 0 ] 30: memory =&gt; this.Entry(0, 3)(memory) 0:[ 0 ] 1:[ 43 0 0 36 ] 31: memory =&gt; this.Input(36)(memory) 0:[ 0 ] 1:[ 43 0 0 36 54 ] 32: memory =&gt; this.Input(54)(memory) 0:[ 0 ] 1:[ 43 0 0 36 54 34 ] 33: memory =&gt; this.Call(0)(memory) 0:[ 0 ] 1:[ 43 0 0 ] 4:[ 36 54 34 1 0 ] 0: memory =&gt; this.Entry(2, 5)(memory) ... 0:[ 0 ] 1:[ 43 0 0 38 18 ] 28: memory =&gt; this.Exit(2)(memory) 0:[ 0 ] 1:[ 43 0 0 18 ] 29: memory =&gt; this.Return(memory) 0:[ 0 ] 1:[ 43 0 18 18 ] 38: memory =&gt; this.StoreFP(2)(memory) 0:[ 0 ] 1:[ 43 0 18 ] 39: memory =&gt; this.Pop(memory) 0:[ 0 43 18 ] 40: memory =&gt; this.Exit(0)(memory) 0:[ 0 18 ] 41: memory =&gt; this.Return(memory) 18 0:[ 0 ] 43: memory =&gt; this.Print(1)(memory) 0:[ 0 ] The output shows the machine instructions as they are executed, preceded by the frames. First, there is the global frame (line 2 above), main() is called (line 3), there are two frames, and the input values 36 and 54 are pushed onto the stack (lines 5 and 6). Then the call to euclid() happens (line 7) and there is a third frame which starts at location 4 in memory (line 8). Eventually, euclid() exits (line 10), the result value 18 is left on the stack (line 11), is assigned as result of main() and popped (lines 12 and 13), main() exits and leaves 18 on top of the stack (lines 14 and 15), ready to be printed. Example 7/08 contains several functions and, therefore, has a much more interesting trace... Block Scopes In this section the little language with local variables will be extended with block scopes for the variables. Changes to the grammar can be seen on this page, new stack machine and action methods can be seen in the method browser. At compile time a local scope is pushed on top of a global scope to implement shadowing. So far, for the little language with local variables, shadowing means that parameters and local variables owned by a function hide global variables and function names. The scope where a name is visible is either the enclosing function or the entire program. Languages like JavaScript also have block scopes, i.e., a name is visible only within the block which contains the definition. In example 7/09 some variables are declared before use and can be shadowed within blocks: var trace; function main (x) begin var a; print x; x = 1; print x; begin var b; print x; x = 2; print x end; begin var c, x; print x; x = 3; print x; main = 99 end; begin var d, x; print x; x = 4; print x end; print x end; The output is produced as follows: line code scope output 1 var trace; global 2 function main (x) main() parameters begin main() block 3 var a; print x; 0 x = 1; print x; 1 4 begin var b; print x; first inner block 1 x = 2; print x end; 2 5 begin var c, x; print x; second inner block 0 x = 3; print x; main = 99 end; 3 6 begin var d, x; print x; third inner block 3 x = 4; print x end; 4 7 print x main() block 2 8 end; global 99 The first few lines of output are no surprise. trace is a global variable, initialized to 0 (program line 1 above). x is declared as parameter of main() and the startup code sets the corresponding argument to 0. begin starts the scope for local variables of main() (line 2). x is printed, set to 1, and printed again (line 3). The first inner block does not declare another x (line 4); therefore, the parameter x is not shadowed. It is printed, set to 2, and printed again. The second, parallel, inner block declares a new x which shadows the parameter x (line 5). The local variable region of the frame is initialized to 0; therefore the inner x prints as 0, is set to 3 and printed again. The third, again parallel, inner block declares another x which shadows the parameter x (line 6). In a parallel block it shares memory (by location, not by name); therefore this x prints as 3, is set to 4 and printed again. Back in the scope for local variables of main() the parameter x is still 2 and is printed as such (line 7). Deeply nested in the second inner block the result of main() was set to 99 (line 5) and that is printed by the startup code. Example 7/09 demonstrates shadowing: there are exactly two memory slots for various versions of x. The inner two declarations for x are in parallel blocks; therefore, the two x share one memory slot. As usual, press to represent and check the grammar, and press to compile the executable and show the extra information provided because there is a global variable trace: &gt; run = g.parser().parse(program, actions) block [ b at +5 ] block [ c at +5, x at +6 ] block [ d at +5, x at +6 ] block [ a at +4 ] block [ x at +0 ] 0: memory =&gt; this.Entry(1, 7)(memory) ... trace at 0 function main start 0 parms 1 frame size 7 stack starts at 1 execution starts at 36 (memory, steps) =&gt; StackMachine(memory, steps) The global variable trace is at memory location 0 (line 9 above). Each block layout is displayed when recognition of the block is complete. The first inner block contains variable b at offset 5 in the frame for main() (line 2). Each of the next two inner blocks contains a variable x at offset 6 in the frame for main() (lines 3 and 4). The main() block contains variable a at offset 4 in the frame for main() (line 5). Finally, the parameter x is at offset 0 in the frame for main() (line 6). All the blocks belong to the frame for main(). The highest offset in the frame for main() is 6 (lines 3 and 4); therefore, the frame size is 7 (line 10). Note that the variables b, c, and d are declared first in the parallel inner blocks; therefore they share offset 5 in the frame for main() (lines 2 to 4). What changes if the order of d and x is interchanged in program line 6? Example 7/10 has more names, more functions, several frames, and more scopes: var a, b, c; function f (x); function d (d) begin print 100, a, d, x end; function e (a) begin print 200, a, b end; function f (a) begin a = 1; b = 2; c = 3; d(4); e(5); begin var a, b; a = 10; b = 20; print 300, a, b, c; d(40); e(50) end; print 400, a, b, c end; function main () begin c = 5; f(6) end; $ /^%% grammar/,/^%% actions/ | 07/09.eg Seven.Blocks09 Prepare the grammar and compile. There is one error. Repair it by globally defining the missing variable and a variable trace. Recompile and explain how the listing &gt; run = g.parser().parse(program, actions) block [ ] block [ d at +0 ] block [ ] block [ a at +0 ] block [ a at +4, b at +5 ] block [ ] block [ a at +0 ] block [ ] block [ ] ... a at 0 b at 1 c at 2 x at 3 trace at 4 function f start 15 parms 1 frame size 6 function d start 0 parms 1 frame size 4 function e start 8 parms 1 frame size 4 function main start 55 parms 0 frame size 3 stack starts at 5 corresponds to the following frame layouts: frame +0 +1 +2 +3 +4 +5 global a b c x trace d() d old pc old fp result e() a old pc old fp result f() a old pc old fp result a b main old pc old fp result Remove trace, compile and run the program, and explain the output: &gt; run() 100 0 4 0 200 5 2 300 10 20 3 100 0 40 0 200 50 2 400 1 2 3 0 0:[ 0 2 3 0 ] Example 7/11 contains a recursive version of Euclid's algorithm with a global trace and a rather risky use of nested blocks. var trace; function euclid (x,y) begin if x &gt; y then var gt; gt = euclid(x-y, y) else var lt; if y &gt; x then lt = euclid(x, y-x) else return x fi fi; begin var common; print common; euclid = common end end; function main (x, y) begin x = input 54; y = input 36; return euclid(x, y) end; $ /^%% grammar/,/^%% actions/ | 07/09.eg Seven.Blocks09 Compile the program and confirm that the frames are laid out as follows: frame +0 +1 +2 +3 +4 +5 global trace euclid() x y old pc old fp result gt lt common main() x y old pc old fp result Run the program and confirm that it stacks a maximum of five frames, right when 18 is returned as the greatest common divisor of 36 and 54: 0:[ 0 ] 1:[ 54 36 54 0 0 ] 6:[ 54 36 46 1 0 0 ] 12:[ 18 36 10 6 0 0 ] 18:[ 18 18 22 12 18 0 18 ] 26: memory =&gt; this.StoreFP(4)(memory) Where is the risky use of nested blocks -- why does this program produce correct results? Grammar Modifications There are a few changes to the grammar: prog: [ vars ] funs; vars: 'var' names ';'; names: Name [{ ',' Name }]; funs: { fun }; fun: head parms [ block ] ';'; head: 'function' Name; parms: '(' [ names ] ')'; block: begin [ vars ] stmts 'end'; begin: 'begin'; stmt: assign | print | return | block | loop | select; loop: While cmp Do [ vars ] stmts 'od'; select: 'if' cmp then [ else ] 'fi'; then: Then [ [ vars ] stmts ]; else: Else [ vars ] stmts; As before, global variables can be defined with a vars phrase prior to functions (lines 1 and 2 above). They can be accessed wherever they are not shadowed. As before, parameters can be declared with a names phrase enclosed in parentheses following a function name in a function declaration or definition (lines 5 and 7). They can be accessed throughout the function body as long as they are not shadowed. Parameters themselves shadow global variables. As before, a block is the body of a function (line 5); however, it can also be a statement, i.e., blocks can now be nested (line 11). A block delimits the scope of the variables defined by its vars phrase (line 8) and entered into a symbol table for the scope by the names() action (line 3). They will shadow all, global variables, parameters of the encompassing function, and variables in encompassing blocks — this is the semantics of JavaScript's let, rather than var. Similarly, variables can also be defined local to a loop body (line 12) or the then or else branch of a select statement (lines 14 and 15). Obviously, actions will have to create and discard the symbol tables which represent the scopes and it is tempting to assign these responsibilities to the vars and parms rules to create as few scopes as possible. However, a symbol table must exist exactly while the closest scope within a program is recognized which contains the names phrase, i.e., the actions for the fun, block, loop, then, and else rules are involved in managing these symbol tables. These actions happen when recognition is complete, i.e., they will discard the symbol tables, if any, but each of the corresponding rules needs a hook where an action happens early enough to create a symbol table before the names() action enters names. The obvious hooks are the literals 'var' and '(' at the beginning of the vars and parms rules; however, vars is also used to define global variables (line 1) and the global symbol table symbols is allocated as a property of the actions class. Therefore, the actions for head, begin, Do, Then, and Else will have to arrange for new scopes. Scope Management Previously, a function description contained a Map .locals for parameter and local variable names and a property .size which determined the frame size and which _alloc() uses to assign new addresses. _dcl() stores new entries in funct.locals and _find() searched funct.locals before the global symbol table. To implement block scopes, .locals has to refer to the top-most Map of a stack of symbol tables, one per nested scope, .size has to refer to the top-most address of a stack of addresses for new variables in a scope, and _find() has to search backwards through the stack of symbol tables before consulting the global symbol table. Together, these stacks describe one frame, i.e., they should be owned by the function description for the frame. It helps to create a class Block for scope descriptions which contain a Map .locals for names defined in the scope and a property .size to use for new addresses: get Block () { return this.#Block ??= class { locals = new Map(); // maps names in block to descriptions size; // next variable address in block constructor (size) { this.size = size; } toString () // ... }; } #Block; .size must be initialized when a new scope is created. Previously, .locals and .size were implemented with getters and setters and they can be overwritten in an extended function description: class Blocks09 extends Seven.Parameters06 { get Fun () { return this.#Fun ??= class extends super.Fun { frameSize = 0; // because this.size is local to blocks blocks; // block stack, [0] is innermost block get locals () { return this.blocks[0].locals; } set locals (locals) { try { return this.blocks[0].locals = locals; } catch (e) { console.trace(e); throw e; } } get size () { return this.blocks[0].size; } set size (size) { return this.blocks[0].size = size; } constructor (owner, name) { // creates outermost block super(owner, name); this.blocks = [ new this.owner.Block(0) ]; } .blocks[] is a list which represents the nested scopes (line 4 above). It is created and initialized for the scope of parameters when a function description is constructed (line 14). Parameter addresses start in the frame at 0. To simplify searching, the list will contain the scopes in order from innermost to outermost. Therefore, .locals and .size can simply be delegated to block[0] (lines 5 to 10). .frameSize is a new property because .size will not necessarily be both, the next new address and the total size of the frame (line 3). push () { // add block, start in encompassing block this.blocks.unshift( new this.owner.Block(this.blocks[0].size) ); } pop () { // remove block, maintain maximum frame size this.frameSize = Math.max(this.frameSize, this.blocks[0].size); if (this.owner.symbols.get('trace') // trace? instanceof this.owner.Var) puts(this.blocks[0].toString()); this.blocks.shift(); } end () { // [extend] pop outermost block this.pop(); super.end(); } // ... }; } #Fun; There is no need to reset .frameSize if parameters are allocated during a forward declaration for a function because the function definition will later allocate the same amount of memory. push() creates a new innermost scope (line 2 above) which will use new addresses at .size of the current scope (line 3). pop() maintains .frameSize as the maximum .size reached by all nested scopes (lines 8 and 9), displays the definitions in the scope (line 12) if there is a global variable trace (lines 10 and 11), and discards the scope (line 13). At this point .size reverts to the next outer scope, i.e., the part of the frame used by the discarded scope will be reused. Finally, end() is extended to discard the scope created by the constructor (line 17). With the block stack in place, _find() can be extended to search innermost to outermost through the symbol tables (lines 5 to 8 below) before consulting the global symbol table (line 9): _find (name, report) { let sym; try { if (this.funct) // loop inner to outer block this.funct.blocks.forEach(block =&gt; { sym = block.locals.get(name); if (typeof sym != 'undefined') throw sym; }); return sym = this.symbols.get(name); // global } catch (sym) { // found in a block if (sym instanceof Error) throw sym; // shouldn't happen return sym; } finally { if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); } } Actions Scopes manage absolute global and relative local memory addresses at compile time, frames manage memory at run time, i.e., instruction generation does not change for block scopes. There are new actions for begin and block which call funct.push() and funct.pop() at compile time, respectively, to create and discard a scope for a block as a statement or function body. Similarly, the actions for Do, Then, and Else are extended to call funct.push() and the actions for loop, then, and else are extended to call funct.pop() to create and discard their respective scopes, for example: // Do: 'do'; Do () { this.funct.push(); return super.Do(); } // loop: While cmp Do [ vars ] stmts 'od'; loop (While, c, Do, v, s, o) { this.funct.pop(); super.loop(While, c, Do); } // ... } Nested Functions In this section the little language with block scopes will be extended to permit nested function definitions. Changes to the grammar can be seen on this page, new stack machine and action methods can be seen in the method browser. Nested function definitions provide another level of scopes and shadowing, e.g., to hide details and instrumentation of an algorithm from the actual use of the algorithm. Consider example 7/12: function factorial (n) begin var f, calls; function factorial (n) begin calls = calls + 1; if n &lt;= 1 then return 1 fi; factorial = n * factorial(n - 1) end; if n &gt;= 0 then f = factorial(n); print calls; return f fi end; function main (n) begin while n &lt;= 5 do print n, factorial(n); n = n + 1 od end; The outer factorial() (line 1 above) accepts any value as an argument but only performs the requested computation for non-negative numbers (line 8). The number of calls to the inner factorial() (line 3) is counted (line 4) and reported (line 10), but the counter variable calls is hidden inside the outer factorial() (line 2). The scope of calls demonstrates that nesting functions requires a modification to the management of frames for local variables as discussed earlier: calls is not global, it is in the frame of the outer factorial(). calls is accessed from within each activation of the inner factorial(). Because of recursion, there can be many such inner activations stacked up, i.e., each inner activation needs a reference to the common outer frame. Memory use evolves: Initially there is the globals frame. Once the outer factorial() is called and itself calls the inner factorial() there are two more frames. If there are recursive calls from the inner factorial() to itself there are more and more frames stacked up. All frames are chained on the dynamic link (at left) so that the code at the function exits can clean them up in reverse order. Global variables have absolute addresses, determined at compile time. Local variables have relative addresses, i.e., offsets within their frame, which have to be added to the base address where the frame begins at run time. The offset is determined at compile time but — as the graphic indicates — the base address depends on the call history. If function definitions are nested, the inner function — i.e., frame — needs to know the base address of the outer frame. This is known as the static link (at right). It points from an inner frame to the topmost frame for the outer function which the inner function is nested into — the \"static\" nesting at compile time which determines which outer names are visible. The base address for a local variable can be found by following the static link for as many levels outward as the variable name is in a scope more outward at compile time, i.e., the deeper functions are nested the more address tracing is required to access more global variables at run time. The elements of the static link are \"somewhere\" in each frame, i.e., above the function parameters if any. Therefore, just like there is a frame pointer register there has to be a register pointing to the beginning of the static link, and it, too, has to be saved when a function is called and restored on return. An alternative implementation, the so called display, requires a single level of address tracing — at the cost of one memory slot per function nesting level in each frame. The display is the stack of currently visible base addresses for a frame, i.e., it is a copy of all elements of the static link of the frame. A display pointer register is used to locate the bottom of the display. At the bottom of the display is the address of the topmost frame for the outermost function. The top of the display is the address of the display's own frame. In summary, if parms is the number of parameters of a function and depth is the nesting level of the function, starting with 1 for global functions, the frame contains register offset content .fp → +0 ... argument values for the parameters, if any +parms the return address for the function,i.e., the previous value of .pc +parms +1 a slot for the dynamic link,i.e., the address of the frame of the caller,i.e., the previous value of .fp +parms +2 a slot for the static link,i.e., the address of the display of the caller,i.e., the previous value of .dp .dp → +parms +3 a slot for the function result +parms +3 +1 the end of the static link,i.e., the address of the outermostencompassing function's topmost frame +parms +3 + ... parts of the static link,i.e., the addresses of other encompassingfunctions' topmost frames +parms +3 +depth begin of the static link,i.e., the address of the function call's frame,i.e., the address which is also in .fp +parms +3 +depth+ ... values for the local variables and stack Global variables have absolute addresses, determined at compile time. Local variables in the current frame can be addressed relative to the base address of the current frame in .fp of the stack machine. Local variables in outer frames are addressed by using the nesting level of their function relative to the bottom of the display to retrieve the base address of the appropriate frame. Nesting levels for functions start at 1. They can be directly used as indices into the display because .dp is set to point to the function result slot at offset parms +3 which directly precedes the display. The display itself is copied to the new frame when a function is called: if the new nesting level is less than the current one, the new display is popped until it has a length equal to the new nesting level minus 1 — because only something that is visible at compile time can be called, if the nesting level stays the same, only the top entry is popped — because something at the same nesting level can access the same things which the caller can, and it cannot access the caller itself, otherwise, the nesting level can only increase by 1. In all cases the current base address from .fp — which points to the current frame — is pushed onto the new display. This section explains how nested functions are implemented in example 7/12 on top of the block scopes implemented in example 7/09. Grammar Modifications The grammar has to be modified so that function definitions can be nested: block: begin body 'end'; begin: 'begin'; body: [ vars ] [ funs ] stmts; loop: While cmp Do body 'od'; While: 'while'; Do: 'do'; select: 'if' cmp then [ else ] 'fi'; then: Then [ body ]; else: Else body; Then: 'then'; Else: 'else'; A body contains variable definitions, if any, followed by function declarations and definitions, if any, followed by one or more statements (line 3 above). The names defined within the body are only visible within the body, i.e., within the functions and statements, unless shadowed. A body is part of a block (line 1), i.e., a function definition or a block statement, and it is also part of a loop (line 5) and the then and else parts of a select statement (lines 9 and 10). Display Implementation Argument values are pushed onto the stack before a function is called. The Entry instruction at the beginning of each function has to initialize the frame as described above, given that parms is the number of parameters of the function, depth is the nesting depth, starting with 1 for global functions, and size is the memory requirement of the new frame: class Machine13 extends Seven.Machine06 { Entry (parms, depth, size) { return memory =&gt; { const locals = size - parms - 4 - depth, // local variables fp = memory.length - parms - 1, // new frame's base dp = memory.length + 2; // new display's bottom // push old-fp, old-dp, result memory.push(memory.fp, memory.dp, 0); if (depth &gt; 1) memory.push( // push part of display ... memory.slice(memory.dp + 1, memory.dp + depth) ); memory.push(fp); // push new frame's base if (locals) // push local variables if any memory.push(... Array(locals).fill(0)); memory.fp = fp; // new dynamic link memory.dp = dp; // new display's bottom }; } The frame contains a slot for the function result, initialized to 0 (line 8 above). The initial part of the display is copied from the previous frame (lines 9 and 10) and the address of the new frame is added on top (line 11). The Exit instruction at the end of each function no longer needs to know the number of parameters: Exit (memory) { const fp = memory.fp, // current frame, i.e., @arguments dp = memory.dp; // current display, i.e., @result memory.fp = memory[dp - 2]; // restore old-fp memory.dp = memory[dp - 1]; // restore old-dp // pop frame, push old-pc result memory.splice(fp, Infinity, memory[dp], memory[dp - 3]); } It reverts to the previous frame and display pointers (lines 5 and 6 above) and removes all but the return address and result value from the stack as the Return instruction expects it (lines 8). Parameters and local variables have to be addressed relative to the display pointer using two new instructions: /** `stack: ... -&gt; ... frame[depth][addr]` */ LoadDP (addr, depth) { return memory =&gt; memory.push(memory[memory[memory.dp + depth] + addr]); } Both, LoadDP and StoreDP, need to know the static nesting depth at which a variable is defined at compile time and the variable's offset in the frame. depth is used as an index into the display to obtain the appropriate frame's address which is combined with the offset (lines 4 and 10 above). The display pointer simplifies displaying memory for a trace, i.e., toString() is overwritten in the Memory class: get Memory () { return this.#Memory ??= class extends super.Memory { dp = 0; // display (static link) pointer // frames[] is no longer used toString () { let fp = this.fp, // begin of (top) frame to = this.length, // end of (top) frame dp = this.dp, // static link output = []; do { if (!dp) fp = 0; // global frame output.unshift(`${fp}:[ ${this.slice(fp, to). map(slot =&gt; this.mapSlot(slot)).join(' ')} ]`); to = fp; // end and begin of previous frame fp = this[dp - 2]; // previous frame pointer dp = this[dp - 1]; // previous static link } while (to); return output.join(' '); } }; } #Memory; } The current frame extends from the frame pointer to the end of memory (lines 7 and 8 above). The previous frame and display pointers can be obtained relative to the display pointer (lines 16 and 17). Output is collated in reverse order using unshift() (line 13). Infrastructure Nesting functions is a natural extension of block structure. However, chapter eight will show that the feature can cause a very significant complication for runtime memory management; therefore, it should be an optional part of the inheritance chain of the action classes for the little language versions. Nesting functions is implemented as a function which can be applied to extend an action class such as Blocks09 which supports block structure: const Nest13 = superclass =&gt; class extends superclass { constructor (parser, machine = new Machine13()) { super(parser, machine); } // ... }; The result of the function call Nest13(Blocks09) is a class. The function Nest13() overwrites and adds methods and properties of its argument class. In particular, by default it uses Machine13 to generate the stack machine (line 2 above). funct references the current function description. If functions are nested, this description has to be the top entry of a stack so that recognition of a nested function can interrupt recognition of the encompassing functions: get funct () { return this.functs[0]; } set funct (sym) { if (sym) this.functs.unshift(sym); // push function else this.functs.shift(); // pop function } get functs () { return this.#functs; } // current function stack #functs = [ null ]; funct is overwritten as a getter where functs[0] describes the current function (line 1 above). The list is initialized with null to indicate that there is no current function (line 8). The stack is pushed with unshift() if a function description is assigned to funct (line 3) and popped with shift() if null is assigned (line 4). Variable access uses new instructions; therefore, the class of variable descriptions has to be extended: get Var () { return this.#Var ??= class extends super.Var { load () { // [replace] load by depth if (!this.depth) // global this.owner.machine.gen('Load', this.addr); else if (this.depth+1 != this.owner.functs.length)// nested this.owner.machine.gen('LoadDP', this.addr, this.depth); else // local this.owner.machine.gen('LoadFP', this.addr); } store () { // [replace] store by depth if (!this.depth) // global this.owner.machine.gen('Store', this.addr); else if (this.depth+1 != this.owner.functs.length)// nested this.owner.machine.gen('StoreDP', this.addr, this.depth); else // local this.owner.machine.gen('StoreFP', this.addr); } toString () { // ... } }; } #Var; load() and store() use direct addressing (lines 4 and 12 above), addressing relative to the display (lines 6 and 14), or relative to the frame pointer (line 8 and 16), depending at what nesting depth the variable is defined by _alloc(): _alloc (name) { if (this.funct) // create local variable return new this.Var(this, name, this.funct.size ++, this.funct.depth); else // create global variable return new this.Var(this, name, this.size ++, 0); } For global variables, depth is set to 0 (line 6 above) Otherwise it is taken from funct (line 4). The class of function descriptions has to be extended to account for the changes in frame layout: get Fun () { return this.#Fun ??= class extends super.Fun { depth; // length of static link, 1 for global function constructor (owner, name) { // sets depth from owner.functs super(owner, name); this.depth = owner.functs.length; // functs[.. null] } depth records the nesting depth, i.e., the current length of functs[] (lines 2 and 6 above), setParms() is extended because the display pointer and the display will also be stored in the frame (lines 3 and 4 below): setParms () { // frame: parms, old-pc, old-fp, old-dp, result super.setParms(); this.addr = this.size ++; // insert slot for old-dp this.size += this.depth; // leave slots for display } storeOk() has to check all of functs[] to see if a function result is assigned within the function (line 2 below): storeOk () { // [replace] consider outer functions if (this.owner.functs.some(f =&gt; f == this)) return true; this.owner.parser.error(`${this.name}: ` + `assigned to outside function`); return false; } store () { // [replace] consider depth if (this == this.owner.funct) // local this.owner.machine.gen('StoreFP', this.addr); else // outer function this.owner.machine.gen('StoreDP', this.addr, this.depth); } LoadFP can still be used to store a function result in the current function (line 9 above) but LoadDP is necessary to store the result of an encompassing function (line 12). entry() and exit() have to be overwritten because the Entry and Exit instructions expect different arguments. More importantly, function definitions can appear at the beginning of a block, i.e., within a begin, loop, or select statement. Code which is generated during recognition of a function definition cannot easily be moved aside; therefore, nested function definitions have to be bypassed with branch instructions. One branch before the Entry of the first in a sequence of function definitions is sufficient if it lands after the Exit and Return of the last function in sequence; i.e., entry() and exit() together have to code the branch and they can share information in the Block where the sequence of functions is defined: entry () { // [extend] make room for bypass if (this.depth &gt; 1) { // nested function // remember where this is defined this.scope = this.owner.funct.blocks[0]; if (typeof this.scope.bypass == 'undefined') this.scope.bypass = // make room for bypass branch this.owner.machine.code.push(null) - 1; } super.entry(); } exit () { // [replace] uses depth, fixes bypass this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, this.depth, this.frameSize); this.owner.machine.gen('Exit'); // needs no parms info const end = this.owner.machine.gen('Return'); if (this.scope) // need to repair bypass this.owner.machine.code[this.scope.bypass] = this.owner.machine.ins('Branch', end); } A bypass branch is only required for nested functions (line 2 above). entry() is called when funct still references the encompassing function; therefore, a reference to the Block which contains the description of the new function can be stored as property .scope of the new function description (line 4). The same Block contains the descriptions of all functions defined in a sequence in the same scope; therefore, a new property .bypass in this Block can be shared by all functions in the sequence: If .bypass is undefined, entry() for the first function in the sequence allocates a slot for a branch and stores the address in .bypass (lines 5 to 7). exit() for each function checks for the shared Block and inserts an appropriate branch instruction in the .bypass slot (lines 18 to 20). The result is a single branch instruction preceding all function definitions in the same block and landing past the exit of the last of these function definitions. One last extension: function definitions have to be checked at the end of every block (line 2 below), not only once globally: pop () { // [extend] check for undefined functions this.owner._check_defs(this.locals); super.pop(); } }; } Actions The actions for block, loop, and else now receive fewer parameters than before, e.g., loop: While cmp Do [ vars ] stmts 'od'; vs. loop: While cmp Do body 'od'; The parser checks the argument count for actions; therefore, these actions have to be overwritten, for example: loop (While, cmp, Do, body, od) { super.loop(While, cmp, Do, undefined, undefined, od); } Other than that, only one more action has to be overwritten: // head: 'function' Name; head (_, name) { let sym = this._find(name); try { if (sym instanceof this.Fun) { if (sym.depth &gt;= this.functs.length) { // same nesting level if (typeof sym.start != 'number') throw true; // forward this.parser.error(`${name}: duplicate`); } // else define at deeper nesting level } else if (sym instanceof this.Var &amp;&amp; // same nesting level sym.depth &gt;= this.functs.length - 1) this.parser.error(`${name}: used as variable and function`); sym = this._dcl(new this.Fun(this, name)); // (re-)define } catch (e) { throw e; // shouldn't happen } finally { sym.entry(); // generate code for function entry return this.funct = sym; // in function } } head() defines a new Name as a function (line 13 above), generates code at function entry (line 16) and pushes the description as the new value of funct (line 17). If a prior definition for the Name can be found (line 3) it has to be investigated: The description of a function declaration at the same nesting level (line 6) without a start address (line 7) can be used to define the function, otherwise it is a duplicate name (line 8). A more global function description can be shadowed by a new local definition. A variable definition at the same level is an error (lines 10 to 12). If an error is found a local definition is created to continue recognition (line 13). _find() searches for a name beginning with the innermost Block outward through all nested scopes (line 6 below) and functions (line 4) and ending with the global symbol table (line 11): _find (name, report) { let sym; try { this.functs.forEach(funct =&gt; { // loop inner to outer funct if (funct) // loop inner to outer block funct.blocks.forEach(block =&gt; { sym = block.locals.get(name); if (typeof sym != 'undefined') throw sym; }); }); return sym = this.symbols.get(name); // global } catch (sym) { // found in a block if (sym instanceof Error) throw sym; // shouldn't happen return sym; } finally { if (report &amp;&amp; !sym) this.parser.error(`${name}: undefined`); } } forEach() can be used because scopes and functions are stored innermost first. throw is used to abort the search as soon as a match is found (line 8) and a catch clause converts the throw into a return (line 14). It is only prudent to rethrow any errors caught in this construction (line 13). Finally, an error is reported if the name cannot be found and a report was requested (lines 16 and 17). Examples Example 7/13 shows a function which uses an inner helper function to compute the factorial for non-negative numbers. There is significant shadowing: Add a global trace variable to see which names belong to which scope. Trace execution to see which variable is accessed using the display and when. Example 7/14 is yet another variant of Euclid's algorithm with a helper function which returns zero for invalid arguments. Again, there is shadowing. Example 7/15 is the variant of Euclid's algorithm with mutually recursive functions studied in example 7/08, modified to take advantage of nested functions. Example 7/16 is a variant of example 7/10 where some functions are nested. Add a trace variable to see which names belong to which scope. Compare to the previous output (below) and explain the difference: 100 1 4 0 200 5 2 300 10 20 3 100 1 40 0 200 50 2 400 1 2 3 Delete the first assignment to c and explain the difference in output. Example 7/17 is a puzzle with nested functions. Explain the output — and then add a variable definition to obtain the expected output: expected actual 3 -1 -13 -11 4 -2 4 -2 Example 7/18 demonstrates that inner functions can set the result of outer functions which they are nested into (line 4 below) — function names do act as assign-only variables: function main () begin function a (x) begin function b (x) begin function c (x) begin c = x + 1; b = x + 2; a = x + 3 end; print c(100 + x) end; print b(10 + x) end; print a(5) end; Finally, example 7/19 is another collection of semantic errors: function main (); function a (); function a (dup, dup) begin var dup; dup = 1 end; function a (x) begin var y; y = 1 end; function f () begin var g; function undef (); function main (x) begin return y end; function g () begin print 2 end; f = 3; g = 4 end; a duplicate parameter dup (line 3 above) a mismatch in parameter counts (lines 2 and 3) a duplicate function definition a() (line 4) an undefined variable y (line 7) a name g used as a variable and nested function (lines 5 and 8) an assignment to g outside the function g() because g was redefined as a function (line 9) an undefined nested function (line 10) there is a function definition for main() (line 7) but it is not global Note that a local variable can shadow a parameter (line 3). Quick Summary A programming language can be strongly typed — to be checked at compile time — or dynamically typed like JavaScript — where all values are typed and operators convert as necessary. Grammar rules can be type-aware; however, this approach to type checking fails unless there are very few mixed type operations in a language. Type checking can be done during syntax analysis and code generation for a stack machine, mostly by checking argument types for machine instructions and returning types from the actions generating the instructions. Functions require branch instructions which capture an address to return to. Recursive functions require stacking return addresses. Argument values and return values for functions can be passed on the stack machine's stack. The values of local variables for a recursive function have to be on the stack. Together with argument values, return value, return address, and other administrative information they are the activation record or frame of a function call. Local variables and parameters are addressed relative to a frame pointer or activation record pointer which is used to locate the frame and which also has to be stacked during a call to another function. The visibility of names and shadowing of global names by local names can be implemented by stacking symbol tables at compile time. Variables within the same frame in non-intersecting scopes can share memory but they are not always initialized. Nesting functions at compile time requires a static link at run time which connects the visible nested scopes for variable access. Addressing variables in encompassing scopes requires only a single level of indirection through the display which is a complete copy of the static link in each frame. If a sequence of actions within a parent rule need to share information they can use a stacked context which the first action creates and the action of the parent rule deletes. Previous: 6. Compiling Little Languages Next: 8. Functions as Values × Search results Close "},"tutorial-08-functions.html":{"id":"tutorial-08-functions.html","title":"Tutorial: 8. Functions as Values","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 8. Functions as Values First-Order Functions Stack versus Closure Chapter seven explained how to perform type checking in the actions of syntax analysis and how to compile global and nested functions into machine instructions for a stack machine simulated in JavaScript. This chapter investigates the use of functions as parameter and variable values and as function results. If function definitions can be nested the current stack machine only supports functions as parameters. Other uses of functions as values require a significant change to the stack machine's memory management. Appendix B summarizes the evolution of the stack machine and appendix C outlines the changes to the infrastructure for code generation. All classes are available from the module Eight which is built into the practice page. First-Order Functions The term first-order functions refers to the fact that they can be passed as function arguments, stored in variables, called, and returned as function results — in other words they can be used just like numbers or any other value which is manipulated by a program. Consider the following scenario for global functions with block scopes as implemented previously: var global; function x (p) begin var v; ... end x; function y (q) begin var w; ... end y; ... There is a global frame and — depending on call history — there can be frames for multiple nested calls to x and y: The dynamic link (frame pointers) is shown at left, the static link (visibility) at right. In addition to the global variables each activation of a global function can only access its own parameters and local variables, i.e., the stack of frames can handle any visibility issues no matter where a global function is called from. Global functions are first-order functions. The start address of a global function represents the function as a value — no additional information is required. As an alternative, consider the following scenario for nested functions as implemented previously: var global; function x (p) begin var v; function y (q) begin var w; ... end y; ... z(y); ... end x; function z (y) begin ... y(...); ... end z; ... x(...); ... Assume there is a call sequence through x to z where x passes function y as a parameter and where z then activates y. The diagram shows at right the display for the activation of y. It has access to the local information in x and to the global variables — because these are visible at compile time — and x is still active on the stack because it awaits a return from z which in turn awaits a return from y. As long as nested functions are only passed as parameters there are no problems if the frames are stacked. However, passing a function as a value requires both, the address of the function and the display on which the function value can be called, so that a proper display can be constructed to activate the function. Finally, consider the same setup for nested functions as before var g; function x (p) begin var v; function y (q) begin var w; ... end y; ... return y end x; function z (y) begin ... g(...); ... end z; ... g = x(...); ... z(...); ... but this time assume that a call to x returns the function y to the global variable g and during a later call to the function z the function y is activated by calling on g. The left picture shows the frame for a call to x. The center picture shows the display which any activation of y will have — the display must include a frame for x. This information would be assigned to a more global variable g. The right picture shows the situation for a call to z and from there by way of the variable g to y. There must be frames for z and y, but there also has to be the frame for x which was assigned to g together with the address of y — and this time the frame for x is no longer on the stack! This effect is known as closure and it poses a problem if a function defined at a deeper level such as y is passed outward, e.g., to g. The picture at right shows that nested first-order functions cannot be supported with the strict stack discipline which has been used for frames so far. If functions can be passed to lower depths, higher depth frames still have to exist until they can no longer be referenced — they need to be garbage-collected. This chapter will implement little languages for each of these three scenarios. Function Typing Functions and numbers are very different kinds of values, e.g., functions can be called, numbers can be added. When functions are called the arguments have to match expectations, e.g., a parameter can only be called if the corresponding argument is a function. If functions are values the little language must support an infinite number of types: functions with zero to many parameters and perhaps a result each of which can be a number or a function which in turn can have parameters and might have a result, etc. Fortunately, this infinite set of types can be described with a small grammar such as the following: prog: [ typedcls ] [ vars ] funs; typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; typedcl: Name '(' [ types ] ')' [ ':' typename ]; types: typename [{ ',' typename }]; typename: Name | 'number'; Type declarations are global and first in a program (line 1 above). The literal type introduces one or more type declarations, separated by commas and terminated with a semicolon (line 2). Each declaration describes a function type and starts with the type name (line 3). Parentheses enclose the list of zero or more parameter type names (line 4), and a colon precedes the result type name if any. The literal number is used to indicate a number as a parameter or result type (line 5). Type names need not be different from other global names because they will be stored in a separate type table. In a program, context determines if a name refers to a type. type Euclid (number, number): number, Sum (number, number): number; The example above declares each, Euclid and Sum, as a function type with two numbers as parameters and a number as result. The little typing (sub-)language defined by the grammar above is restrictive: The number and type of parameters for a function are fixed, i.e., the exact sequence of parameters of a function is declared. Types are unique based on their names, i.e., there is type identity, not type equivalence. The Euclid and Sum function types above, both, require two numbers as arguments and return a number, but they are considered different types. As a benefit, type names can be used before they are declared, i.e., there is no need for forward type declarations, and recursion is allowed, e.g., a function can be typed to return itself. number is predefined and could be replaced by a richer set of types such as string, integer, etc. main is predefined as a function without parameters and a number result. All other type names must eventually be declared. Once function types can be declared, variables and functions in the little language can be strongly typed, e.g., vars: 'var' varname [{ ',' varname }] ';'; varname: Name [ ':' type ]; type: Name | 'number'; funs: { fun }; fun: head parms [ block ] ';'; head: 'function' Name; parms: '(' [ names ] ')' [ ':' Name ]; Variables are numbers by default, but in a definition a variable name can be explicitly typed by appending a type name (line 2 above). Similarly, a function can be typed by appending a type name to the parameter list (line 7). If there is no explicit type name, the function name is the type name and the type must be declared — unless it is main. Parameters are implicitly typed because a function type declaration includes types for the parameters and the result. For example: type Euclid (number, number): number; var e: Euclid; function euclid (x, y): Euclid begin ... return 18; ... end; Given these definitions, the assignment e = euclid; would be acceptable. Global First-Order Functions In this section the little language with global functions and block scopes will be extended to allow functions as variable values, argument values, and function results. Changes to the grammar can be seen on this page, new stack machine and action methods can be seen in the method browser. Example 8/01 prints a list of values for two global functions, square() and cube(): type Calc (number): number; function square (x): Calc begin square = x * x end; function cube (x): Calc begin cube = x * x * x end; Two more global functions implement a loop to print a list of function values: up() is used if the function argument increases along the list, down() is used otherwise. They differ only in the loop condition. Here is up(): type Printer (Calc); var from, to, step; function up (calc): Printer begin var f; f = from; while f &lt;= to do print f, calc(f); f = f + step od end; Unfortunately, in this little language there is no closure, i.e., the loop range has to be captured in global variables. One more global function, loop(), initializes the loop range and returns the appropriate Printer function: type loop (number, number, number): Printer; function loop (f, t, s) begin loop = up; from = f; to = t; step = s; if step &lt; 0 then loop = down else if step = 0 then to = f; step = 1 fi fi end; Note that loop() shares nothing with the function which will be tabulated. Only the main program puts it all together by creating a Printer with loop() and immediately calling the resulting function with the function to be evaluated: function main () begin loop (1, 5, 1) (square); loop (10, 7, -1) (cube); loop (6, 7, 0) (square) end; Check out example 8/01 which demonstrates functions used as parameters and function results: Note that the type declarations have to be at the beginning of the program. Compare the loop conditions in up() and down(). Press to represent and check the grammar, press to compile the program, and press to see the result. Can you assign the loops to variables and use each twice? Grammar Modifications The compilers developed in example 7/09 and example 7/13 support nested variable definitions but the latter supports nested function definitions. Therefore, a compiler for global first-order functions is best developed as a function to extend the compiler from example 7/09. Most changes to the grammar have already been discussed above: the typing (sub-) language is included up front, function definitions are global and can include a type name, and variable names can be defined in any scope and can include a type. The main program in example 8/01 showed that it is convenient if a function result can be called immediately: loop (1, 5, 1) (square); For the grammar this means that a function name can be followed by several sets of arguments: assign: symbol action; action: store | call; store: '=' sum; call: { args }; name: symbol [{ args }]; symbol: Name; At the statement level (line 1 above) a function name must be followed by at least one set of arguments (line 4) because a function name alone cannot be a statement. In an expression (line 6), a function name without arguments refers to the function as a (constant) value, a function name with one or more sets of arguments denotes the return value of — potentially cascaded — function calls. Types Type declarations are global in the little language and they are stored in a separate type table: const Global01 = superclass =&gt; class extends superclass { get typeSymbols () { return this.#typeSymbols; } #typeSymbols = new Map(); A type description contains the type name, a list of parameter types, and a result type if any: get Type () { return this.#Type ??= class extends super.Symbol { parms = []; // list of parameter types, `null` for 'number' returns; // result type if any get isFun () { return this.parms !== null; } constructor (owner, name, parms, returns) { super(owner, name); this.parms = parms; this.returns = returns; } toString () { /* ... */ } }; } #Type; Two types are predefined and created when the singleton object with action methods is constructed: get numberType () { return this.#numberType; } #numberType; get mainType () { return this.#mainType; } #mainType; constructor (parser, machine) { super(parser, machine ?? new (Machine01(Seven.Machine06))()); this.typeSymbols.set('number', this.#numberType = new this.Type(this, 'number', null, null)); this.typeSymbols.set('main', this.#mainType = new this.Type(this, 'main', [ ], this.numberType)); } numberType is a scalar type, i.e., it has null in place of a parameter list (line 10 above). mainType is a function type with an empty parameter list and number as a return type (lines 12 and 13). The actions for the typing (sub-)language fill and check the type table: // typename: Name | 'number'; typename (name) { return name; } // types: typename [{ ',' typename }]; types (typename, many) { return [ typename ]. concat(many ? many[0].map(list =&gt; list[1]) : []); } // typedcl: Name '(' [ types ] ')' [ ':' typename ]; typedcl (name, lp, types, rp, returns) { if (this.typeSymbols.get(name)) this.parser.error(`${name}: duplicate type`); else this.typeSymbols.set(name, new this.Type(this, name, types ? types[0] : [], returns ? returns[1] : null)); } typename() returns a name (line 2 above) and types() returns a list of one or more names (lines 6 and 7). typedcl() checks if a name has already been declared (line 12) and if not builds a new entry in the type table (lines 15 and 16). At this point all the types, including number, are represented as strings. Once all declarations have been recognized the type descriptions have to be modified so that they reference each other and they have to be checked for completeness: // typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; typedcls (some) { this.typeSymbols.forEach(sym =&gt; { // check and translate types if (sym.isFun) { // avoid non-functions const check = name =&gt; { // return type description for name const type = this.typeSymbols.get(name); if (type) return type; this.parser.error(`${name}: not a type`); return this.numberType; // patch }; sym.parms = sym.parms.map(check); // convert to symbols if (typeof sym.returns == 'string') sym.returns = check(sym.returns); } }); } typedcls() looks at every function type in the type table (lines 3 and 4 above) and replaces the parameter and return type names by references to their descriptions (lines 11 to 13). Undefined type names are reported and replaced by references to number to let recognition continue (lines 6 to 9). Variables Variables now have a type which is set by an action when a variable is defined: // type: Name | 'number'; type (name) { const type = this.typeSymbols.get(name); if (type) return type; this.parser.error(`${name}: not a type`); return this.numberType; } // vars: 'var' varname [{ ',' varname }] ';'; // varname: Name [ ':' type ]; varname (...arg) { let [ name, type ] = arg; type = type ? type[1] : this.numberType; this._dcl(this._alloc(name), true).type = type; } type() checks that a type name has been declared (lines 2 to 7 above). If not, it is reported as an error and number is substituted to let recognition continue (line 6). varname() creates the variable description, enters it into the symbol table, and sets a .type property, by default numberType (lines 12 and 13). Var, the class of variable descriptions, has to be extended: get Var () { return this.#Var ??= class extends super.Var { type; // variable's type storeOk (type) { // [replace] check type if (this.type == type) return true; this.owner.parser.error(`${this.name}: ` + `expects ${this.type}, not ${type}`); return false; } call () { this.load(); this.owner.machine.gen('CallValue'); } toString () { /* ... */ } }; } #Var; Assignment is only allowed if the value to be stored and the variable have identical types (lines 4 to 9 above). call() implements code generation if a variable is called as a function (line 11): load() pushes the variable's current value onto the stack and a new instruction CallValue branches to that value and replaces it on the stack by the return address, similar to Call. Functions Functions now have a type which is set in the function declaration because it has to be known even for a forward declaration: // fun: head parms [ block ] ';'; // head: 'function' Name; // parms: '(' [ names ] ')' [ ':' Name ]; parms (lp, names, rp, name) { // funtion's name is default type this.funct.setParms(name ? name[1] : this.funct.name); } The function type name is recognized together with the parameter list. It is either an explicit type name or the name of the function (line 5 above). The parms() action calls setParms() to store the type as part of the description of the current function. Fun, the class of function descriptions, has to be extended: get Fun () { return this.#Fun ??= class extends super.Fun { type; // function's type loads = []; // forward references to push setParms (name) { // [replace] sets parameter types this.parms = this.locals.size; // may be wrong, see below this.size += 2; // leave room for old pc and old fp this.addr = this.size ++; // leave slot for result try { const type = this.owner.typeSymbols.get(name); if (!type) throw `${name}: not a type`; if (!type.isFun) throw `${name}: not a function type`; if (this.type &amp;&amp; this.type != type) throw `${name} ${this.name}: ` + `previously declared as ${this.type.name}`; if (type.parms.length != this.locals.size) throw `${name} ${this.name} arguments: expects ` + `${type.parms.length}, receives ${this.locals.size}`; this.type = type; let n = 0; // Map.forEach does not provide n this.locals.forEach(parm =&gt; parm.type = type.parms[n ++]); } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(e); // report an error } } // ... }; } #Fun; setParms() is extended to set the function's type (line 19 above) — which must match a previous declaration, if any (line 13) — and assign types to the parameter names. When setParms() is called the symbol table .locals contains the parameter descriptions. Map's forEach() visits entries in insertion order, corresponding to the types in the function type's parameter list, if any. The types are copied to the parameter descriptions (lines 20 and 21 above). Errors are reported and number is substituted as necessary to continue recognition. The function type has to be checked when a return value is assigned: storeOk (type) { // [extend] checks type try { if (this.type.returns) { // return value expected? if (!type) // no return value? throw `must return ${this.type.returns}`; else if (this.type.returns != type) // wrong type? throw `expects ${this.type.returns}, not ${type}`; } else if (type) // return value not expected? throw `doesn't return a value`; return super.storeOk(); // inside function? } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(`${this.name}: ${e}`); return false; } } storeOk() now has to be called with the type of the value to be returned which has to match the expected returns type (lines 3 to 9 above) and, as before, assignment is only allowed within the current function (line 10). In an expression a function name can be specified without arguments to denote the function as a value which might be assigned or passed as an argument, i.e., just like Var, the class of variable descriptions, Fun, the class of function descriptions, has to support a load() operation which generates code to put a function value onto the stack. At this point, for global functions, this means that the function's start address has to be pushed onto the stack (line 3 below) — even if it is not yet known: load () { // generates 'Push start' if (typeof this.start == 'number') this.owner.machine.gen('Push', this.start); else this.loads.push(this.owner.machine.code.push(null) - 1); } end () { // [extend] resolves loads const push = this.owner.machine.ins('Push', this.start); this.loads.forEach(p =&gt; this.owner.machine.code[p] = push); this.loads.length = 0; super.end(); } Just as for the call() and return() methods, if the address is not yet known, load() reserves a code memory slot and stores the address in a list (line 5 above) so that the correct instruction can be inserted by end() when the function definition is completed (line 10). Names A name can be recognized as the source of a value or as the target of an assignment: // symbol: Name; // name: symbol [{ args }]; name (sym, args) { const context = this.context; this.context = null; if (args) return context.type; sym.load(); return sym.type; } // assign: symbol action; // action: store | call; // store: '=' sum; store (_, sum) { if (this.context.symbol.storeOk(sum)) this.context.symbol.store(); } // call: { args }; Chapter seven discussed that the symbol() action sets up a context with a reference to the Name, intended to be available during recognition of args or store and discarded by the actions for either name or assign. Chapter seven also indicated that for type checking during recognition the actions have to indicate what type results from the generated code. Therefore, if there are no arguments applied to a Name, the name() action asks the Name's description to generate code to push the appropriate value onto the stack (line 6 above) and it returns the type declared for the Name (line 7). If there are arguments, the args() action is responsible for leaving a result type in the context which name() will return (line 5). Note that both, a variable or a function description, have a .type property and support a load() operation. A result type will eventually be returned by the action for sum and the store() action passes it to storeOk() to check if an assignment is possible (line 14) which store() will generate code for (line 15). Again, a variable or a function description, both, support the storeOk() and store() operations. The main program of example 8/01 contains cascaded function calls, e.g., loop (1, 5, 1) (square); In this case there are two argument lists which have to be recognized by two successive args() actions — and there could be many moreL // args: '(' [ sums ] ')'; args (lp, sums, rp) { const args = sums === null ? [ ] : sums[0]; // list of types const type = 'type' in this.context ? // chained call if true this.context.type : this.context.symbol.type; try { if (!type) throw 'too many argument lists'; if (!type.isFun) throw 'not a function'; if (type.parms.length != args.length) throw `arguments: ${type.parms.length} expected, ` + `${args.length} specified`; const errors = []; type.parms.forEach( (parm, n) =&gt; { if (parm != args[n]) errors.push( `argument ${n+1} is ${args[n].toString()}, ` + `not ${parm.toString()}` ); }); if (errors.length) throw errors.join('; '); if ('type' in this.context) { // chained call this._lift(args); // move function address past arguments this.machine.gen('CallValue'); // call address on stack } else this.context.symbol.call(); // call function/variable } catch (e) { if (e instanceof Error) throw e; // should not happen this.parser.error(`call to ${this.context.symbol.name}: ${e}`); } this.context.type = type ? type.returns : null; // result type } args() is called after sums() has generated code to push argument values onto the stack and it is responsible for type checking (lines 3 to 18 above), generating the actual function call (lines 19 to 22), and determining the result type (line 27). As discussed above, the sum() action will return the type of the value which the generated code produces. Therefore, sums() will return a list of types and args() matches this list to the parameters which the function expects (lines 13 to 17). The first of a sequence of argument lists is applied to a name and context.symbol contains the description of the name — which can be a variable or a function, but which must have a function type. For subsequent argument lists, context.type must contain the type which the preceding argument list produced. Therefore, args() stores the result type as context.type for next time (line 27) and fetches its function type from context.type, if any, or from the name described in the context (lines 4 and 5). Given that type, parameter checking is straight-forward (lines 7 to 18). The first of a sequence of argument lists is applied to a name, i.e., code for the actual function call is generated by the call() operation of the name's description (line 22) — both, variables and functions now support this operation. For each subsequent argument list the code generated for the preceding argument list has (hopefully) resulted in a function value on top of the stack. Unfortunately, code for the subsequent argument list will push the argument values on top of that function value. Therefore, the function value has to be lifted to the top of the stack (line 20) where the CallValue instruction expects it (line 21). _lift (args) { if (args.length) this.machine.gen('Rotate', args.length); } A new Rotate instruction may be needed to move the function value past the argument values to the top of the stack (line 2 above). This part of args() is encapsulated as a separate method so that it can be replaced later. Type Checking The grammar guarantees that the type table is built and checked before any code is generated; therefore, the action methods can ensure that function and number values are only used as intended. Similar to the type checking implementation in example 7/02, actions involved in expressions again have to report and check at compile time what types of values will be produced at runtime: cmp: sum rel; rel: eq | ne | gt | ge | lt | le; eq: '=' sum; ... sum: product [{ add | subtract }]; add: '+' product; ... product: signed [{ multiply | divide }]; multiply: '*' signed; ... signed: [ '-' ] term; term: input | number | name | '(' sum ')'; input: 'input' [ Number ]; number: Number; name: symbol [{ args }]; For the grammar excerpt above, recognition succeeds and the actions are called in order from bottom to top. input(), number(), and name() report to term() which, together with signed(), eventually reports to product() and from there to sum() which reports to the comparisons for the control structures and to the print and return statements. Analysis is simpler than in example 7/02 because the arithmetic and comparison operations cannot be applied to functions and there are no cast operations which could modify function types. For the most part, the action methods have to return number or function types and flag illegal operations. input() and number() return numberType. As discussed above, name() can return a function type description. term() returns the type received from it's descendants (line 2 below): // term: input | number | name | '(' sum ')'; term (...val) { return val.length &gt; 1 ? val[1] : val[0]; } // signed: [ '-' ] term; signed (minus, term) { if (minus &amp;&amp; term != this.numberType) this.parser.error(`cannot apply '-' to ${term.toString()}`); else this.parser.call(this, super.signed, minus, term); return term; } signed() accepts any type but complains if a minus sign is applied to a function (line 6 above); code generation for number values is always delegated to the superclass (line 8). // multiply: '*' signed; multiply (_, signed) { if (signed != this.numberType) this.parser.error(`cannot apply '*' to ${signed.toString()}`); else this.parser.call(this, super.multiply); } // product: signed [{ multiply | divide }]; product (signed, many) { if (many &amp;&amp; signed != this.numberType) this.parser.error(`cannot apply '*' or '/' ` + `to ${signed.toString()}`); return signed; } multiply() and the other arithmetic operators complain if they have a function as a right operand (line 3 above); they don't have to return anything. product() and sum() return a number or function type (line 13) but complain if a function is the left operand in an arithmetic operation (line 10). Finally, comparisons complain if they are applied to functions: // cmp: sum rel; cmp (sum, _) { if (sum != this.numberType) this.parser.error(`cannot compare ${sum.toString()}`); } // rel: eq | ne | gt | ge | lt | le; // eq: '=' sum; eq (_, sum) { if (sum != this.numberType) this.parser.error(`cannot apply '=' to ${sum.toString()}`); else this.parser.call(this, super.eq); } There is a small amount of semantic analysis for statements as well. As discussed above, sums() is extended to return a list with the type of each sum (lines 3 and 4 below): // sums: sum [{ ',' sum }]; sums (sum, many) { return [ sum ]. concat(many ? many[0].map(list =&gt; list[1]) : []); } // print: 'print' sums; print (p, sums) { if (!sums.every(sum =&gt; sum == this.numberType)) this.parser.error('can only print numbers'); this.parser.call(this, super.print, p, sums.length); } // return: 'return' [ sum ]; return (_, sum) { if (this.funct.storeOk(sum ? sum[0] : null)) if (sum) (this.funct.store(), this.machine.gen('Pop')); this.funct.return(); } }; The print action restricts printing to numbers (line 9 above) and then delegates to the superclass (line 11). The return action, just like the store action, calls storeOk() to see if a result value has the expected type and is even expected (line 16), and it calls store() to generate code to store the value, if any, in the result slot (line 18). Bottom line: the more types the more ways to make mistakes in a program, but also more chances to catch mistakes by type checking. And — little things to be thankful for — the control structures are not affected by function types and their actions remain unchanged. Examples This is still a compiler for the little language with block scopes and previous examples can be changed to use the new features. Example 8/02 and example 8/03 implement Euclid's algorithm from example 7/11 and example 7/08 but they refer to functions with variables. Example 8/02 shows that main() need not have the default type and, e.g., can have parameters. Example 8/04 and example 8/05 demonstrate block scopes and the effects of shadowing from example 7/09 and example 7/10. Finally, example 8/06 contains a collection of errors which semantic analysis detects: type F (), G(number), H(): number, aa(number, number): bb, bb(number): cc, cc(): H; var f, dup, dup; function undefined (): Undefined; function a (): F; function a (dup): G begin var dup; dup = 1 end; function a (x): G begin var y; y = 1 end; function b (): H begin b = 2 end; function f (): H begin f = 3; g = 4 end; function cc () begin return b end; function bb (x) begin return cc end; function aa (x, y) begin return bb end; function main () begin a(); a = 5; b = 5; undef(); dup(); dup = aa(1,2)(3)()(); dup = aa(1,2)(3)(); aa(); aa(4,5)(); aa(5,6)(7)(8) end; a duplicate variable name dup (line 3 above), an undeclared type Undefined (line 5), a forward declaration for a with a different type than the definition (lines 6 vs. 7), a duplicate definition for a (line 8), a global variable f which is redefined as a function in the same scope (lines 3 and 10), an undefined name g which has no type (line 10), a mismatch in the number of arguments when calling a (line 17), an assignment to a function name a which has no result (line 18), an assignment to a function name b outside the body (line 19), an undefined name undef without a type (line 20), a call to dup which is not a function (line 21), an assignment of a function to a variable dup which expects a number (line 23), mismatches in the number of arguments in cascades of function calls (line 24 to 26), and finally an undefined function undefined (line 5). Function Composition Example 8/07 makes an attempt at function composition, i.e., combining two functions to produce a new function: type Binary (number, number): number, Ternary (number, number, number): number, Compose (Binary, Binary): Ternary; var a: Binary, b: Binary; function add (x, y): Binary begin return x + y end; function sub (x, y): Binary begin return x - y end; function sum (x, y, z): Ternary; function compose (aa, bb): Compose begin a = aa; b = bb; return sum end; function sum (x, y, z): Ternary begin return b(a(x, y), z) end; function main () begin print compose(add, sub)(1, 2, 3), compose(sub, add)(1, 2, 3); add() and sub() are Binary functions — they accept two numbers and return their sum or difference, respectively (lines 7 and 8 above). compose() takes two Binary functions and creates a Ternary function which accepts three numbers and returns a number. The goal is that the main program (line 21) should print 0 and 2 because it should be equivalent to the following operations 1 2 add 3 sub print 1 2 sub 3 add print in postfix notation, i.e., the result of the first Binary function should be the argument of the second Binary function handed to compose(). compose() (lines 12 to 14) has to return a function. Function definitions cannot be nested in this little language, i.e., the function sum(), the result of compose(), has to be defined as a global function (lines 16 to 18). compose() stores the argument functions in two variables, a and b, which unfortunately also have to be defined globally (line 5) because they are shared between compose() and sum(). When called, sum() will apply a to it's own first two argument values and b to the result of a() and the third argument value — a fairly convoluted way to compute and print 0 and 2... Unfortunately, the following block is still part of the example and it exhibits a serious flaw: begin var as: Ternary, sa: Ternary; as = compose(add, sub); sa = compose(sub, add); print as(1, 2, 3), sa(1, 2, 3) end end; The functions assigned to as and sa are composed (line 2 above) just as before in the print statement, but this time the output is 2 and 2! The problem is that sum, the result function of compose(), applies whatever is stored in the variables a and b at the time the function is executed, not at the time it is created. The variables are global, i.e., they are shared between all uses of compose(); therefore, both function calls in the second print statement (line 3) will produce the same result. This problem will be fixed once first-order functions are nested and closure is available, see example 8/21 below. Functions as Argument Values In this section the little language with nested functions and the little language with global first-order functions will be merged to allow nested functions as argument values — but not yet as variable values or function results. Example 8/01 suffers from a similar flaw as example 8/07 just discussed above. The main program function main () begin loop (1, 5, 1) (square); loop (10, 7, -1) (cube); loop (6, 7, 0) (square) end; should work the same if it is changed to var up: Printer, down: Printer, single: Printer; up = loop(1, 5, 1); down = loop(10, 7, -1); single = loop(6, 7, 0); up(square); down(cube); single(square) Load example 8/01. Press to represent and check the grammar. Edit the main program using the text above. Press to compile the program. Do not press ! Instead, press a few times to see that the program goes into an infinite loop tabulating cube(). All functions returned by loop() share the same range because from, to, and step have to be stored in global variables. Therefore, up(square) will print one line within the first 200 steps but then down(cube) will use a positive step size in a loop condition that relies on a negative step size... Function nesting comes to the rescue because it allows to hide the range. Example 8/08 retains the type declarations for Calc and Printer and the function definitions for square() and cube() type Calc (number): number; type Printer (Calc); function square (x): Calc begin square = x * x end; function cube (x): Calc begin cube = x * x * x end; function main () begin loop(1, 5, 1, square); loop(10, 7, -1, cube); loop(6, 7, 0, square) end; but up() and down() are nested into loop(): type loop (number, number, number, Calc); function loop (from, to, step, calc) begin function up (calc): Printer begin while from &lt;= to do print from, calc(from); from = from + step od end; function down (calc): Printer begin while from &gt;= to do print from, calc(from); from = from + step od end; if step &lt; 0 then down(calc) else if step = 0 then to = from; step = 1 fi; up(calc) fi end; The functions to be tabulated and the loop construction are still separate. The range is still shared between the two Printer functions up() and down() but only one of them will actually be executed and the range, i.e., the parameters of loop(), cannot be reused. Example 8/08 requires function nesting (e.g., up() and down() in loop()) and the ability to pass a function as an argument value — even over several levels (e.g., calc() into loop() and then into up() or down()). This is the second scenario discussed above and the little language can still be implemented for the stack machine using stacked frames. Press to represent and check the grammar. Press to compile the program. Press once or twice and check out how near the start of the program a new instruction PushDP is involved in creating an argument with the function value square and in calling loop(). Grammar Modifications Changes to the grammar can be seen here for the nested function compiler and here for the global first-order function compiler. Obviously, the typing (sub-)language has to be included prog: [ typedcls ] [ vars ] funs; typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; typedcl: Name '(' [ types ] ')' [ ':' 'number' ]; types: typename [{ ',' typename }]; typename: Name | 'number'; but functions can only return numbers, not functions (line 3 above). block: begin body 'end'; begin: 'begin'; body: [ vars ] [ funs ] stmts; varname: Name; fun: head parms [ block ] ';'; head: 'function' Name; parms: '(' [ names ] ')' [ ':' Name ]; loop: While cmp Do body 'od'; select: 'if' cmp then [ else ] 'fi'; then: Then [ body ]; else: Else body; Functions can be declared in every scope (line 3 above) — even at the statement level (lines 11 to 14) — and variables cannot have function types (line 5). As before, a function definition can include a type name (line 9) or default to it's own name as a type name. Finally, the rules for function calls change. A single set of arguments is all that can be applied to a function or variable name because there are no function values as results: call: args; name: symbol [ args ]; As noted above the grammar forbids that a variable name can be declared with a function value type. However, the typing (sub-)language has to allow that a parameter can have a function value type so that function values can be passed as arguments. To stick with the second scenario (no variables with function values) it has to be enforced that such parameters are read-only — the grammar itself cannot ensure that. What's in a Function Value? Previously, a function was represented by it's address in code storage because variables could only be global or local — no display was required. With function nesting the main program from example 8/08 is replaced in example 8/09 as follows: function main () begin var which; function calc (x): Calc begin if which &gt; 0 then return square(x) fi; return cube(x) end; which = input 0; loop(1, 5, 1, calc); loop(10, 6, -1, calc) end; Depending on input (line 8 above) the output will be a table of squares or cubes: loop() is handed a function calc() to be calculated (line 8). calc() is nested into main() (lines 4 to 6). Both, main() and loop(), are global. calc() depends on a local variable which, defined in main() (line 2) and therefore invisible to loop(). As the left diagram below shows, which is not reachable from loop()'s display: When loop() calls calc() the display shown at right in the right diagram above has to be constructed. calc() is nested into main(), i.e., it requires a display which contains a frame for main() and thus can reach which. Therefore, when main() sends calc() as an argument to loop() it has to send the starting code address of calc() and main()'s own display — at least up to the depth of calc() — because that covers what is visible to calc(). This is the so-called closure which calc() requires during execution. Function Value Management If functions can be nested a function value consists of information to construct the display for the function value plus the starting code address for the function. In the little language with nested functions each frame contains the display which provides access to all visible frames and the address of the current display is stored in memory.dp, i.e., a display register. This value — obtained at a point where the name of a function is visible — provides the information. In example 8/09 press to represent and check the grammar, press to compile the program, and press twice and check out how PushDP instructions at addresses 112 and 114 are involved in creating the function value for calc (start address 87) and in calling loop() (start address 18): 0:[ 130 0 0 0 0 0 1 ] 109: memory =&gt; this.Push(1)(memory) 0:[ 130 0 0 0 0 0 1 5 ] 110: memory =&gt; this.Push(5)(memory) 0:[ 130 0 0 0 0 0 1 5 1 ] 111: memory =&gt; this.Push(1)(memory) &gt; memory = run(memory, 10) 0:[ 130 0 0 0 0 0 1 5 1 3 ] 112: memory =&gt; this.PushDP(memory) 0:[ 130 0 0 0 0 0 1 5 1 3 87 ] 113: memory =&gt; this.Push(87)(memory) 0:[ 130 0 0 0 0 0 1 5 1 3 87 3 ] 114: memory =&gt; this.PushDP(memory) 0:[ 130 0 0 0 0 0 1 5 1 3 87 3 116 ] 115: memory =&gt; this.Call(18)(memory) PushDP is a new instruction implemented in the Machine08 mix-in for the stack machine: const Machine08 = superclass =&gt; class extends superclass { // stack: ... -&gt; ... dp PushDP (memory) { memory.push(memory.dp); } The instruction pushes the current display pointer onto the stack where it will form part of a function value. This instruction is first used by the _startup() method which generates the code for the initial call to a program's main() function and which has to be replaced: const Pass08 = superclass =&gt; class extends superclass { constructor (parser, machine) { super(parser, machine ?? new (Machine08(Machine01(Seven.Machine13)))()); } _startup (main) { for (let p = 0; p &lt; main.parms; ++ p) // push arguments if any this.machine.gen('Push', 0); this.machine.gen('PushDP'); // push display pointer this.machine.gen('Call', main.start); // call main function this.machine.gen('Print', 1); // print and pop } The Pass08 mix-in for the action methods by default includes the Machine08 mix-in (line 3 above). _startup() generates PushDP right before Call transfers control to main() (lines 9 and 10). A change to the structure of a function value and, in particular, to the size of a function value — two memory slots rather than one — requires changes to the Entry and Exit instructions shown below as well as changes to the classes Var and Fun which represent parameters, variables, and functions in the symbol table. Surprisingly, there are no changes to the action methods themselves. All changes can be seen in the method browser. Both, parameters and variables, are represented as Var objects. If a parameter has a function value a second memory slot is allocated for the parameter, see below. The load() method is responsible for generating code to push a parameter (or variable) value onto the stack. For function values this requires two instructions: get Var () { return this.#Var ??= class extends super.Var { load () { // [replace] load two slots for function type const load = addr =&gt; { if (!this.depth) // global this.owner.machine.gen('Load', addr); else if (this.depth+1 != this.owner.functs.length) // nested this.owner.machine.gen('LoadDP', addr, this.depth); else this.owner.machine.gen('LoadFP', addr); // local }; load(this.addr); // top:value or below:display if (this.type.isFun) load(this.addr + 1); // + top:address } Effectively, the super.load() method is turned into a local function (lines 2 to 9 above) which is called once for the parameter's memory slot at this.addr (line 10) and once again for the next address (line 11) if the parameter has a function value. The grammar cannot prevent assignment to a parameter which has a function value. Instead, storeOk() reports this as an error and does not allow an assignment: storeOk (type) { // [extend] read-only function parameters if (this.type?.isFun) { this.owner.parser.error(`${this.name}: read only parameter`); return false; } return super.storeOk(type); } }; } #Var; Functions are represented as Fun objects. The call() and load() methods are responsible for generating code to call a function or push the function value onto the stack, respectively: get Fun () { return this.#Fun ??= class extends super.Fun { call () { // [extend] generate 'PushDP' this.owner.machine.gen('PushDP'); super.call(); } load () { // [extend] generate 'PushDP' this.owner.machine.gen('PushDP'); super.load(); } Each method generates PushDP to push the display pointer onto the stack and then delegates to it's superclass method to either generate a Call or Push instruction directly or defer actual code generation until the start address is known. setParms() assigns the function type to a function description and implicitly the types to the parameters. This is where the extra memory slots are allocated to the parameters, i.e., setParms() is responsible for the layout of the frame: setParms (name) { // [replace] sets parameter types try { const type = this.owner.typeSymbols.get(name); if (!type) throw `${name}: not a type`; if (!type.isFun) throw `${name}: not a function type`; if (this.type &amp;&amp; this.type != type) throw `${name} ${this.name}: ` + `previously declared as ${this.type.name}`; if (type.parms.length != this.locals.size) throw `${name} ${this.name} arguments: expects ` + `${type.parms.length}, receives ${this.locals.size}`; this.type = type; this.size = 0; // parameter addresses start at 0 let n = 0; // Map.forEach does not provide n this.locals.forEach(parm =&gt; { parm.addr = this.size ++; // set parameter address parm.type = type.parms[n ++]; // set parameter type if (parm.type.isFun) ++ this.size; // function argument }); this.parms = this.size; // argument slots this.size += 3; // room for old pc, old fp, old dp this.addr = this.size; // address of result this.size += 1 + this.depth; // room for result, display } catch (e) { if (e instanceof Error) throw e; // shouldn't happen this.owner.parser.error(e); // report an error } } After some error checking the type is assigned (line 12 above) and this.size is reset to 0 because the parameters are at the beginning of the frame (line 13). As a Set, this.locals contains the parameter descriptions in insertion order, i.e., in the order of the types in type.parms. Each parameter receives an address and a type and if necessary an additional memory slot (lines 16 to 18). Finally, the total number of slots for the argument values is recorded in this.parms (line 20), this.addr is set to the address of the function result within the frame (line 22), and this.size is adjusted to leave room for the return address, old frame and display pointers, and the display (lines 21 to 23), so that it points to the start address for local variables, if any. When the Entry instruction at the beginning of a function is reached the stack contains the argument values, the incoming display pointer, and the return address. From that, Entry determines the new frame pointer, extracts the incoming display, saves the current frame and display pointers, and allocates a result slot (lines 5 to 8 below): // stack: ... arguments dp old-pc // -&gt; ... arguments old-pc old-fp old-dp result display locals Entry (args, depth, vars) { return memory =&gt; { const fp = memory.length - args - 2, // next memory.fp dp = memory.splice(-1, 1, memory.pop(), // retain old-pc memory.fp, memory.dp, 0 // push fp, dp, result slot )[0]; // extract incoming display memory.fp = fp; // new frame's base memory.dp = memory.length - 1; // new display's base // copy incoming display up to depth-1 memory.push(... memory.slice(dp + 1, dp + depth), memory.fp, // append new frame ... Array(vars).fill(0)); // initialize local variables }; } The new frame and display pointers are set (lines 9 and 10 above) and the new display is constructed by copying part of the incoming display (line 12) and inserting the new frame pointer (line 13). Finally, the local variables are allocated (line 14), if any. The Exit instruction at the end of a function reverses most of this: // stack: ... arguments old-pc old-fp old-dp result display locals // -&gt; ... result old-pc Exit (args) { return memory =&gt; { const fp = memory.fp; // current frame memory.splice(fp, args, // remove argument values memory[fp + args + 3]); // insert result // restore old fp dp, free rest of frame [ memory.fp, memory.dp ] = memory.splice(fp + 2, Infinity); }; } }; The argument values are discarded (line 6 above) and replaced by the result value (line 7), the old frame and display pointers are restored, and the rest of the frame is discarded (line 9). The stack now contains the result value and the return address and is ready for a Return instruction. The Entry and Exit instructions require other parameters then before. These instructions are generated by the method exit() which, therefore, has to be replaced in Fun: exit () { // [replace] new 'Entry', 'Exit' this.owner.machine.code[this.start] = this.owner.machine.ins('Entry', this.parms, // arguments this.depth, // display, variable slots this.frameSize - (this.parms + 4 + this.depth)); this.owner.machine.gen('Exit', this.parms); const end = this.owner.machine.gen('Return'); if (this.scope) // need to repair bypass this.owner.machine.code[this.scope.bypass] = this.owner.machine.ins('Branch', end); } }; } #Fun; }; Examples Example 8/10 is a nasty nested way to input three numbers, i, by default 3 (line 22 below), j, and n, by default 4 and 5 (lines 17 and 18), and return 2 * i * n + j, by default 34: type a (): number, b (number): number, c (b, number): number, d (b), e (b): number; function main () begin var i; function a () begin var n, j; function c (b, n); function e (f) begin e = c(f, 2 * n) end; function c (f, n) begin function d (f) begin c = f(n) end; d(f) end; function b (n) begin b = n * i + j end; j = input 4; n = input 5; a = e(b) end; i = input 3; main = a() end; In example 8/10 press to represent and check the grammar, press to compile the program, and press to see the result. Add a global variable trace, press again, and compare the frame layouts with the following table: offset →↓ type 0 1 2 3 4 5 6 7 8 9 depth main (): number pc fp dp 0 main() i 1 a (): number pc fp dp 0 main() a() n j 2 b (number): number n pc fp dp 0 main() a() b() 3 c (b, number): number f n pc fp dp 0 main() a() c() 3 d (b) f pc fp dp 0 main() a() c() d() 4 e (b): number f pc fp dp 0 main() a() e() 3 Each table row is a frame where the display contains references such as main() to the corresponding frames. Example 8/11 is yet another take on Euclid's algorithm: type euclid (number, number): number; type Runner (Run): number, Run (number): number; function euclid(x, y) begin function run (run): Runner begin return run(y) end; if x &gt; 0 then if y &gt; 0 then function euclid (y): Run begin euclid = x; if x &gt; y then x = x - y; euclid = euclid(y) fi; if y &gt; x then euclid = euclid(y-x) fi end; return run(euclid) fi fi end; function main () begin print euclid(-36, -54); main = euclid(input 36, input 54) end; The actual algorithm is in the helper function euclid() (line 10 above) which shares x with the global function euclid() (line 4). The helper is executed by the Runner (line 5) if the parameters for the global function are positive (lines 7 and 8) and receives y from the Runner (line 5) and from recursive calls (lines 12 and 13). Admittedly contrived, but there is a nested function as an argument value (line 16)... As an aside, if a parameter is non-positive the global function does not reach the return statement (line 16) and the result is zero because that is set up by Entry. Example 8/12 builds a deeper display: type F (number), G (number, H), H (number): number; function x (a, f): G begin function y (b): F begin function z (c): F begin print 111, a, b, c, f(222) end; z(b+1) end; y(a+1) end; function a (a): F begin function b (b): F begin function c (c): F begin function d (d): F begin function e (e): H begin function f (f): H begin print a, b, c, d, e, f; return f+1 end; x(e+1, f) end; e(d+1) end; d(c+1) end; c(b+1) end; b(a+1) end; function main () begin a(1) end; The main program calls a() (line 23) which results in a chain of calls (line 21 back to line 18) until e() passes the function f() to x() (line 17). x() builds another chain of calls (lines 8 and 7) until z() calls the parameter function (line 6) with the argument 222. The parameters are incremented along the chains and the expected output is 1 2 3 4 5 222 111 6 7 8 223 0 The first line of output is printed by f() (line 16) before the second line is printed by z() (line 6); the last line is printed by the code generated by _startup(). f() is passed once as a parameter and called once. Press or a few times to see the frames evolve. Example 8/13 is a typed version of example 7/17 with three function values as arguments which are defined at different depths. type f (number, number), add (number): number, set (number), sub (): number, out (), act (add, sub, out); var g; function f (x, y) begin var a; function add (a); function set (z) begin var s; function sub() begin sub = x - y - z end; function out () begin print a, s; if s &lt;&gt; -2 then set(1) fi end; function act (add, sub, out) begin a = add(z); s = sub(); out() end; act(add, sub, out) end; function add (p) begin add = x + y + p end; set(g) end; function main () begin g = 10; f(1,2) end; act() does the actual work (line 19 above) and receives three function values (line 21) which were defined at different depths. Use to observe function values on the stack and stored locally. Finally, the following program fragment can be used to demonstrate that assignments to number parameters are allowed (line 7 below) and assignments to parameters with function values (line 4) or mismatched types (line 5) are reported as errors: type a (number, f), f (); function a (n, f) begin function a (nn, ff) begin f = ff; f = 1; n = ff end; n = 10 end Nested first-order Functions In this section the restrictions on typing in the little language with functions as argument values will be removed to allow nested functions as variable and argument values and function results. Nesting first-order functions is the third scenario discussed above and it can be implemented for the stack machine as long as the frames are garbage-collected. Nested first-order functions are used everywhere in JavaScript, i.e., garbage collection is readily available. In this section frames are implemented as arrays which JavaScript will manage dynamically as needed. One could say that nested first-order functions finally push the envelope of the \"stack\" machine... Grammar Modifications In the previous section the little language was restricted so that functions could only be passed as argument values. This restriction is now removed. Changes to the grammar can be seen here for the compiler from the previous section. The typing (sub-)language has to be changed to again allow function types as result types: typedcl: Name '(' [ types ] ')' [ ':' typename ]; typename: Name | 'number'; Variables can be typed, in particular, with function types: varname: Name [ ':' type ]; type: Name | 'number'; Finally, the rules for function calls change. More than one set of arguments can be applied to a function or variable name because function values as results are available: call: { args }; name: symbol [{ args }]; Memory Management It even turns out that frame management is simplified by using JavaScript arrays. Global variables and the value stack remain in memory which now has the following layout: memory use .pc register next address in code to execute .fp register null or Array of current frame [ 0 ... values of global variables ... ] stack All machine instructions are functions manipulating memory, i.e., the stack will remain at the end of memory, independent of what happens with the frames. However, argument values handed to parameters during a function call become part of the function's frame, i.e., they will have to be moved. The layout of a frame is as follows: frame[] use 0 return address in code for function call 1 null or Array of previous frame 1+1 ... arrays of visible frames 1+depth Array of this frame (at depth) 2+depth result value of function call 3+depth extra slot, exactly if result value is function value ... argument values ... frame size-1 local variable values All administrative information can be reached at fixed (relative) addresses within each frame, i.e., the display pointer register memory.dp is no longer used. A frame references itself because it contains it's own address at the end of the display. Machine14 is a new mix-in which replaces Machine08 to support first-order function values. It contains new instructions to deal with frames: const Machine14 = superclass =&gt; class extends superclass { // stack: ... -&gt; ... fp PushFP (memory) { memory.push(memory.fp); } // stack: ... -&gt; ... frame[depth][addr] LoadGC (addr, depth) { return memory =&gt; memory.push(memory.fp[1 + depth][addr]); } // stack: ... val -&gt; ... val | frame[depth][addr]: val StoreGC (addr, depth) { return memory =&gt; (memory.dirty = memory.fp[1 + depth])[addr] = memory.at(-1); } PushFP pushes the current frame pointer, i.e., null or an Array value, onto the stack (line 4 above). This instruction replaces PushDP when a function value is created. LoadGC replaces both, LoadFP and LoadDP, to push a value from a frame onto the stack using the display within the current frame (line 9). StoreGC replaces both, StoreFP and StoreDP, to copy a value from the stack into a frame using the display within the current frame (lines 14 to 15). memory.dirty acts as a register which — for the benefit of tracing execution — is set whenever a frame is modified by StoreGC. It contains the Array which was last modified. The Entry and Exit instructions are responsible for the setup and tear-down of a frame. They have to be modified once the layout of a frame is changed: // stack: ... arguments fp old-pc // -&gt; ... | frame: old-pc old-fp display result arguments locals Entry (args, depth, result, vars) { return memory =&gt; { const frame = [ memory.pop(), memory.fp ]; // old-pc, old-fp frame.id = memory.newId; // label new frame if (depth &gt; 1) // push (part of) incoming display, if any frame.push(... memory.pop().slice(1 + 1, 1 + depth)); else memory.pop(); // pop frame frame.push(frame); // push new frame's base frame.push(... Array(result).fill(0)); // push result value if (args) // move arguments to frame frame.push(... memory.splice(- args, Infinity)); if (vars) // create local variables frame.push(... Array(vars).fill(0)); memory.dirty = memory.fp = frame; // new fp }; } Entry creates a new array for the frame (line 5 above). A property .id with a unique sequence number taken from memory.id is attached (line 6) so that the frame arrays can be identified in a trace. Unless the called function is global, i.e., at depth 1 (line 7), most of the new display is copied from the display in the incoming frame (line 8) which is now at the top of the stack because the return address has been popped off earlier (line 5). This concludes access to the incoming frame which was part of the function value referencing this Entry instruction. The new frame array is assigned to the top of the new display (line 10). The slot(s) for the function result are allocated following the display (line 11). If there are argument values (line 12) they are popped off the stack and moved to the new frame (line 13). If there are local variables (line 14) they are allocated next (line 15). Unlike memory the size of the new frame array is now fixed. Finally, the array is set as the new frame pointer and recorded in memory.dirty in case execution is traced (line 16). // stack: ... | frame: old-pc old-fp display result ... // -&gt; ... result old-pc | fp: old-fp | frame unchanged Exit (depth, result) { return memory =&gt; { memory.push( // push result ... memory.fp.slice(2 + depth, 2 + depth + result), memory.fp[0]); // push old pc memory.fp = memory.fp[1]; // set previous frame }; } The use of arrays as frames significantly simplifies Exit. The result value and the return address are pushed onto the value stack (lines 5 to 7 above) where the immediately following Return instruction expects it. The frame pointer is restored from the old value in the frame (line 8). Done — the frame array is silently abandoned. Unless a function value with the frame was created in the course of activation, JavaScript will reclaim the space eventually; otherwise, the array can be referenced as long as such a function value is among the values accessible to the program. Execution Trace The memory array still holds the global variables and the stack but the Memory class needs some modifications to support tracing execution: get Memory () { return this.#Memory ??= class extends super.Memory { get newId () { ++ this.#id; return this.id; } get id () { // returns a letter or a sequence number return this.#id &lt;= 26 ? String.fromCharCode(96 + this.#id) : this.#id &lt;= 52 ? String.fromCharCode(64 + this.#id - 26) : String(this.#id - 52); } #id = 0; // current uniqe id For tracing, each frame array is labeled with an .id property which has a unique value maintained by memory.newId (line 3 above). The value is an upper-case letter (line 5), a lower-case letter (line 6), or a number starting from 1 (line 7). dirty = null; // frame to be displayed toString () { // [replace] global memory and dirty frame const dump = slot =&gt; slot === null ? 'null' : slot instanceof Array ? 'id' in slot ? `${slot.id}:[]` : '[?]' : slot; let result = 'mem:[ ' + this.map(dump).join(' ') + ' ] ' + `fp: ${dump(this.fp)}`; if (this.dirty) { result += ` ${this.dirty.id}:[ ` + this.dirty.map(dump).join(' ') + ' ]'; this.dirty = null; } return result; } }; } #Memory; }; Memory slots may have to be interpreted symbolically: they can contain null (line 5 above), an array reference which should have an .id property (lines 6 and 7), or a plain value (line 8). A line of trace output contains memory.toString() which at least contains a symbolic dump of memory (line 9) and the current value of the frame pointer (line 10). The most recently changed frame is referenced in memory.dirty and if there is one it's symbolic dump is added to the trace (lines 12 and 13) and memory.dirty is cleared (line 14). If there is no trace, the very last line in the after a contains the last dirty frame. As an example consider the main program in example 8/14 begin var printer: Printer; printer = loop(1, 5, 1); printer(square); printer(cube) end which computes tables of squares and cubes, similar to earlier examples. Press to represent and check the grammar, press to compile the program, and press to see the the first few trace lines: mem:[ ] fp: null mem:[ null ] fp: null 125: memory =&gt; this.PushFP(memory) mem:[ null 127 ] fp: null 126: memory =&gt; this.Call(0)(memory) mem:[ ] fp: a:[] a:[ 127 null a:[] 0 0 0 ] 0: memory =&gt; this.Entry(0, 1, 1, 2)(memory) mem:[ ] fp: a:[] 1: memory =&gt; this.Branch(100)(memory) mem:[ 1 ] fp: a:[] 100: memory =&gt; this.Push(1)(memory) mem:[ 1 5 ] fp: a:[] 101: memory =&gt; this.Push(5)(memory) mem:[ 1 5 1 ] fp: a:[] 102: memory =&gt; this.Push(1)(memory) mem:[ 1 5 1 a:[] ] fp: a:[] 103: memory =&gt; this.PushFP(memory) mem:[ 1 5 1 a:[] 105 ] fp: a:[] 104: memory =&gt; this.Call(20)(memory) mem:[ ] fp: b:[] b:[ 105 a:[] a:[] b:[] 0 0 1 5 1 ] 20: memory =&gt; this.Entry(3, 2, 2, 0)(memory) memory is initially empty and the frame pointer is null (line 1 above). The first two instructions call main() where Entry builds the first frame represented as a:[] (line 4). This frame contains the return address 127, the previous frame pointer null, a display of length 1 which just represents it's own frame a:[], a slot for a number result, and two slots for the local variable printer. The code now pushes the arguments 1, 5, and 1 onto the stack and calls loop() where Entry builds the second frame represented as b:[] (line 11). This frame contains a longer display which ends in b:[], followed by two slots for the function value result of loop(), and followed by the arguments moved off the stack. memory itself is empty and the frame pointer references b:[]. Other Modifications Based on the little language with global first-order functions, i.e., on the Global01 mix-in, this little language with nested first-order functions results in two major changes: function values require two memory slots and frames are arrays. The stack machine has a different frame layout and new instructions as discussed above. These require changes to the classes Var and Fun for variable and function representations and changes to some action methods. Most of the changes are very similar to the changes made for the little language with functions as argument values. This section describes each change and includes links, marked with ³, to the method browser where the new code can be directly compared to the corresponding code for the little language with functions as argument values. Variables are represented as Var objects. The load() method generates code to push a variable value onto the stack. It now has to generate LoadGC instructions for parameters and local variables and it takes two instructions for a function value. The store() method generates code to copy the top value on the stack to a variable. It now has to generate StoreGC instructions for parameters and local variables and it takes two instructions for a function value. Functions are represented as Fun objects. The call() method generates code to call the function. The load() method generates code to push a reference to the function onto the stack. Both now include the current frame pointer which requires a PushFP instruction. The store() method generates code to copy a value from the top of the stack to the slot(s) for the function's result value in the frame. This now requires one or two StoreGC instructions. The setParms() method has to assign types to the function parameters and define their addresses within the frame. This is now based on the new frame layout. The exit() method has to generate the new Entry and Exit instructions and accommodate function values, i.e., two memory slots, for function results. The _startup() method generates code to call main() which now requires a PushFP instruction. The varname() action method is responsible for defining a variable which includes creating a Var object and allocating a global or local memory slot. This now requires an additional memory slot for function values. The grammar rules assign: symbol action; action: store | call; ensure that both action methods, store() and call(), will be followed by a call to the assign() action method which generates a single Pop instruction to remove the result from the top of the stack. The store() and call() action methods now have to consider that function values require two slots on the stack and generate an additional Pop instruction. storeOk() reverts back, allows assignment for equal types, and no longer prevents assignment to parameters with function values. The _lift() method generates code to move a function value past it's arguments to the top of the stack when function calls are cascaded. It now has to move two slots for the value and it has to consider that function values among the arguments require two slots in order to compute where the value is on the stack. Finally, the return() action method is responsible to generate code to remove the return value of a function from the stack after it has called store() to set the value, if any, in the frame. It now has to consider that function values require two slots on the stack. Closure Examples Example 8/14 revisits the loop and Printer functions implemented in example 8/01 and improved in example 8/08. Thanks to function nesting and therefore closure, creation and repeatable use of a loop range can be separated and the range shielded from modification: type loop (number, number, number): Printer, Printer (Calc), Calc (number): number; function main () begin function square (x): Calc begin square = x * x end; ... function loop (from, to, step) begin function up (calc): Printer begin var f; f = from; while f &lt;= to do print f, calc(f); f = f + step od end; loop = up; if step &lt; 0 then function down (calc): Printer begin ... end; loop = down; ... begin var printer: Printer; printer = loop(1, 5, 1); printer(square); printer(cube) end end; Prepare the grammar and compile the program as usual. Press once and observe that at code address 20 (begin of loop()) frame b:[] contains the loop range 1 5 1. Press once more and observe that at code address 48 frame b:[] and address 22 are the function value of up() stored as result in loop()'s frame b:[]. Press twice more and follow how this value ends up as value of printer at the end of main()'s frame a:[] at code address 107. Closure is also employed in yet another implementation of Euclid's algorithm in example 8/15: type Euclid (number, number): Run, Run (): number; function euclid (x, y): Euclid begin function fail (): Run begin return 0 end; function euclid (): Run begin if x = y then return x fi; if x &gt; y then x = x - y else y = y - x fi; euclid() end; if x &gt; 0 then if y &gt; 0 then return euclid fi fi; return fail end; function main () begin var run: Run; run = euclid(36, 54); print run(), run(), euclid(0, 1)() end; For positive arguments euclid() returns a function (line 13 above) which needs no arguments and recursively performs the calculation when called (lines 7 to 11). If an argument is non-positive the returned function (line 14) does nothing (line 5). Find all three uses of first-order functions in this example. The default output is 0 18 0, rather than 18 18 0. Why? run() is a function without arguments, computed in line 18 and called twice in line 19. How can it produce two different results? It takes one word to repair the program... Example 8/16 is intended as a testbed for closure: type a (), b (), c (), x (); var f: c; function x () begin print 3; f() end; function a () begin var a; function b () begin var b; function c () begin print a, b end; b = 1; f = c end; a = 2; b() end; function main () begin a(); x() end; Unchanged, it outputs a line containing 3 (line 3 above) and a line containing 2 and 1 (line 8). Press . The last line of output mem:[ c:[] 13 ] fp: null e:[ 6 d:[] b:[] c:[] e:[] 0 ] shows the last modified frame e:[] which has to belong to a call to c() because the display has three entries. Press to see this frame e:[] when c() is called from code address 5 and entered into at code address 13. Why is this the last modified frame? As one test, move c() out of b() to a lower depth, modify the print statement to account for arguments which are no longer in scope, step execution, and check the frames again. Example 8/17 is a nesting puzzle: type F (), Fr (): number, Fv (number), Fvr (number): number, Ffr (Fr): number; var add: F, sub: Fvr, mul: Fvr, div: Fvr; function a (a): Fv begin function b (): Fr begin var x, y; function c (x): Fvr begin function a (): F begin print 100, x + y end; function s (s): Fvr begin return x - s end; function m (m): Fvr begin return x * m end; function d (d): Fvr begin return x / d end; add = a; sub = s; mul = m; div = d; y = input 36; c = x end; x = input 54; print 200 + a, c(x); b = y end; function d (d): Ffr begin a = 2 * a; return d() end; print 300 + a, d(b) end; function main () begin a(1); add(); print 400, sub(2), mul(3), div(4) end; The default output is 202 54 301 36 100 90 400 52 162 13.5 0 mem:[ e:[] 6 e:[] 14 e:[] 23 e:[] 32 ] fp: null i:[ 142 a:[] b:[] d:[] e:[] i:[] 13.5 4 ] The post-mortem dump of memory (lines 6 and 7 above) shows that the function values for the four innermost functions a, s, m, and d in the four global variables add, sub, mul, and div share the same frame e:[] which belongs to the call to the function c() because the function values were assigned in c() (line 10 in the program). Frames a:[] and b:[] belong to the initial calls to main() and from there to a() (line 19 to line 3). The last modified frame i:[] is at depth 4 and contains the result value 13.5, i.e., it belongs to the call to the variable div (line 19) which contains the function value of d() (line 10); 4 in that frame is the argument value (from line 19); the modification is the setting of the result value at code address 36. Currying Example 8/18 demonstrates a pattern for Currying, i.e., transforming a function with multiple arguments into a sequence of single-argument functions. Javascript can do this in a very elegant fashion: const f = (a, b, c) =&gt; a + b * c; const g = a =&gt; b =&gt; c =&gt; a + b * c; f(1, 10, 100) == g(1)(10)(100) In the little language the intermediate steps have to be named and typed in the spirit of this piece of JavaScript code: const h = a =&gt; { const g = b =&gt; { const i = c =&gt; a + b * c; return i; } return g; }; f(1, 10, 100) == h(1)(10)(100) Note that the last line in both JavaScript fragments is true. To curry functions with up to four arguments, example 8/18 changes the tokens definition to allow for alphanumeric names { Number: /0|[1-9][0-9]*/, Name: /[a-zA-Z][a-zA-Z0-9]*/ } and declares types to define the Curry operations: type f (number): number, f2 (number, number): number, f3 (number, number, number): number, f4 (number, number, number, number): number, curry (f2): ff, ff (number): f, curry3 (f3): fff, fff (number): ff, curry4 (f4): ffff, ffff (number): fff; Types f through f4 describe functions with one or more number parameters which produce a number result. Types ff through ffff describe functions with a single number parameter which can be cascaded. The curry types describe functions which perform the Curry transformations for functions with two to four number arguments. main() illustrates how functions with these types can be used: function main () begin function f2 (a, b) begin return a + b end; function f3 (a, b, c) begin return a + b * c end; function f4 (a, b, c, d) begin return (a + b) * (c - d) end; print 1 + 2, f2(1, 2), curry (f2) (1)(2); print 1 + 2 * 3, f3(1, 2, 3), curry3(f3) (1)(2)(3); print (1 + 2) * (3 - 4), f4(1, 2, 3, 4), curry4(f4) (1)(2)(3)(4) end; The output is 3 3 3 7 7 7 -3 -3 -3 0 i.e., the explicit expressions, the functions with two to four parameters, and the cascaded curried functions, all, produce the same results — as expected. Example 8/18 demonstrates a design pattern: function curry (body) begin function ff (a) begin function f (b) begin f = body(a, b) end; ff = f end; curry = ff end; body is the function to be curried. There are nested function definitions, each accepts one number parameter and together they accept as many as body. Each deeper nested function is the result of the next encompassing function. Altogether, the code makes it clear that currying heavily depends on closure. Confirm that the definitions of curry3() and curry4() follow the design pattern. Press and as usual. Press and confirm that a total of 18 frames are generated. Press three times and confirm that frame r:[] — which is created at address 89 for f() in curry4() and is defined at depth 5 — in fact has a display with 5 entries. Composition Revisited Chapter 6 started with interpreting and compiling arithmetic expressions. Example 8/19 demonstrates a pattern for an arithmetic expression compiled into nested function calls: type f (number): number, f2 (number, number): number; function add (x, y): f2 begin return x + y end; Type f describes the resulting function which allows setting one \"variable\" and returns a number (line 1 above). Type f2 describes binary operators which accept two numbers and return a number (line 2). add() defines the addition operator (line 4). The main program shows how to implement the expression (x + 1) / (x - 2) * 3: function main () begin function f (x) begin f = mul( div( add(x, 1), sub(x, 2)), 3) end; print f(0), f(1), f(3) end; The resulting function f() (lines 2 to 8 above) essentially is reverse Polish notation but in reverse order, i.e., when reading from left to right and top to bottom the leaves (numbers and variables) appear in order, the operators precede their operands — and are, therefore, in reverse order at each precedence level. Nested calls arrange for operator precedence. Example 8/20 copies currying from example 8/18 and the operators from example 8/19 to demonstrate how the arithmetic expression can be implemented with curried functions: function f (x) begin var a: ff, s: ff, m: ff, d: ff; a = curry(add); s = curry(sub); m = curry(mul); d = curry(div); f = m( d( a(x)(1)) (s(x)(2))) (3) end; The order of operands and operations is the same as before; however, using the curried functions results in cascaded calls. The first compiler for arithmetic expressions developed in example 6/07 uses functional programming. It includes the following action methods for product and multiply which reduce a list of one-argument functions produced by signed into a single function using function composition: // product: signed [{ multiply | divide }]; product (signed, many) { const c = (a, b) =&gt; b(a); // function composition return (many ? many[0] : []). reduce((product, list) =&gt; c(product, list[0]), signed); } // multiply: '*' signed; multiply (_, right) { return left =&gt; memory =&gt; left(memory) * right(memory); } product() and multiply() receive functions from the signed() action method which manipulate memory. memory could be a map from variable names to variable values. product() is expected to return such a function by combining a function produced by signed() with a list of zero or more results produced by the multiply() and divide() action methods. To support list reduction, each multiply() action method returns a curried function (line 10 above) which product() composes along the list (lines 3 and 5). Example 8/21 implements this pattern in the little language with nested first-order functions. It starts with the following types: type value (number): number, leaf (number): value; value is the result of representing any arithmetic expression. It describes functions which should accept variable values and return the value of an expression. leaf describes functions num() and name() which are used to represent constants and variables: function num (n): leaf begin function value (ignore) begin value = n end; num = value end; function name (index): leaf begin function value (memory) begin var n; n = 0; while memory &gt; 10 do memory = memory - 10; n = n + 1 od; if index &gt; 0 then value = memory else value = n fi end; name = value end; num() creates a value which always returns the same number, originally specified as argument to num(). name() creates a value which will always return the same digit from it's argument; the argument to name() determines which digit it is. This is a rudimentary implementation of a memory containing single-digit integers for the names 0 and 1. type operator (value): operation, operation (value): value; operator is used to represent a binary operator such as * together with it's right-hand argument value. It returns an operation, i.e., a (curried) function which needs a left-hand argument value and returns the value of applying * to the two arguments: function multiply (rvalue): operator begin function operation (lvalue) begin function value (memory) begin value = lvalue(memory) * rvalue(memory) end; operation = value end; multiply = operation end; Function composition, finally, takes a left-hand value and an operation and returns the combined value: type compose (value, operation): value; function compose (lvalue, roperation) begin compose = roperation(lvalue) end; Given this infrastructure, here is how to construct a function f() which can evaluate the expression (x + 1) / (y - 2) * 3: function main () begin var x: value, y: value, f: value, g: value; x = name(0); y = name(1); f = multiply(num(3))(divide(sub(num(2))(y))(add(num(1))(x))); g = compose( compose( compose(x, add(num(1))), divide( compose(y, sub(num(2))))), multiply(num(3))); print x(0), y(0), f(0), g(0); print x(21), y(21), f(21), g(21); print x(43), y(43), f(43), g(43) The first implementation, f() (line 5 above), again is reverse Polish notation in reverse order, i.e., the leaves are in reverse order, the operators precede their operands, and composition is accomplished by cascading function calls. The second implementation, g() (lines 6 to 11), uses compose() and, therefore, does without reverse order and cascaded calls. The print statement evaluates the function for three pairs of values for x and y. The complete source in example 8/21 is set up for tracing. Press to represent and check the grammar and press to see how many functions are created for the example. Press and check the last modified frame in the post-mortem dump to see that over 80 frames were created: mem:[ -1 ] fp: null 29:[ 371 a:[] A:[] C:[] 29:[] 15 43 ] Change the value of trace or press a few times to find the last modification to the first frame a:[] which belongs to the last and only call to main(): a:[ 376 null a:[] 0 b:[] 20 c:[] 20 n:[] 142 C:[] 142 ] The four local variables contain function values of name() at address 20 and the value() function at address 142 nested into multiply() at address 138, each with two different frames containing different argument values. Quick Summary First-order values can be assigned to variables, sent as arguments to functions, and returned as results. Numbers and the addresses of global functions are first-order values. If function definitions can be nested, a non-global function can access frames on the static link. If frames are strictly stacked, the address of a non-global function, together with the base address of the display at the point of call, can be used as an argument value, but it cannot be supported as a full first-order value. If frames are garbage collected the address of a non-global function, together with a reference to the frame at the point of call (or just the display) is a first-order value. The display reference implements closure, i.e., a nested function has access to the variables visible at compile time with the values at the point where the value of the nested function is captured. First-order functions can be used to implement functional programming with manipulations such as composition and currying. Type checking is necessary if functions are first-order values. Type identity checking can be implemented based on a small grammar for defining unique type names and using these names to strongly type variables and functions. Type equivalence checking would require comparing ordered trees. Previous: 7. Language Features Next: 9. Compiling Grammars × Search results Close "},"tutorial-09-bootstrap.html":{"id":"tutorial-09-bootstrap.html","title":"Tutorial: 9. Compiling Grammars","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 9. Compiling Grammars What's in a Parser Generator? Grammar (De-)Constructed Among other things, chapter one defined context-free grammars and chapter two introduced the version of extended BNF to specify grammars which we have been used throughout. Given some grammar rules written in this notation, chapter three explained how to mechanically create a scanner function from a grammar to break up an input string into the literals and tokens used as terminal alphabet in the grammar. Chapter four introduced classes for objects that can represent grammar rules as trees in such a way that a grammar rule can be viewed as a function to recognize a piece of input and, in particular, the start rule will recognize sentences of the language described by the grammar. Finally, chapter five explained how the rules, i.e., recognition functions, can be augmented by action methods to translate a sentence from the input terminals into some convenient representation, or to manipulate it in other ways. All of this works as soon as the grammar rules are represented with objects from Rule and the other magic classes. This chapter shows how this is done. The Grammars' Grammar Throughout, grammars have been written in a specific version of extended BNF notation. Formally speaking, the notation amounts to a language where the sentences are grammars, and as such there has to be a grammar describing this language. Indeed, this grammars' grammar is Grammar.ebnf, a static ingredient of the Grammar class, and it is another sentence in the language of grammars: grammar: { rule }; rule: Token ':' alt ';'; alt: seq [{ '|' seq }]; seq: { lit | ref | opt | some }; lit: Lit; ref: Token; opt: '[' alt ']'; some: '{' alt '}'; To begin with, the above is just another grammar which can be studied in example 9/01. As usual, press to represent and check the grammar and see that there are no issues — the grammars' grammar is LL(1). The output shows the usual grammar description created by Grammar.toString() with the literals ':' and ';' to separate a rule name from the right-hand side and to terminate a rule (line 2 above), the literal '|' to separate alternatives (line 3), brackets, '[' and ']', to enclose an optional list of alternatives (line 7), and braces, '{' and '}', to enclose a list of alternatives which can be repeated (line 8). Such a self-referential description tends to be confusing, but the output also shows that this grammar has two tokens, aptly named Token and Lit: Token appears in line 2 at the beginning of the grammar rule for a grammar rule (ouch!) and, therefore, corresponds to anything in the input which can be a rule name. Lit is the other token (ouch!) and appears in line 5 and by reference in line 4. From the looks of the grammars' grammar, line 4 describes what can be in a sequence; therefore, Lit must correspond to anything in the input which can be a literal. Unfortunately, lines 4 and 6 together point out a problem: Token stands for any name used in a grammar, i.e., for a rule name or a token name. One could have taken the position that any name not defined as a rule name must eventually be defined as a token name and provided with a pattern. Instead, Grammar construction requires the token definitions up front and complains if they are used as rule names. The token definitions for the grammars' grammar must be specified in the and are as expected: Lit /'(?:[^'\\\\]|\\\\['\\\\])+'/ Token /[A-Za-z][A-Za-z0-9_]*/ i.e., when represented in the input, Lit are surrounded by single quotes, with single quotes and backslashes escaped by backslashes, and Token are alphanumeric. The references Grammar.terminals, another static ingredient of the Grammar class. This suggests two experiments. In example 9/01: Press to represent and check the grammars' grammar for use. Copy the to the and press to see that the grammars' grammar recognizes itself, i.e., the grammars' grammar is a sentence in the language described by the grammars' grammar. Is it the only one? grammar is do rule end end rule is Token \\: alt \\; end alt is seq maybe do \\| seq end end end seq is do lit or ref or opt or some end end lit is Lit end ref is Token end opt is \\[ alt \\] end some is \\{ alt \\} end The grammars' grammar would not recognize the above as a sentence — literals are just backslash-escaped single characters, rules are not marked up with colons and semicolons, etc. However, you can check in example 9/02 that it just takes minor tweaks to literals and token definitions for the grammars' grammar to recognize the above as a sentence: Press to represent and check the tweaked grammars' grammar for use, and press to see that the above is a sentence for the tweaked grammars' grammar. Representing the Grammars' Grammar The examples suggest that there are different ways to spell grammar rules — there might even be extensions to the notation used so far. Example 9/03 contains: seq: { lit | ref | opt | some | parens }; parens: '(' alt ')'; This addition would allow parentheses containing one or more alternatives — just like brackets and braces — to be part of a sequence, i.e., the parentheses would arrange for precedence and we could embed alternatives for something that appears exactly once right into a sequence. If this were the grammars' grammar, a grammar for a sum could be sum: Number [{ ( '+' | '-' ) Number }]; Extending the grammars' grammar is the subject of an upcoming section. First, however, there is still the question: how does the button on the practice page represent a grammar — specified only as a string in the — with objects from Rule and all the other magic classes so that functions to perform lexical and syntax analysis based on that grammar can be called by the button? The documentation of the Grammar constructor makes it look very easy: const g = new Grammar(grammar, tokens); The construction only requires a string grammar straight from the and an object tokens which maps token names to regular expressions describing their representation. An empty string can even be mapped to a regular expression which describes everything which is to be ignored in the and the , such as white space and comments. The practice page cannot hand the string from the to the Grammar constructor directly, but it can apply eval to the string and hand the resulting JavaScript object to the constructor. So, the Grammar constructor must recognize an arbitrary grammar string as a sentence — that is a job for syntax analysis based on the grammars' grammar represented in the magic objects. If we had this representation, we could apply it to get it — a clear case of bootstrapping. A Grammar object has factory methods such as rule() which construct Rule and all the other magic objects and handle all the bookkeeping, too. A rule of the grammars' grammar such as rule: Token ':' alt ';'; is represented manually as follows: Grammar.grammar = new Grammar(Grammar.terminals); Grammar.grammar.rule(Grammar.grammar.nt('rule'), Grammar.grammar.seq([ Grammar.grammar.token('Token'), Grammar.grammar.lit(\"':'\"), Grammar.grammar.nt('alt'), Grammar.grammar.lit(\"';'\") ], null) ); Thankfully, this has to be done manually only once, for the grammars' grammar, and the resulting JavaScript code, Grammar.grammar, is another static ingredient of the class. Any other grammar — as long as it is a sentence for the grammars' grammar — is recognized using the parse() method of a Parser created by the Grammar.parser() method which only depends on the fact that the rules of the grammars' grammar have been represented using Rule and all the other magic classes, and that the grammar tree has been checked as described in chapter four. class Grammar { constructor (grammar, tokens, configuration) { ... Grammar.grammar.parser().parse(grammar, ... ); The Grammar.parser() factory method creates a Parser which calls the factory method Grammar.scanner() to create a Scanner. The Parser.parse() method accepts a string, uses the Scanner to break it up into a list of Tuple objects each of which contains an input position, part of the input string, and a Lit or Token object representing this piece of the input. Finally, the Parser.parse() method starts syntax analysis by calling the Rule.parse() method of the start rule if the terminal in the first Tuple is in the expect set of the rule. Representing Any Grammar So far, Grammar.grammar can recognize any grammar that is a sentence conforming to the grammars' grammar. However, mere recognition of some other grammar does not mean that there is lexical and syntax analysis for the other grammar. To get that, the rules of the other grammar have to be represented with Rule and all the other magic classes. This could again be done manually, but that's an error-prone process. If the Parser.parse() function can recognize grammars, it can call action methods so that grammars can be represented — using the very same classes that are involved in recognition in the first place. That is bootstrapping! The Actions class contains the action methods which are used during construction of a Grammar object for some grammar string describing a sentence conforming to the grammars' grammar: class Grammar { constructor (grammar, tokens, configuration) { ... Grammar.grammar.parser().parse(grammar, new Actions(this)); The Parser.parse() function takes the sentence string and the action methods corresponding to the rules of the grammars' grammar which build and check the trees for the rules in the sentence. All action methods have access to a new, empty Grammar object this.g, set by the constructor, and can use factory methods such as Grammar.rule() to build the trees just as it was done manually once only for the grammar's grammar. No more manual labor! The action methods of the class Actions are surprisingly simple. Each action method receives the items collected by the rule's parse() method and returns a new object. For example: // lit: Lit; lit (literal) { return this.g.lit(literal, true); } If a literal is recognized, the name is collected by the Lit object in the rule tree. The action method uses the factory method of this.g to create a Lit object for the new grammar. // ref: Token; ref (name) { if (name in this.g.tokensByName) return this.g.token(name, undefined, true); return this.g.nt(name); } Similarly, a Token object collects a name and creates either a Token or an NT object for the new grammar. // seq: { lit | ref | opt | some }; seq (some) { if (some.flat().every(node =&gt; node instanceof Opt)) throw this.g.error(some.flat().join(', ') + ': all sequence elements are optional'); return this.g.seq(some.flat(), null); } Braces collect a list of lists. Here, the content of each of the inner lists is produced by a rule, i.e., it will be new objects such as the two produced above. flat() moves these objects to the outer list. Spread syntax, i.e., ..., passes the objects collected by the braces as individual arguments to Grammar.seq(), the factory method to represent a sequence. // alt: seq [{ '|' seq }]; alt (seq, many) { return many ? this.g.alt(seq, ... many.flat(1).map(elt =&gt; elt[1])) : this.g.alt(seq); } Alternatives are easy if there is only one — it was represented as a Seq object by the previous action and it needs to be wrapped into an Alt object. Otherwise the brackets collect a list which contains the list of lists produced by the braces. many.flat() lifts the innermost lists up where map() can pick the second element of each of the innermost lists. Each elt[0] would have been the string representing the '|', each elt[1] is a Seq object. Spread syntax and the factory method Grammar.alt() take care of representing the list of alternative sequences. Alt objects never show up in a grammar tree — Alt is the hidden superclass to represent rules, brackets, and braces. The next three actions use spread syntax and factory methods to revise the representation: // rule: Token ':' alt ';'; rule (name, _, alt, s) { return this.g.rule(this.g.nt(name), ...alt.seqs); } // opt: '[' alt ']'; opt (lb, alt, rb) { return this.g.opt(...alt.seqs); } // some: '{' alt '}'; some (lb, alt, rb) { return this.g.some(...alt.seqs); } A grammar contains some rules. By now they have been collected and the factory methods have attached everything to the new grammar. Finally, the start rule action just returns the grammar, not yet checked: // grammar: { rule }; grammar (r) { return this.g; } It is up to the caller of the Parser.parse() function to check the grammar, at least far enough to create the expect sets. In retrospect, a few comments: The spread syntax ... seems unnecessary — the factory methods could have been designed to accept arrays instead. However, the grammars' grammar had to be represented manually. A look at the source of Grammar.grammar shows how requiring individual descendants as arguments facilitates nested calls to the factory methods. Creating and immediately destroying the Alt objects could have been avoided. Instead, the alt action could have returned a list of alternative sequences. However, some action is necessary to smooth out the different nesting depths of one and more alternatives. Alt objects seem to be destined to represent alternative sequences nested into a sequence when the grammars' grammar is extended with parentheses for grouping. Could there be an obstacle? Quick Summary Grammar rules can be represented as nested constructor or factory method calls to create Rule and other objects. The classes implement algorithms for grammar checking such as shallow(), deep(), and check(), and recognition, i.e., parse(). As a result. once the grammars' grammar is (manually) represented, any grammar can be recognized. Following recognition, action methods for the rules of the grammars' grammar take care of representing the rules of any grammar string which is a sentence. In summary, the grammars' grammar, once represented, can represent other grammars, and this in turn implements lexical and syntax analysis for other grammars. Their rules, too, can be augmented with actions to implement translations. Bootstrap Example Example 9/04 demonstrates that the grammars' grammar can recognize and represent itself. class Actions extends EBNF.Actions { // modify top-level action static count = 0; // count created grammars constructor () { // create next grammar super(new EBNF.Grammar(EBNF.Grammar.terminals)); this.g.count = ++ Actions.count; } grammar (some) { this.g.check(); // check next grammar puts(this.g.toString()); // display next grammar puts('count', this.g.count); // display it's count // executable uses next grammar to parse it's own rules return () =&gt; this.g.parser().parse( this.g.count % 2 ? program : grammar, Actions); } } The Actions class is extended and contains a static variable count to identify how often an object is created (lines 2 and 6 above). Whenever an object is created it uses a new, empty Grammar object (line 5). The top-level action is replaced to check and display the grammar, together with it's count (lines 10 to 12). Rather than returning the grammar it returns a function which will use the new Grammar object to parse the text in the or the and represent it using a new Actions object (lines 15 and 16). Press to represent and check the grammars' grammar. Press to let the grammars' grammar represent and check itself and store the parser from the new representation as the result in run. Press to apply this parser to the or the which both contain the grammar's grammar. Press a few more times: the count value in the increases because the grammar keeps representing itself. Extending the Grammars' Grammar The grammars' grammar can represent itself. Therefore, it is possible to extend the grammars' grammar, i.e., to modify or extend the notation in which we have been writing grammars. Example 9/05 tries to add parentheses to the notation as discussed earlier, so that alternatives can be embedded into sequences. The extended grammar's grammar is in the . The modifications are seq: { lit | ref | opt | some | parens }; parens: '(' alt ')'; Press to represent and check it: it is a sentence! The new grammar for sum sum: Number [{ ( '+' | '-' ) Number }]; is in the . The again extends the Actions class to provide a definition for Number and replace the top-level action for grammar to check and display the new grammar and return an executable which will call the Parser.parse() method based on the new grammar with a sum 1 + 2 - 3. It also contains an action for parens // parens: '(' alt ')'; parens (lp, alt, rp) { // returns the alternatives return alt; } which simply returns the Alt object to be included in the sequence. Press to represent and check the grammar for sum. Unfortunately... An Alt object cannot be a descendant of a Seq object — sequences were supposed to only contain terminals, rule references, brackets and braces. Not allowing parentheses in sequences is a syntax issue, checking that there are no other descendants is a semantic issue. The semantic check is part of the Seq constructor. A rule reference is allowed in a sequence, and a rule contains alternatives. Example 9/06, the next attempt, tries to add a hidden rule: // parens: '(' alt ')'; parens (lp, alt, rp) { // returns reference to auxiliary rule const uniq = this.g.nt(); // unique non-terminal this.g.rule(uniq, ... alt.seqs); // uniq: alt; return uniq; } The only change from the previous example is a different action for parens. This action creates a rule with a unique name and returns a reference to it which will be added to the parent sequence. Press to represent and check the extended grammars' grammar and press to let the extended grammars' grammar represent and check the new grammar for sum found in the . Unfortunately... The rule for sum got lost: the Parser.parse() method looks for a grammar, from there for a rule, alt, seq, and eventually parens — this is the stack of open calls on the parse() methods by the time we reach the new action which creates the hidden rule. This action happens to create the first Rule object ever which becomes the start rule, rather than sum. Third time is a charm: the action for parens in example 9/07 is more careful and moves the new rule to the end of the list of rules (lines 2, 8, and 14 below): class Actions extends EBNF.Actions { #hidden = []; // parens: '(' alt ')'; parens (lp, alt, rp) { // returns reference to auxiliary rule const uniq = this.g.nt(); // unique non-terminal this.g.rule(uniq, ... alt.seqs); // uniq: alt; this.#hidden.push(this.g.rules.pop()); // can't be start rule return uniq; } // grammar: { rule }; grammar (some) { this.g.rules.push(... this.#hidden); // append hidden rules ... Again, press to represent and check the extended grammars' grammar, press to let the extended grammars' grammar represent and check the new grammar for sum found in the , and finally, press to apply the new grammar for sum to the expression 1 + 2 - 3. Bottom line: the grammars' grammar can translate itself and this allows for changes to the notation as long as Rule and the other magic classes support the semantics or new classes are added to support entirely new constructs. According to the definition of bootstrapping this can go on for many iterations — but it will eventually reach the limits of the practice page... Previous: 8. Functions as Values Next: 10. Recognition Revisited × Search results Close "},"tutorial-10-bottom-up.html":{"id":"tutorial-10-bottom-up.html","title":"Tutorial: 10. Recognition Revisited","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 10. Recognition Revisited Try (Almost) Everything? Conflicts and Errors Chapter two defined context-free grammars, the BNF notation for grammar rules, and the version of Extended BNF used throughout this book — rules are alternative sequences which contain literals, tokens, references to other rules, and additionally brackets for optional alternatives and braces for alternatives which can appear one or more times. All the examples so far employed the recursive descent algorithm for recognition implemented by the EBNF module and described in chapter four: Consider the grammar rules to be recognition functions. Call the start rule. The lookahead (next input symbol) uniquely selects an alternative within the rule. If the next item in the rule is a literal or token it is collected and recognition moves on. If the next item is a reference another rule is called. Brackets are entered if the lookahead fits. Braces are entered and iterated as long as the lookahead fits. Eventually the start rule has to be completed. As an aside, example 2/05 illustrated that this algorithm cannot handle left recursion in grammar rules. This chapter discusses a stack-based parser to replace the recursive descent algorithm. The parser is constructed from BNF rules and supports left recursion. It is based on an idea by Don Knuth. It turns out that EBNF rules can be translated to BNF in such a way that the stack-based parser executes the same actions as before, i.e., the objective of this chapter is to construct a more powerful parser from grammars which are not suitable for recursive descent. All numbered classes in the examples are available from the module Ten which is built into the practice page. All examples in the previous chapters can use either the recursive descent parser or the stack-based parser — no changes are required! The Idea The construction is based on BNF notation, i.e., rules are ordered pairs with a non-terminal on the left and a symbol sequence — terminals and non-terminals — on the right. Alternatives are expressed by rules which have the same non-terminal at left. The stack-based parser moves from left to right along the input and records each move on the stack until the top values on the stack fit a rule of the grammar. At this point there are at least as many values on the stack as there are symbols in the rule's sequence. At this point the values corresponding to the rule are popped off the stack, optionally processed by an action, and a value corresponding to the rule is placed on the stack instead. The process continues until the input is exhausted and the stack just contains a value corresponding to the start rule of the grammar. Success! This looks like the obvious algorithm — but the problem is to recognize that the top values on the stack fit a rule of the grammar. Example 10/01 shows how this might be accomplished: The very first button should show . If not, click it until it does. Toggle and press to represent and check the grammar. Press to see that the text in the is recognized. Remove b or c from the and each time press again. The grammar describes sequences starting with a single a, optionally followed by a single b, and ending in any number of c: root: 'a'; root: 'a' 'b'; root: root 'c'; The grammar is left-recursive and the first two rules for root start with the same terminal symbol, i.e., the grammar is definitely not LL(1) and it is not suitable for recursive descent. However, the grammar is not ambiguous because a sentence starts either with a or with a and b, and that uniquely determines how each syntax tree is built. How should recognition proceed if it is based on this grammar? The stack-based parser is controlled by a transition diagram which is constructed by simulating execution: a position marker • is placed at the beginning of the rules and is advanced as input arrives: The result is a directed graph where the nodes are recognition states which contain marked rules and the edges indicate transitions based on input terminals (single arrowhead) or recognized non-terminals (double arrowhead). A non-terminal is recognized exactly when a rule can be satisfied, i.e., the graph needs edges for completed rules — rules with the marker at the end of the rule. Edges must lead from states with completed rules to states with rules where the marker is just before the non-terminal at left in the completed rule: In the diagram above these edges are blue, labeled reduce, and are marked with double arrowheads. Finally, there are transitions based on non-terminals (black with double arrowheads). A transition based on a terminal is called a shift and a transition based on a non-terminal is called a goto. A reduce transition is always immediately followed by a goto transition. To get unique start and end states for the transition diagram a rule zero is added to the grammar $accept: root $eof where root is the start non-terminal of the grammar. This provides a unique start state 0 for the transition diagram, namely the state which contains rule 0 marked at the beginning. Whenever the position marker is right before a non-terminal, closure is applied (recursively), i.e., all rules for the non-terminal are marked at the beginning and are added to the state. Rule zero also provides a unique state where the transitions end successfully, namely the state which contains rule 0 marked at the end, following $eof, the end of input. Here is the complete transition diagram: States and transitions for example 10/01 can be viewed: The very first button should show . If not, click it until it does. Toggle so that the effect of closure is displayed and press to represent and check the grammar. Check the . It contains the states and the marked rules defining each state. Each state is followed by the transition messages. One more thought and the recognition technique is complete: The transition diagram is finite because the number and length of rules, both, are finite. However, a grammar can, for example, describe a set of nested parentheses of arbitrary depth, i.e., recognition needs a mechanism for unlimited counting which a finite diagram cannot provide. Therefore, the states are kept on a state stack with the current state on top. Each shift and goto transition, i.e., recognizing an input terminal or a completed non-terminal, pushes one new state on top of the stack. A reduce transition pops states off the stack, namely exactly as many states as it took to complete the rule which is reduced, i.e., exactly as many states as there are symbols in the right-hand side of the rule. This can be counted for any specific path through the diagram, too. The transition diagram really tries \"everything.\" It starts with the parser positioned at the beginning of rule 0. It transitions and pushes the state stack for every possible input. It pops the stack for completed rules and transitions beyond them until, hopefully, the end of rule 0 is reached. The states are computed in a way that \"everything\" is tried in parallel, thus avoiding the complications of trial and error. There has to be a catch — not every grammar will result in this kind of a transition diagram. The catch will show up once the state table is constructed but example 4/04 which was discussed previously provides a quick preview: The very first button should show . If not, click it until it does. Press to represent and check the grammar — no complaints because the if statement is defined with a trailing fi. Remove the 'fi' in the and press again to see that the check() algorithm is not happy — the grammar is now ambiguous. Switch to BNF: press the very first button until it shows , i.e., the EBNF grammar will be translated to BNF and the stack-based parser is used. Toggle to see the effect of closure and press to translate the grammar to BNF and create the state table. Check the : The last line complains about a shift/reduce conflict. If you scroll to state 7 you can see that it contains both, a complete rule which could be reduced and the opportunity to shift else. The Architecture The EBNF and BNF modules use similar class architectures to represent grammars: A BNF Grammar object wraps a grammar for parsing and BNF classes Rule, Lit, Token, and NT are used to represent the rules. A BNF Grammar object can be constructed from a string with rules expressed in BNF notation using the kind of bootstrap technique described in chapter nine which is demonstrated in example 10/02 for BNF: The very first button should show . If not, click it until it does. Press to represent and check the BNF grammars' grammar. Press to let the BNF grammars' grammar represent itself and store the parser from the new representation as the result in run. Press to apply this parser to the which also contains the BNF grammar's grammar. Press a few more times: The count in the increases because the grammar keeps representing itself. The EBNF and BNF modules share some common code included from the Base module. In particular, the ability to create a scanner from the literals and token patterns in a grammar is implemented in the Base module. The design objective was to decouple the modules as far as possible and avoid duplicating code, but for the fact that a BNF Grammar can be constructed from an EBNF Grammar using the BNF factory method Grammar.fromEBNF(). There are some subtle but significant differences which reduce the number of classes used to represent a BNF grammar: a BNF Rule is an ordered pair which contains a BNF non-terminal NT at left and a flat list of terminals and non-terminals at right, the same non-terminal can be at left in several rules, and a non-terminal has a list of rules where it is at left. The state table is computed by check() and owned by the BNF Grammar object. A BNF Parser is a separate object which owns the state stack and is consumed during the parsing operation, i.e., a BNF Parser cannot be reused once all input has been processed. As before, a Scanner is a separate object, created from the terminals of a BNF Grammar with the technique explained in chapter three. It translates a string into a list of Tuple objects each of which contains a piece of the input string, the line number in the input, and a BNF Lit or Token object representing the piece of the input. In Example 10/01 the very first button should show . If not, click it until it does. Press to represent and check the grammar. Press to see the pattern used in the scanner and the Tuple objects for the text in the . The BNF parsing method Parser.parse() can either be called with a string, or it can be called repeatedly, either with a list of Tuple objects or with a function providing such lists. Because the parsing state is stacked, successive input lists can be pushed to the parsing method, i.e., parsing could even operate interactively. null acts as end of all input and matches $eof in rule zero. An illegal input character is represented as a Tuple containing null rather than a Lit or Token object. This kind of Tuple will cause an error during recognition. In Example 10/01 the very first button should show . If not, click it until it does. Press to represent and check the grammar. Toggle either to see all transitions or to see only reduce and toggle to collect the input into lists. Finally, press to observe recognition: &gt; g.config.build = true &gt; g.config.trace = /./ &gt; g.parser().parse(program) STATE TUPLE MESSAGE RETURNS 0 (1) 'a' shift 1 null 1 (1) 'b' shift 3 null 3 (1) 'c' reduce root: 'a' 'b'; [ 'a' 'b' ] 0 (1) 'c' goto 2 null 2 (1) 'c' shift 4 null 4 (1) 'c' reduce root: root 'c'; [ [ 'a' 'b' ] 'c' ] 0 (1) 'c' goto 2 null 2 (1) 'c' shift 4 null 4 eof $eof reduce root: root 'c'; [ [ [ 'a' 'b' ] 'c' ] 'c' ] 0 eof $eof goto 2 null 2 eof $eof accept [ [ [ 'a' 'b' ] 'c' ] 'c' ] [ [ [ 'a' 'b' ] 'c' ] 'c' ] Recognition implicitly contains an Observer design pattern. Input terminals are processed and trigger some of the state changes and transitions described earlier and the transitions result in messages: shift, reduce, goto, accept, and perhaps error. The parser’s observe() method reacts to these messages. It sends the message to the trace() method if the configuration option Grammar.config.trace is set, i.e., is set on the practice page, and to the build() method if Grammar.config.build, i.e., , is set, or if Action methods were supplied in the first call of the parse() method. For reduce messages build() assembles recognized input into lists and sends them to Action methods, if any. The classic implementations of this parsing technique, yacc and bison, spend considerable effort on optimizing the state table. BNF was designed to be more tutorial in nature; therefore, the state table is a list of State objects. Each holds marks, a list of one or more Mark objects, i.e., the marked rules, and a messages collection which maps the symbols for the outgoing edges of the state to the possible messages which are sent to observe() and which define the operations on the stack. For display purposes these messages are encoded as Message objects. As an aside, this chapter uses the term actions for semantic actions implemented as Action methods as introduced in previous chapters. In contradistinction, the term messages is used for the operations on the state stack because they are also sent as messages to observe(). The reduce messages trigger the semantic actions, if any. Constructing the State Table The state table is constructed by the check() method which is called once after the rules of a BNF Grammar have been represented. The first State object is created with a Mark object for rule zero marked at the beginning: $accept: ● start-symbol $eof; check() uses factory methods state() and mark() to create state 0: this.states.push(this.state([this.mark(this.rules[0], 0)])); A state is created with a list of one or more marked rules. Together they are called the core marks and they uniquely define the state. The state additionally contains the closure of the core: all rules for all non-terminals which immediately follow a marker. Here is the factory method which is called with a list of Mark objects: state (core) { const coreLength = core.length; const messages = {}; // compute closure: loop over core and add(ed) marks ... return new State(this, core, coreLength, messages); } The state stores the number of core marks because only cores have to be compared to determine if two states are equal. Each state maps terminals and non-terminals to messages which control parsing: message verb information effect shift next state push onto state stack,advance in input. reduce rule pop state stack by rule length,uncover state which expects the non-terminal. goto next state push onto state stack. accept done! The State object contains a messages object: messages maps a terminal symbol which immediately follows a mark in the state either to a shift message which consumes the corresponding input and transition to another state, or to a reduce message which completes recognition of a rule. messages maps a non-terminal symbol which immediately follows a mark in the state to a goto message which transitions to another state. messages maps $eof if it immediately follows a mark in the state to an accept message which completes parsing. The keys of messages are exactly all symbols which immediately follow one or more marks in the state. All other terminal symbols would not be expected. messages is set up when the rules in the closure are added to the core of the state: // compute closure: loop over core and add(ed) marks for (let c = 0; c &lt; core.length; ++ c) // for each incomplete mark if (!core[c].complete) { // next symbol in a mark const s = core[c].rule.symbols[core[c].position]; if (s instanceof NT &amp;&amp; !(s.ord in messages)) // add all rules for a new non-terminal, marked at 0 s.rules.forEach(rule =&gt; core.push(this.mark(rule, 0)), this); // map this next terminal or non-terminal to null messages[s.ord] = null; } This loop runs as long as new marked rules are added — until it reaches the eventual end of core. .complete is true for a Mark if the marker follows all symbols of the rule. So far, all values in messages are null and the keys of messages are the symbols that immediately follow one of the marks in the state. In a similar loop in the check() method, all state objects are then asked to advance(), i.e., to create outgoing edges and more states as needed to terminate the edges, and to fill in all messages collections: // tell each state to advance // this creates new states which are also advanced for (let s = 0; s &lt; this.states.length; ++ s) this.states[s].advance(s); The heavy lifting happens in the advance() method: advance (stateNumber) { // create reduce messages for complete rules this.marks.forEach(mark =&gt; { if (mark.complete) { ... } // done with every complete rule }, this); The first step is to enter reduce messages into the messages collection for all complete marks. The details are discussed below. Each literal, token, and non-terminal has a unique ordinal number, starting with 0. messages maps this number to a message. Once the reduce messages have been entered, all other values in messages will have to be shift or goto, with one exception: // create accept/shift messages for each next symbol which has none for (let a in this.messages) { if (this.messages[a] == null) { if (a == this.grammar.lit().ord) { // special case: $eof this.messages[a] = this.grammar.accept(); this.grammar.rules[0].reduced = true; $eof only appears in rule zero and this symbol can only lead to a reduce or accept message. accept means that rule zero is successfully recognized. If the symbol is not $eof, the message will be shift or goto and needs a target state which is computed by advancing the marker across the symbol in all Mark objects where the marker is currently just before the symbol: } else { // create next core by advancing marker over one symbol const next = [ ]; let symbol = null; this.marks.forEach(mark =&gt; { // find a as next symbol in all marks if (!mark.complete &amp;&amp; a == mark.rule.symbols[mark.position].ord) { // remember symbol and push mark after symbol symbol = mark.rule.symbols[mark.position]; next.push(mark.advance()); } }, this); next is a list, used to collect all new Mark objects with the marker moved across the symbol. advance() uses the factory method to create a new mark with the same rule but the marker in the next position. next will contain at least one Mark object, otherwise a would not have been a key in messages for this state. next is the core of the target state for the shift or goto message to be recorded for the key a in messages. If the core cannot be found among the known states, a new state needs to be created: // add new state with next as core, if any // shift/goto existent or new state if (!this.grammar.states.some((state, s) =&gt; state.equals(next) ? (this.messages[a] = this.grammar.shift_or_goto(symbol, s), true) : false, this)) { this.messages[a] = this.grammar.shift_or_goto(symbol, this.grammar.states.length); this.grammar.states.push(this.grammar.state(next)); } This concludes creating all but the reduce messages, and it looks as if nothing can go wrong. Unfortunately, entering the reduce messages will show that there can be problems. This part of the advance() method is discussed next but it was already demonstrated above that not every grammar is suitable for stack-based parsing because there can be conflicts. Conflicts The previous section did not discuss how reduce messages are entered into a state's messages table before the other messages are filled in. A reduce message requires a .complete rule and it only makes sense to enter it for terminals which can follow the mark's rule's non-terminal: // create reduce messages for complete rules this.marks.forEach(mark =&gt; { if (mark.complete) { // rule we are in const rule = mark.rule; // for each terminal which can follow the rule in the grammar for (let t in rule.nt.follow) { // ordinal number const f = rule.nt.follow[t]; // terminal which can follow if (!(t in this.messages)) { // can it follow in this state? // if t is not in messages it cannot follow this state -&gt; reduce rule.reduced = true; this.messages[t] = this.grammar.reduce(f, rule); .follow contains all terminals which can follow a rule. Computing .follow for EBNF grammars was discussed in chapter four. For BNF grammars the computation is easier because BNF rules are simpler. If a terminal in .follow is not yet a key in the state's messages table, it cannot lead from the state to another one; therefore, this terminal needs to be added with a reduce message. However, if the terminal is already a key in the messages table, there is a conflict. If the terminal was associated with a reduce message previously, the terminal is in the follow set for some other complete rule, i.e., there are two different rules which can be reduced before the terminal is accepted: } else if (this.messages[t] != null) { // t is in messages and messages[t] is already set as a reduce const r2 = this.messages[t].info; // the other rule ++ this.grammar.rr; error('for', f.toString(), 'reduce/reduce conflict between', '(' + rule + ')', 'and', '(' + r2 + ')'); // resolve for rule which is first in the grammar if (rule.index &lt; r2.index) this.messages[t].info = rule; Technically, this reduce/reduce conflict makes the grammar unsuitable for stack-based parsing because the state table's message is not unique. Traditionally, as a stopgap measure in such a case, the first rule in the grammar is selected to be reduced. If there is no prior reduce message, the terminal is in the messages table because it will be associated with a shift message when the marker is moved across it, as discussed in the previous section: else { // this.messages[t] == null ++ this.grammar.sr; error('shift/reduce conflict between', f.toString(), 'and rule', '(' + rule + ')'); } // done with conflicts } // done with every t which can follow } // done with every complete rule }, this); This is called a shift/reduce conflict and makes the grammar unsuitable for stack-based parsing, too. In this case the stopgap measure is to prefer the shift message. A shift/reduce Conflict Example 10/03 shows that preferring the shift action can be desirable, for example to resolve the classic dangling else problem in favor of the innermost if statement. statement: 'if' Number statement; statement: 'if' Number statement 'else' statement; statement: Number; The grammar above has a shift/reduce conflict for else. The very first button should show . If not, click it until it does. Press to represent and check the grammar and check on the conflict. Toggle and press to see that if 1 if 2 3 else 4 is recognized as [ 'if' '1' [ 'if' '2' [ '3' ] 'else' [ '4' ] ] ] i.e., the else is recognized as part of the innermost if. Toggle and press again to confirm: STATE TUPLE MESSAGE RETURNS 2 (2) 'else' reduce statement: Number; [ '3' ] 2 (0) $eof reduce statement: Number; [ '4' ] 7 (0) $eof reduce statement: 'if' Number [ 'if' '2' [ '3' ] 'else 5 (0) $eof reduce statement: 'if' Number [ 'if' '1' [ 'if' '2' [ [ 'if' '1' [ 'if' '2' [ '3' ] 'else' [ '4' ] ] ] A reduce/reduce Conflict The built-in resolution for a shift/reduce conflict, i.e., to shift rather than to reduce, can often be accepted. However, reduce/reduce conflicts are usually more serious and need to be investigated carefully. Example 10/04 contains a grammar, hugely simplified, where an expression is based on a condition or arithmetic and where a condition is based on a comparison or arithmetic: expression: condition; expression: Number; condition: sum '&lt;' sum; sum: Number; The very first button should show . If not, click it until it does. Toggle and press to represent and check the grammar. Check the to see the reduce/reduce conflict in state 1 between the rules in line 2 and 4 above which is resolved in favor of the rule in line 2. Toggle or and press to confirm that a single Number such as 0 can be recognized. Move the last rule into second place and press again to see that the conflict is now resolved in favor of that rule. Press to confirm that now a single Number such as 0 cannot be recognized: (0) $eof is not allowed expecting: '&lt;' irrecoverable error LR(1) As a final note, the implementation discussed here is a simplification of Knuth's LR(1). BNF was designed to illustrate the principle and to at least be capable of handling all the examples from the previous chapters. The idea of using the follow set of a rule's non-terminal to avoid some conflicts when the complete rule is processed is convenient but not as restrictive as possible. Each marked rule starts with a nonterminal in a known context and one could consider only those terminals which can follow in that context, i.e., each mark should include it's own follow set. This results in larger state tables but potentially fewer conflicts and, therefore, more grammars which are suitable for LR(1) parsing. Precedence and Associativity The LL(1) grammar for interpreting arithmetic expressions written in EBNF was a bit cumbersome. Operator associativity had to be implemented in the semantic actions, not in the grammar itself. Example 10/05 contains a more convenient grammar: sum: product | add | subtract; add: sum '+' product; subtract: sum '-' product; product: factor | multiply | divide; multiply: product '*' factor; divide: product '/' factor; factor: power | term; power: term '**' factor; term: number | '(' sum ')'; number: Number; This time, left associativity for sum and product is expressed through left recursion, right associativity for power is expressed through right recursion. Operator precedence is encoded into the grammar because the non-terminals sum, product, factor, and term establish appropriate levels. Both, recursive descent and the stack-based parser, can apply an action when a rule is reduced. The translation from EBNF to BNF does not change the structures which are presented to the action. As a result, actions for immediate evaluation with this grammar are very intuitive, for example: class Actions { // sum: product | add | subtract; sum (value) { return value; } // add: sum '+' product; add (sum, x, product) { return sum + product; } ... // term: number | '(' sum ')'; term (... arg) { return arg.length &gt; 1 ? arg[1] : arg[0]; } // number: Number; number (number) { return parseInt(number, 10); } } Here is an expression which produces 2 as a result: 1 + 2*3 - 45/(1 + 2**3**2 / 4**3) The grammar in example 10/05 uses EBNF notation — because | is used to separate alternatives — but the grammar is left recursive and has to be processed using the stack-based parser: The very first button should show . If not, click it until it does. Press to translate the grammar from EBNF to BNF, represent, and check it. Press to recognize and evaluate the expression in the . Toggle and press again to observe evaluation. The actions for sum, product, factor, and term, each, receive one or three values and each action just extracts and returns the appropriate value. The actions for add, subtract, etc., each, receive two values, separated by an operator, perform immediate evaluation, and return the result. None of the actions has to deal with associativity or precedence. Yet another grammar for arithmetic expressions, in example 10/06, is as short as it can get expr: add | subtract | multiply | divide | power | '(' expr ')' | number; add: expr '+' expr; subtract: expr '-' expr; multiply: expr '*' expr; divide: expr '/' expr; power: expr '**' expr; number: Number; but this grammar lacks any information about operator precedence and associativity. The very first button should show . If not, click it until it does. Press to translate the grammar to BNF and try to represent and check it. Unfortunately, there are 25 shift/reduce conflicts... Following yacc, precedence and associativity are specified in example 10/07 as a sequence of precedence levels preceding the grammar rules: %left '+' '-'; %left '*' '/'; %right '**'; expr: add | subtract | multiply | divide | power ... Precedence increases in the order of the level statements. Each level statement contains one or more terminal symbols. Terminal symbols in the same level statement have the same precedence and associativity. A precedence level can also start with %nonassoc to suppress associativity, e.g., for comparison operators. The grammar rules remain unchanged for example 10/07 but the precedences make no sense in the context of recursive descent: The very first button should show . If not, click it until it does. Press to represent and check the grammar. Note that precedences are not allowed for recursive descent. Click the very first button until it shows . Press to represent and check the grammar. Note that there are no more conflicts reported. Press to confirm that the expression in the can be recognized and evaluated. Toggle and press again to observe evaluation as a result of the reduce messages. Principles Consider the grammar expr: expr 'a' expr; expr: expr 'b' expr; expr: Number; and the input 1 a 2 b 3 and two trees which could be built to suggest that a and b are mathematical operations on the inputs 1, 2, and 3: The left tree suggests that operator a has precedence over b, e.g., multiplication happens before addition, or — for equal precedence — that a is left-associative, e.g., addition and subtraction happen from left to right. The right tree suggests that operator b has precedence over a, or — for equal precedence — that b is right-associative, e.g., exponentiation or assignment happen from right to left. What happens if creating the state table has reached the following point: expr a expr ● b Rule 1 in the grammar above is complete, and it can be followed by terminal b. The left tree can be built if rule 1 is reduced first, the right tree requires a shift of b so that rule 2 can be reduced first. Therefore: If the last terminal in a complete rule (a) has higher precedence than the \"follow\" terminal (b), the rule should be reduced. If the last terminal in a complete rule has lower precedence than the \"follow\" terminal, there should be a shift. If the last terminal in a complete rule and the \"follow\" terminal have equal precedence, the rule should be reduced if the last terminal is left-associative, and there should be a shift if the last terminal is right-associative. Otherwise, i.e., with equal precedence and no associativity, there remains a shift/reduce conflict. This will be implemented below. Hiding Conflicts It should be noted that precedences hide conflicts, but they are a natural way to implement arithmetic. It is usually a good idea to check the state table before and after adding precedence information to make sure the precedences have the intended effect. Example 10/08 is a \"dangling else\" without a visible conflict: %right 'else'; statement: 'if' Number statement %prec 'else'; statement: 'if' Number statement 'else' statement; statement: Number; A BNF rule can include a trailing %prec clause to specify precedence and associativity explicitly by referencing a terminal on a precedence level defined earlier (lines 3 and 1 above). For this grammar there is no message about the shift/reduce conflict demonstrated earlier and state 5 shows that this state table will still reduce else with the closest if: state 5 statement: 'if' Number statement ● %prec 'else'; statement: 'if' Number statement ● 'else' statement %prec 'else'; $eof reduce (statement: 'if' Number statement %prec 'else';) 'else' shift 6 It is tempting to think that changing %right to %left would reduce else with an outer if but in fact the change renders the grammar useless: rule 2 is never reduced ... state 5 statement: 'if' Number statement ● %prec 'else'; statement: 'if' Number statement ● 'else' statement %prec 'else'; $eof reduce (statement: 'if' Number statement %prec 'else';) 'else' reduce (statement: 'if' Number statement %prec 'else';) errors: 1 Now the second grammar rule is never reduced, i.e., input cannot contain else. Actually, we are in case (3) described above. The %prec clause assigns the same precedence to the rule which the \"follow\" terminal else has. Right associativity will cause a shift in this case, i.e., else will be reduced with the innermost if. EBNF and Precedence The state table is computed for a BNF grammar — or for an EBNF grammar internally translated into BNF. How should a %prec clause apply to EBNF to be translated to BNF? The clause must always apply to a single BNF rule. EBNF brackets and braces have to be translated into several BNF rules because each BNF rule can only contain one symbol sequence. This suggests that a %prec clause can only apply to a symbol sequence in EBNF, i.e., to one (of perhaps several) alternatives. Example 10/09 is a small but useful example which shows how to add a unary minus to the arithmetic example discussed above: %left '-'; expr: subtract | minus | number; subtract: expr '-' expr; minus: '-' expr; number: Number; With the additional semantic action class Actions09 extends Ten.Actions07 { minus (x, a) { return - a; } } this will get 1 as the result of evaluating -1 -- 2 The grammar enforces that the unary minus has precedence over the binary minus. Without a precedence level the grammar is ambiguous. %left defines associativity for binary minus and settles the conflicts; replacing %left by %right would cause a chain of subtractions to be evaluated right to left. Unary minus only \"fits\" the grammar at an implicitly higher precedence. Example 10/10 adds another precedence level and a %prec clause to the EBNF grammar: %right Number; %left '-'; expr: subtract | minus | number; subtract: expr '-' expr; minus: '-' expr %prec Number; number: Number; This — deliberately — gives the unary minus less precedence than the binary minus. The same input now evaluates to -3. It is instructive to trace both evaluations. With the rule %prec clause, 5 (0) $eof reduce expr: minus; -3 is the last reduce message, without it it is 4 (0) $eof reduce expr: subtract; 1 i.e., with lower precedence minus is the last operation, with higher precedence for minus the subtraction is last. Both examples are EBNF grammars because they contain alternatives for expr, but both require the stack-based parser because of the precedence levels. The %prec clause is not applied to an EBNF rule — which can have several alternatives — but to a symbol sequence such as '-' expr. Example 10/11 takes this to an extreme: %right Number; %left '-'; expr: expr '-' expr | '-' expr %prec Number | Number; The action for this one-line grammar is just based on the number of arguments: class Actions { expr (... arg) { switch (arg.length) { case 3: return arg[0] - arg[2]; case 2: return - arg[1]; case 1: return parseInt(arg[0], 10); } } } Why use Number in the precedence level statement for this example? All that is required is to connect the unary minus with a %prec clause to a terminal symbol which is — for fun — on a level below binary minus. Assigning a precedence to Number through a level statement does not affect the state table and does not introduce a new, otherwise unused terminal symbol. Trick question: without a %prec clause and without changes to the grammar structure, how can -1 -- 2 ---- 4 be evaluated as either -7 or 5? Conflict Resolution Precedence objects represent precedence levels and contain associativity and a list of terminals which are at the same level of precedence. Grammar objects for either EBNF or BNF contain a list of Precedence objects in order of increasing precedence; for EBNF they can only be used when translating to BNF. BNF.Lit and BNF.Token objects, EBNF.Seq and BNF.Rule objects can have a .prec property with similar information which can be set up during construction because the precedence table has to precede the rules of a grammar. The Grammars' Grammars for EBNF and BNF contain the appropriate syntax and the bootstrap process described in chapter nine includes the necessary actions to create the representations. Thus, the stage is set to resolve some conflicts. They are detected when there are complete rules and reduce messages are about to be entered into the messages table for a state. Recall the code structure in the advance() method set up above: advance (stateNumber) { // create reduce messages for complete rules this.marks.forEach(mark =&gt; { if (mark.complete) { const rule = mark.rule; // rule we are in // for each terminal which can follow the rule in the grammar for (let t in rule.nt.follow) { // ordinal number const f = rule.nt.follow[t]; // terminal which can follow if (!(t in this.messages)) { // if t is not in messages it cannot follow this state ... // create reduce message } else if (this.messages[t] == null) { // if t is in messages -- there might be a s/r conflict ... // explained below } else { ... // t already set as a reduce -- report r/r conflict } // done with this t } // done with every t which can follow } // done with complete mark }, this); // done with all marks // create shift messages, next state, etc. Recall that rule is complete, ready to be reduced (line 5 above), f is one of the \"follow\" terminals (line 8), t is it's key in messages (line 7), and a message has not yet been entered (line 9). If both, rule and \"follow\" terminal, actually have a precedence the shift/reduce conflict can be resolved with the following code inserted above (at line 14): // if t is in messages -- there might be a s/r conflict if (rule.prec &amp;&amp; f.prec.assoc) { // rule and terminal have defined precedence if (rule.prec.level &gt; f.prec.level) { // rule's precedence is higher -&gt; reduce ... } else if (rule.prec.level &lt; f.prec.level) { // rule's precedence is lower -&gt; fall through to shift } else // equal precedence switch (rule.prec.assoc) { case '%left': // rule is left-associative -&gt; reduce ... case '%right': // rule is right-associative -&gt; shift break; // fall through case '%nonassoc': // non-associative -&gt; error delete this.messages[t]; // i.e. f as input would be an error } } else { // no precedence available -- shift/reduce conflict ... } // resolved as a shift (fall through) Conflict resolution through precedences is implemented just as the principles above require. In order to concentrate on the overall structure, calls on the factory methods for the messages and insertion in the state's messages table have been omitted in the code above. The complete code can be viewed from the documentation of the advance() method. Recognition Given a state table owned by a Grammar object, how is input recognized, how are values collected and presented to any Action methods, and what needs to be done so that a recursive descent parser and a stack-based parser, both derived from the same EBNF grammar, can interact with the exact same Action methods? Recognition starts with a Parser object which is constructed by the Grammar object and owns a state stack which is simply a list of indices into the Grammar's list of states. The current state is the top element on the stack; therefore the stack initially contains just one element with value zero. parse() The parse() method takes a list of Tuple objects which a Scanner can prepare from a string. null in the list represents the end of all input, i.e., $eof; otherwise parse() is called again with more input. parse() executes a loop which can be aborted: try { while (true) { if (!this.current) this.next(); // lookahead as needed if (this.current.t // expected input? &amp;&amp; this.current.t.ord in this.state.messages) { if (this.process(this.current)) this.next(); // consumed } else // illegal character or unexpected input this.recover(); } } catch (outcome) { if (outcome instanceof Array) return outcome[0]; // success throw outcome; // true: more input, else: failure } this.current is a Tuple representing the current input terminal and next() is called to move along — just not beyond null, i.e., $eof. By convention, next() throws true to request more input. If there is a message for the current input terminal in the current state process() executes the message for the Tuple and returns true if the terminal should be consumed, i.e., after a shift message (line 6 above). false would protect the terminal for another round, i.e., after reduce plus goto. If there is no message the input is not expected and recover() gets a chance to arrange for the loop to continue as discussed below (line 9). If a value, wrapped into an Array, is thrown parse() would unwrap and return it (line 12) — this is a hook for an observer to return a value from a semantic action. Any other throw (but true) will terminate recognition ungracefully (line 13). process() The process() method accepts an input Tuple, finds a message, if any, offers it to observe(), and manages the state stack: process (tuple) { // get message and inform observer const verb = this.state.messages[tuple.t.ord].message, info = this.state.messages[tuple.t.ord].info, result = this.observe(tuple, verb, info); switch (verb) { // dispatch message case 'accept': throw [ result ]; // parse ends with success case 'shift': this.stack.push(info); // shift to new state return true; // tuple is consumed case 'reduce': // pop the stack by the length of the rule, uncover state this.stack.length -= info.symbols.length; // there always follows a goto for the non-terminal const g = this.state.messages[info.nt.ord]; this.observe(tuple, g.message, g.info); // observe the goto this.stack.push(g.info); // goto to new state return false; // tuple still available } } The message is obtained from the current state (lines 3 and 4 above) and a call to observe() with the message produces a result (line 5). As described above observe() will invoke an Action method, if there is one, or return the result null so that there always is a value. If the message is accept the result is wrapped into an Array and thrown (line 8), to be returned from parse(). For shift the message contains the next state which is pushed and the input terminal will be consumed (lines 10 and 11). For reduce the message references the rule so that the state stack can be popped (line 14). In addition, a goto for the non-terminal is sent to observe() and the corresponding state is pushed (lines 17 and 18). In this case the input terminal is not consumed (line 19). observe() The observe() method accepts a Tuple and the corresponding message, asks the build() method to compute a result in place of null if Grammar.config.build is set or if Action methods were supplied in the first call to parse(), asks the trace() method to create and display a trace if the configuration option Grammar.config.trace is set, and displays an error message if the incoming message is error with non-empty information. observe(), build(), and trace() are deliberate hooks for subclassing at different levels. For example, yacc and bison have a significantly different approach to collecting input and presenting it to semantic actions because they do not have to accommodate EBNF. build() Chapter five explained how the recursive descent parser collects recognized input into nested lists which can be processed by Action methods, if any. Similarly, the stack-based parser can use Action methods if an observer collects input in response to shift messages and calls actions in response to reduce messages. When the parse() method is first called, if the Grammar.config.build configuration option is set or if Action methods are supplied a value stack is added to the Parser. The build() method accepts a Tuple and the corresponding message, manages the value stack to parallel the state stack, and presents values to Action methods, if any, to potentially change the result of reduce messages: build (tuple, verb, info) { switch (verb) { case 'shift': // shift: collect input text this.values.push(tuple.value); return null; case 'reduce': // reduce: pop by rule length const len = info.symbols.length; let result = this.values.splice(- len, len); // can be [] result = this.act(info.nt.name, result); // apply action if any this.values.push(result); // goto (follows!): push result return result; case 'accept': // accept: return result of start rule return this.values.pop(); } // actual goto can be silently ignored } build() is called with the current input tuple and verb and info of the message triggered by the state and the input. A shift message indicates that the parser transitions to a new state in response to some input and build() pushes the input onto the value stack for the stacks to stay in sync (line 4 above). A reduce message indicates that a rule has been completed and build() has to pop values off the value stack to keep it in sync. The extra info references the rule to be reduced. The rule's number of symbols (line 7) determines how many values have to be popped off the value stack (line 8) to be presented to an Action method, if any (line 9). Either the list of values or the result of the action is returned for reduce (line 11) and pushed as value associated with the immediately following goto message (line 10) which itself will be silently ignored (line 14). The method act() (line 9) is shared between the recursive descent and the stack-based parser. It takes a rule name and a list of values collected for the rule and tries to find and execute an action method with the rule name. act() returns the result of the action method or the list of values. An accept message indicates that the parser is done and build() pops the top value off the value stack and returns it. Eventually, process() sends it back as the parse() method's result value. Success! Translating EBNF The build() method seems to produce nested lists just like the recursive descent parser does. However, example 10/12 shows that there is a problem: The very first button should show . If not, click it until it does. Press to represent and check the grammar. Toggle and press to see the result. This BNF grammar uses left recursion to specify that a sentence should consist of one or more sequences, where a sequence consists of a, an optional b, and c: some: seq; some: some seq; seq: 'a' opt 'c'; opt: 'b'; opt: ; This program consists of two sequences: a b c a c Here is the output, reformatted for clarity: [ [ [ 'a' [ 'b' ] 'c' ] ] [ 'a' [ ] 'c' ] ] By default, the observer creates a list whenever a rule is reduced, i.e., rule 4 (above) will return a list containing b and rule 5 will return an empty list. Note that the recursive descent parser will instead return null when there is no input for an optional alternative — which is enclosed in brackets in the EBNF notation. Rule 3 returns a list when a sequence is found — these are the brackets directly around the sequences in the output above. Rule 1 returns a list containing the list with the first sequence ever and rule 2 creates yet another — outermost — list whenever another sequence is found. The Action method for some would have to count arguments to know which of the two rules for some is reduced in order to process it's arguments correctly. The EBNF grammar in example 10/13 some: { 'a' [ 'b' ] 'c' }; accepts the same input with two sequences shown above but it produces a more uniform output (reformatted for clarity): [ [ [ 'a' [ 'b' ] 'c' ] [ 'a' null 'c' ] ] ] This is independent of the choice of parser: The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the result for the recursive descent parser. Click the very first button to show , press to represent and check the grammar and press to see that the stack-based parser produces the same result. A BNF grammar expresses alternatives as rules with the same non-terminal at left. EBNF uses | to separate alternatives and insists on unique non-terminals as rule names. Additionally, EBNF uses brackets for optional alternatives and braces for alternatives which can be repeated. The EBNF rule in example 10/13 produces a list for the selected alternative. The braces produce a list containing one inner list for each alternative that was recognized. The brackets produce null or a list for the recognized alternative. The two examples together hint at the translation from EBNF to BNF which the factory method BNF.Grammar.fromEBNF() implements. Example 10/14 combines the two grammars and (almost) allows direct comparison between automatic and manual translation: cases: ebnf bnf; ebnf: 'ebnf' { 'a' [ 'b' ] 'c' }; bnf: 'bnf' ebnf4; ebnf4: ebnf5 | ebnf4 ebnf5; ebnf5: 'a' ebnf6 'c'; ebnf6: | 'b'; The two cases in this EBNF grammar accept the same sequences as before, prefixed with ebnf or bnf to select different rule sets for recognition. The ebnf rule uses braces and brackets for iteration and the optional part (line 3 above). The bnf rule (line 5) uses the left-recursive ebnf4 rules to express iteration of one or more sequences (line 7), the ebnf5 rule to express the sequence itself (line 8) — i.e., the single alternative enclosed by the braces in the ebnf rule — and the ebnf6 rules (line 10) to express the optional b — i.e., the enclosed alternative and the brackets in the ebnf rule. Preparing the grammar in Example 10/14 shows (more or less) that the manual translation agrees with the translation performed for the stack-based parser: The very first button should show . If not, click it until it does. Press to represent and check the grammar. The error is due to the fact that EBNF does not permit empty alternatives — regardless of parser. Remove the empty alternative of the ebnf6 rule and press again to represent and check the grammar. The BNF rules can be found near the beginning of the : 0 $accept: cases $eof; 1 cases: ebnf bnf; 2 $-6: ; 3 $-6: 'b'; 4 $-5: 'a' $-6 'c'; 5 $-4: $-5; 6 $-4: $-4 $-5; 7 ebnf: 'ebnf' $-4; ... Technically, special characters cannot be part of non-terminal names in either grammar notation — they are used internally for BNF rule zero and for the additional rules resulting from the translation. BNF rule 2 (above) is simply copied from EBNF (line 1 below), BNF rules 2 to 7 are the translation of the ebnf rule (line 3 below). Rules 2 and 3 take care of the brackets (compare to line 5), rules 5 and 6 take care of the iteration with rule 4 for the content (compare to lines 6 and 7). Altogether, the BNF rules are the same as the explicit manual translation in the example's (almost) EBNF grammar: cases: ebnf bnf; ebnf: 'ebnf' { 'a' [ 'b' ] 'c' }; ... ebnf6: | 'b'; ebnf5: 'a' ebnf6 'c'; ebnf4: ebnf5 | ebnf4 ebnf5; The translation of brackets and braces from EBNF to BNF according to the pattern suggested above requires additional BNF rules which should result in more deeply nested lists to be built. Why can the stack-based parser turn out the same lists as the recursive descent parser? There have to be hidden actions which happen when the additional rules are reduced. The reduce case implemented in the build() method turns out to be a bit more devious than shown before: case 'reduce': // reduce: pop by rule length const len = info.symbols.length; let result = this.values.splice(- len, len); // can be [] if (this.grammar.ebnf &amp;&amp; // extra rule to translate from EBNF? info.nt.name.startsWith(this.grammar.config.uniq)) { if (len == 2 &amp;&amp; info.symbols[0] === info.nt) // left recurse result.splice(0, 1, ...result[0]); // don't add one more [] else if (!len) // return null if brackets find nothing result = null; } else // rule copied from EBNF result = this.act(info.nt.name, result); // action if any this.values.push(result); // goto (follows!): push result return result; Additional rules are only present if the BNF grammar is translated from EBNF (which is noted in a property .ebnf of the grammar). The names of the additional BNF rules will always start with a prefix which can be configured as Grammar.config.uniq. Those rules cannot have explicit Action methods because they only exist if the BNF grammar is translated from EBNF as shown above: 0 $accept: cases $eof; Rule 0 collects an extra list but the top-level parse() method corrects that implicitly. $-6: ; Rules like the one above describe an optional alternative which recognizes nothing. If they are completed null must be returned rather than the empty list which was collected. This is taken care of in line 9 in the code above. $-6: 'b'; $-5: 'a' $-6 'c'; $-4: $-5; Rules like these three above collect the same lists which the recursive descent parser collects for alternatives, even rules like the last one which recognizes the first iteration within braces. $-4: $-4 $-5; This kind of a left-recursive rule handles further iterations of alternatives in braces. The rule pattern is recognized in line 6 in the code above and in line 7 the list collected for the second symbol is added (not appended!) to the list already collected by flattening this first list with the spread syntax. All other completed rules will invoke the same actions as for the recursive descent parser. The hidden actions may look complicated but they preserve the Idioms for Actions described in chapter five which have worked well throughout. Representing structured input always requires some kind of list and tree building. Iteration constructs in the grammar and the hidden actions avoid the list manipulations which would otherwise be needed to accommodate iteration implemented as recursion. EBNF notation seems more convenient and the stack-based parser is more powerful. Thanks to the hidden actions this is a winning combination. Error recovery Most of the implementation of recognition was discussed before. The parse() method executes the following loop: try { while (true) { if (!this.current) this.next(); // lookahead as needed if (this.current.t // expected input? &amp;&amp; this.current.t.ord in this.state.messages) { if (this.process(this.current)) this.next(); // consumed } else // illegal character or unexpected input this.recover(); } } catch (outcome) { if (outcome instanceof Array) return outcome[0]; // success throw outcome; // true: more input, else: failure } this.current is the next input symbol to be recognized, represented as a Tuple. next() is called to advance in the input (line 3 above). this.state is the current parser state, i.e., the top value on the parser's stack, and this.state.messages maps the unique ordinal values of expected input symbols to messages (line 5). process() is called (line 6) to send such a message to observe(), change the parser state, and request to consume input or return a recognition result as appropriate. recover() is called (line 9) to handle unexpected inputs in order to continue recognition if possible. recover() could: discard input, i.e., call next(), or pop parser states and perhaps tell observe(), or select a combination of these. Theoretically, expected input symbols could even be created and inserted; however, that might well result in a never ending recognition loop with a very long sentence-to-be... recover() first sends an error message to observe() indicating (from the state table) which input symbols were expected: recover () { const error = this.grammar.token(), // unique symbol $error eof = this.grammar.lit(); // unique symbol $eof this.observe(this.current, 'error', `${this.current} is not allowed\\nexpecting:` + Object.entries(this.state.messages).reduce((s, kv) =&gt; s += kv[1].symbol instanceof Base.T &amp;&amp; kv[1].symbol !== error ? ' ' + kv[1].symbol : '', '')); Next, illegal input characters are silently dropped: while (!this.current.t) this.next(); // next tuple, throws true for more input // now at tuple with $eof or actual input Finally, recover() has no choice but to pop the stack and/or to discard input. The choice can be fine tuned in the grammar: following yacc, there is a special $error token which can be used in rules to let a grammar have some control over error recovery. $error is used like any other token on the right-hand side of a rule and, therefore, ends up as a key in some state.messages: pop: while (this.stack.length &gt; 0) { if (!(error.ord in this.state.messages)) { // $error unexpected this.observe(this.current, 'error', null); // pop value stack this.stack.pop(); // pop state stack continue; } // else $error expected if (this.process(this.grammar.tuple(this.current.lineno, error))) while (true) // did shift $error, now search for input if (this.current.t?.ord in this.state.messages) { if (this.process(this.current)) { // did shift current this.#current = null; // consume return; // recovery should be complete } // else did reduce+goto before current, retry } else if (this.current.t === eof) { // end of input this.grammar.message('terminating at ' + this.current); break pop; // cannot recover } else { // current is not expected: discard this.grammar.message('discarding ' + this.current); this.next(); } // else did reduce before $error, process $error again or pop } throw 'irrecoverable error'; } If $error is not expected in state.messages (line 2 above) recover() sends a special error message so that observe() can pop a value stack, if any (line 3), and recover() pops the state stack (line 4). If $error is never expected an irrecoverable error is eventually thrown (line 23) and aborts recognition. Otherwise, once $error is expected, process() deals with it, wrapped in an artificial Tuple (line 7). If there is a shift message for $error the search is on for a shift message for an input symbol (lines 8 to 20). If found, this input symbol is consumed (line 11) and recover() returns (line 12). If instead there was a reduce message before the input symbol the message is executed, followed by goto as usual, and the input symbol is retried (back to line 8). If the input symbol is not expected (at line 14) end of input results in an irrecoverable error (line 15 to line 23) and other input is discarded (line 18 back to line 8). Finally, if there is a reduce message before $error it is executed, followed by goto as usual, and either the new state expects $error or the new state is popped, too (line 7 back to line 1). This is a tutorial implementation; therefore, all discarded symbols are reported (line 18). The algorithm could be modified to be less chatty and perhaps require more than one successful shift message, i.e., accepting more than one input symbol, before normal processing is resumed. Example 10/15 implements error recovery for a sentence consisting of a list of one or more copies of the letter a: sentence: some; sentence: $error; some: 'a'; some: some 'a'; some: $error; some: some $error; The very first button should show . If not, click it until it does. Toggle and press to represent and check the grammar. There is a reduce/reduce conflict in state 2: state 2 sentence: $error ●; some: $error ●; $eof reduce (sentence: $error;) 'a' reduce (some: $error;) $error reduce (some: $error;) for $eof reduce/reduce conflict between (some: $error;) and (sentence: $error;) The conflict happens at the end of input and is resolved in favor of the earlier rule 2 (line 5). This can be seen if input is simply the letter b: Toggle and press : STATE TUPLE MESSAGE RETURNS 0 (1) \"b\" error -message- null error: at (1) \"b\": (1) \"b\" is not allowed expecting: 'a' 0 eof \"\" $error shift 2 null 2 eof $eof reduce sentence: $error; null 0 eof $eof goto 4 null 4 eof $eof accept null Move rule 2 to the end of the grammar, press to prepare the modified grammar, and press : STATE TUPLE MESSAGE RETURNS 0 (1) \"b\" error -message- null error: at (1) \"b\": (1) \"b\" is not allowed expecting: 'a' 0 eof \"\" $error shift 2 null 2 eof $eof reduce some: $error; null 0 eof $eof goto 3 null 3 eof $eof reduce sentence: some; null 0 eof $eof goto 4 null 4 eof $eof accept null Toggle and press again to see that different lists are built depending on which rule catches the error. Try different inputs — including none — to see that an irrecoverable error cannot happen for this grammar. Idioms for $error The placement of $error symbols in BNF grammar rules is guided by the following, conflicting goals: as close as possible to the start symbol of the grammar. This way there is always a point to recover from because there should always be a state very low on the stack in which $error is expected. The parser then is unable to clear its stack early, i.e., to not accept the end of input from the scanner. as close as possible to each terminal symbol. This way only a small amount of input would be skipped on each error. without introducing conflicts. This may be quite difficult. In fact, accepting shift/reduce conflicts is reasonable as long as they serve to lengthen strings. E.g., one can continue parsing an expression past an error, rather then accepting the same error at the statement level, thus trashing the rest of the expression. Given these goals, there are typical positions for $error symbols: in each recursive construct, i.e., in iterations such as statement lists in a program, argument lists in a function call, etc. preferably not at the end of a rule because that is more likely to cause conflicts. non-empty lists (some) require two $error symbols: one for a problem at the beginning of the list, and one for a problem at the current end of the list — see example 10/15. possibly empty lists (many) require an $error symbol in the empty branch — if this causes bad conflicts the symbol could be added to the places where the possibly empty list is referenced. Example 10/16 is a blueprint for typical constructs: example: ; example: example 'many' many ';'; example: example 'some' some ';'; example: example 'list' list ';'; Input consists of any number of examples. An example starts with the name of a construct and ends with a semicolon. There is no error recovery at this level — e.g., calling for a non-existing construct causes an irrecoverable error. Each construct should recover from all errors so that the terminating semicolon can be found. The following action class Actions { example (... arg) { if (arg.length) puts(`reduced ${arg[1]}`); } } will confirm successful recovery within each construct. many: ; many: many 'm'; many: many $error; A many construct contains any number of m but no other letters. One additional rule with $error in place of m is sufficient for a full recovery. For example, in the following input many; many m m; many A; many B m; many m C m; many m D m E; the upper-case letters are not allowed but the many construct is still reduced six times. some: 's'; some: some 's'; some: $error; some: some $error; Similarly, some contains one or more s but no other letters and two rules with $error in place of s are required for a full recovery. Again, in the following input some s s; some F; some G s; some s H s; some s s I; the upper-case letters are not allowed but the some construct is still reduced five times. list: 'l'; list: list ',' 'l'; list: $error; list: list $error; list: list $error 'l'; Finally, list is defined as a comma-separated list of one or more l. For programming language grammars this is probably the most frequently used construct. Unfortunately, it is also the most complicated. The following input contains many errors such as unexpected upper-case letters and missing or superfluous commas: list l; list l, l; list l,; list J; list l K; list l L l; list l, M; list l, N l; list l, O,; list l, P, l; list l, Q, l,; The output shows that list is still reduced eleven times. Example 10/16 contains the grammar and the input shown above. It is instructive to compare input and error messages: The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the error messages. As expected, every upper-case character in the input triggers a message, but the examples for list additionally complain about three unexpected semicolons. The output does not end with an irrecoverable error. In order to avoid message bursts, recover() discards illegal characters silently, but discarded tokens and literals are reported. Add a token definition { Bad: /[A-Z]/ } and a rule example: Bad; so that the token is used in the grammar and recognized by the scanner and press and to see the discard messages. Example 10/17 contains the same grammar and input as before and adds the following actions to record the numbers of the rules which are reduced: class Actions { example (example, tag, rules) { if (!(typeof example == 'string')) return ''; // example: ; return `${example}${tag} ${rules.join(' ')}\\n`; // example: ... } many (many, m) { if (!many) return [ 5 ]; // many: ; many.push(m == 'm' ? 6 : 7); return many; // many: many 'm'; } some (some, s) { if (some == 's') return [ 8 ]; // some: 's'; if (!some) return [ 10 ]; // some: $error; some.push(s == 's' ? 9 : 11); return some; // some: some 's'; } list (list, comma, l) { if (list == 'l') return [ 12 ]; // list: 'l'; if (!list) return [ 14 ]; // list: $error; if (comma == ',') list.push(13); // list: list ',' 'l'; else if (l == 'l') list.push(16); // list: list $error 'l'; else list.push(15); // list: list $error; return list; } } An action is called when a rule is reduced and selected by the non-terminal name. The actions above are based on the following: a shift of a terminal pushes the input value onto the value stack, a shift of $error pushes null, a goto pushes the result of a rule's action, and a rule's action receives one value corresponding to each symbol on the right-hand side. The output shows for each recognized construct the list of rule numbers which were reduced during recognition, for example: input output rules many; many 5 5 many: ; many m m; many 5 6 6 6 many: many 'm'; many A; many 5 7 7 many: many $error; many B m; many 5 7 6 many m C m; many 5 6 7 6 many m D m E; many 5 6 7 6 7 The very first button should show . If not, click it until it does. Press to represent and check the grammar, toggle to suppress messages about mismatched argument counts, and press to see the raw result data — how often is each rule used? Example 10/18 can be used to analyze some interactions of error recovery strategies. The idea is to recognize one or more a followed by one or more b. Each can be done with and without error recovery: as: 'a'; as: as 'a'; aes: 'a'; aes: $error; aes: aes 'a'; aes: aes $error; Both sets of rules, as and aes, recognize one or more a but only aes includes error recovery. bs and bes are defined in the same fashion. Finally, a sentence starts by selecting a strategy, from 1 to 4, followed by some a and then some b. As a fallback, sentence includes $error but no provision to try again: sentence: '1' as bs ';'; sentence: '2' aes bs ';'; sentence: '3' as bes ';'; sentence: '4' aes bes ';'; sentence: $error; A typical (faulty) input is 1 b a b a; The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see that all but the strategy input in the is discarded. Toggle and press again to see why there is no irrecoverable error. Toggle and press again to find out which single input symbol is recognized. Change 1 in the to 2, etc., and repeat the experiments for the different recovery strategies. Which strategy results in an irrecoverable error and why? Does the resolution of the conflict in state 23 make any difference? How many a or b are ever passed to an action, if any? Error recovery for EBNF Example 10/19 recognizes all sentences but one which example 10/16 recognizes: examples: { example }; example: many | some | list | $error; many: 'many' [{ 'm' }] ';'; some: 'some' { 's' } ';'; list: 'list' 'l' { ',' 'l' } ';'; Which \"sentence\" for example 10/16 is no longer acceptable? A simple action can show the list that each example recognizes: class Actions { example (e) { puts('example', g.dump(e)); } } The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see that the recursive descent parser can handle all examples involving many: many; many m m; many A; many B m; many m C m; many m D m E; some s s; some F; ... The recursive descent parser succeeds as long as it drops illegal characters but it fails after dropping F because check before you call cannot enter the iteration in the rule for some and the recursive descent parser is not designed to recover. To work with the stack-based parser, click the very first button to show . Press to represent and check the grammar and toggle and press to see how the stack-based parser survives all examples. Remove | $error from the second rule and try again. $error has no effect in the recursive descent parser. However, it is an alternative of the top-level iterative construct in this grammar and allows the stack-based parser to recover. The trace shows that a lot of meaningful input is discarded. Reload the example, click the very first button until it shows , toggle to insert $error into all iteration constructs during the translation to BNF, and press to represent and check the grammar again. There are a number of reduce/reduce conflicts which are all caused by the explicit $error token in the second rule. Remove | $error from the second rule, press to represent and check the grammar again, and toggle and press to see that the stack-based parser again survives all examples. The trace shows that with the semi-automatic error recovery produced by a lot more meaningful input is recognized. In general, the stack-based parser is preferable because it can work with more grammars, e.g., with a shift/reduce conflict for a dangling else, and it usually recovers well if $error is automatically inserted into iterations expressed with braces in EBNF. If a grammar is used to explain the features of a programming language, the effects of braces and brackets in EBNF are easier to understand than left recursion and empty alternatives in BNF. Actions are easier to design for EBNF and they do not have to be changed for the translation to BNF. Quick Summary Parser Types. LL(1) refers to recognition from left to right searching for the left-most derivation with one symbol lookahead. This is known as top-down because the left-most derivation determines the root of the parse tree. The lookahead symbol is used for the check before you call approach discussed in chapter four. LR(1) instead searches for the right-most derivation. This is known as bottom-up because it creates the parse tree from the leaves to the root. Grammars suitable for LL(1) parsing are suitable for LR(1) parsing. The opposite is not true; e.g., some left-recursive grammars are suitable for LR(1) parsing. State-Transition Table. A state-transition table is computed from a BNF grammar by considering all acceptable input sequences. States are sets of marked rules. Rules and rule lengths are finite, i.e., the set of states is finite. Starting with a mark at the beginning of the start rule of the grammar, closure is applied to each new state, i.e., if the mark precedes a non-terminal, all rules for the non-terminal are added to the state and marked at their beginnings. shift transitions for each combination of a state and an input symbol are defined by moving each mark across the next terminal in it's rule. goto transitions, instead, involve non-terminals. This finite process can result in new marked rules and then new states. Completed rules have the mark at their end. For simplified LR(1), a reduce transition is defined if the lookahead is in the follow set of the rule. Conflicts and Resolution. There is a reduce/reduce conflict if several different rules in the same state have the mark at their end and if the lookahead is in the follow set of each. Recognition would be based on whichever conflicting rule appears earlier in the grammar. There is a shift/reduce conflict if in the same state there is a mark at the end of one rule and the lookahead is in the follow set and in a different rule the mark can be moved across the lookahead. In this case, recognition will be based on shift, i.e., accept more input, which implements, e.g., proper dangling else recognition. Explicit shift/reduce Conflict Resolution. A precedence table preceding a grammar assigns decreasing precedence levels and associativity to lists of terminals. A precedence clause at the end of a single BNF rule copies precedence level and associativity to the last terminal in the rule. Conflicts are hidden and resolved according to the following table: last rule terminal follow terminal resolution higher precedence lower reduce lower higher shift equal, %left equal reduce equal, %right equal shift equal, %nonassoc equal error Recognition. Based on a state-transition table, a LR(1) parser consumes lookaheads and pushes it's new states onto a stack until the combination of state and lookahead indicates that a rule has been completed. The states corresponding to the rule are popped and a new state corresponding to the completed rule is pushed. End of input should cause a transition to a legal state. The parser can be observed. An observer maintains a stack of values parallel to the states and offers them to actions when rules are reduced. EBNF can be translated to BNF and hidden actions added so that identical actions can be used by a top-down and a bottom-up parser. Error Recovery If there is an unexpected input symbol the parser will pop the state stack until the input symbol is expected or the stack is empty, i.e., recognition failed. For better control, grammar rules can contain $error tokens which accept no input but, if expected in a state, will stop the stack popping and result in a state transition. Next, unexpected input symbols are discarded until either recognition can continue with a shift transition or the end of input is reached. $error tokens are most effective when inserted into iteration constructs, especially, when EBNF is translated into BNF to construct a more powerful parser. Previous: 9. Compiling Grammars Next: 11. Compiling Revisited × Search results Close "},"tutorial-11-trees.html":{"id":"tutorial-11-trees.html","title":"Tutorial: 11. Compiling Revisited","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit 11. Compiling Revisited What's in a Tree? What's with a Tree? Chapter six started the implementation of a little language with expressions and control structures which concluded with first-order functions in chapter eight. Chapter seven contained a short section on type-checking. Overall, the discussion focussed on semantic analysis and code generation as part of syntax analysis, i.e., carried out by the actions called when grammar rules were completed. This approach is called one-pass compilation because the source program is immediately rewritten in the target language — it is not converted to an intermediate representation to be processed more than once. One-pass compilation should require less time and memory but the resulting code might not be as performant. This chapter explores a different approach: the source program is represented as a tree and visitors take care of type-checking and code generation. The result is much better separation of concerns and reusability of the components. Base classes provide infrastructure for tree building and visiting. Mix-ins implement tree-building actions for recognition and tree-processing methods for visitors and are used to allow selective sharing of methods. Classes and Mix-Ins Classes can be extended by adding or overriding methods. If a method m() exists in both, the original superclass, and the subclass resulting from extending the superclass, the subclass method can call the superclass method as super.m(), i.e., overriding a method does not discard it's code. Mix-ins are functions which conceptually add methods to classes: const Mix = superclass =&gt; class X extends superclass { hello () { console.debug('hello world', super.constructor.name); } }; try { new class A { } () . hello(); } catch (e) { console.log(e.message); } finally { new (Mix(class A { })) () . hello (); new (Mix(Mix(class A { }))) () . hello(); } This code produces the following output: (intermediate value).hello is not a function hello world A hello world Class A has no method hello() (code lines 4 and 5, output line 1). Mix(class A {}) creates a class which has A as the superclass and has the method hello() (code line 6, output line 2). Mix-ins can be cascaded. Mix(Mix(class A {})) creates a subclass of the subclass created by Mix(class A {}) and these subclasses have no names (code line 7, output line 3). The point is that mix-ins can be applied to \"add\" methods, but there is no extra code if the mix-ins are not applied, i.e., mix-ins can be used to group functionality which can optionally be added to a class. Once added it will be inherited. The code above shows that JavaScript does not need language elements to specifically support mix-ins. There are different ways to implement such a feature. The technique shown above is taken from a paper by Justin Fagnani. The examples in this chapter are largely cumulative. To avoid repetition, the practice page includes a module Eleven which contains all classes and mix-ins defined and used in the examples in this chapter. They are summarized in appendix D. The methods can be seen in the method browser. Building a Tree Chapter four looked at the arithmetic expression 1 - (2 + - 3) which can be represented, e.g., by the following tree: In JavaScript this tree can be represented using nested lists as follows: [ 'subtract', [ 'number', 1 ], [ 'add', [ 'number', 2 ], [ 'minus', [ 'number', 3 ] ] ] ] Each node of the diagram is an Array in JavaScript. The first element of each array is a tag, represented as a string with lower-case letters. The remaining elements are values and, in particular, further nodes represented as arrays. Using Recursive Descent Example 11/01 shows that it is relatively easy to create a tree for a list of arithmetic expressions. The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the tree which is built for the list of expressions in the . Given the rules number: Number; term: number | '(' sum ')'; signed: [ '-' ] term; the corresponding tree-building action methods would be something like number (number) { return [ 'number', parseInt(number, 10) ]; } term (...val) { return val.length == 1 ? val[0] : val[1] } signed (minus, term) { return minus ? [ 'minus', term ] : term; } and left associativity can be handled with an iteration in the grammar product: signed [{ multiply | divide }]; multiply: '*' signed; divide: '/' signed; and by creating lists with \"holes\" multiply (x, right) { return [ 'multiply', null, right ]; } divide (x, right) { return [ 'divide', null, right ]; } and assembling them with reduce() from left to right as follows: product (signed, many) { return (many ? many[0] : []). reduce((product, alt) =&gt; (alt[0][1] = product, alt[0]), signed); } Building a Tree for Arithmetic Build is the base class for the tree builders created in this chapter: class Build { /** Sets the property */ constructor (parser) { this.parser = parser; } /** Tags node with source position as `.lineno` if available. */ _lineno (node) { if (this.parser.current &amp;&amp; this.parser.current.lineno) node.lineno = this.parser.current.lineno; return node; } } Build provides access to the parser (line 3 above), e.g., for error reporting and access to the source line numbers. If errors are detected when trees are processed the error messages should refer back to the source program. Therefore, _lineno() tries to add a property .lineno to a tree node (line 8) which references the current source seen by the parser during tree building. BuildRD() is a mix-in which contains the actions to build a tree for arithmetic expressions based on the recursive descent grammar shown in the previous section. Combined as Build_RD(Build), the superclass Build and the mix-in Build_RD() result in the subclass which should be handed to the parse() method. Example 11/01 uses the trick introduced in chapter six to accomplish this: (() =&gt; { // define and immediately use an anonymous function class Build { ... } const Build_RD = superclass =&gt; class extends superclass { ... }; return Build_RD(Build); }) () The class and mix-in definitions are placed into an anonymous function where return delivers the actual class for parse() (line 4 above) and the anonymous function is called immediately after being defined (line 5). The very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the tree which is built for the expression in the . Replace the entire text in the by Eleven.Build_RD(Eleven.Build) to import the builder class from the module Eleven and repeat the steps. Using Precedences The LL(1) grammar for arithmetic expressions has to use iterations and nested rules so that the resulting tree reflects the expected associativities and precedences. Instead, example 11/02 uses explicit precedences and an ambiguous, very recursive grammar: %left '+' '-'; %left '*' '/'; %right '**'; %right Number; expr: add | subtract | multiply | divide | power | minus | '(' expr ')' | number; add: expr '+' expr; subtract: expr '-' expr; multiply: expr '*' expr; divide: expr '/' expr; power: expr '**' expr; minus: '-' expr %prec Number; number: Number; In example 11/02 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the tree which is built for the expression in the . Delete the code in the and compare the previous output to the nested lists which are built without the actions — these lists represent the same nesting and information but would be much harder to process again. Using an SLR(1) grammar with precedences hugely simplifies the class actions for building, e.g., const Build_Number = superclass =&gt; class extends superclass { expr (...values) { return values.length &gt; 1 ? values[1] : values[0]; } add (a, x, b) { return this._lineno([ 'add', a, b ]); } ... }; The anonymous function pattern can be reused from the previous example: (() =&gt; { // define and immediately use an anonymous function const Build_Number = superclass =&gt; class extends superclass { ... }; return Build_Number(Eleven.Build); }) () The advantage of using mix-ins is that Build_Number(Eleven.Build) only contains methods which match the structure of the SLR(1) grammar, i.e., if the grammar is changed, only the corresponding mix-ins has to be adapted. Build actions very closely match their rules. In spite of different parsers, different grammars, and different actions, both examples, 11/01 and 11/02, build the same trees for sentences which are recognized by both grammars. This means that code for further processing of the trees can be shared. Visiting a Tree Visitors are objects which apply algorithms such as evaluation, type-checking, code-generation, etc., to data structures such as a tree constructed by the action methods described in the previous section. Visitors can be used to separate concerns in a way very similar to the interplay between grammar rules and actions. Example 11/03 implements expression evaluation using a visitor. Visit is the base class for visitors: class Visit { trace = false; // RegExp selects tags to display visit (node, trace) { if (trace instanceof RegExp) this.trace = trace; // not a list: return it if (!(node instanceof Array)) return node; // visit let result; const show = this.trace instanceof RegExp &amp;&amp; this.trace.test(node[0]) ? this._dump(node, 0) : false; try { return result = this.constructor.prototype[node[0]].call(this, node); } finally { if (show) puts(show, 'returns', this._dump(result, 1)); } } The most important method is visit(). It is called to apply the visitor's algorithm to a node. An optional parameter can turn on tracing by setting the .trace property (line 7 above) to make the setting permanent. The node argument should be an Array, otherwise it is simply returned (line 9). A \"real\" node, i.e., an Array, contains a tag as first element which is used to select a method of the visitor (line 15). The method is called with the node as the only argument and the result is returned. There can be tracing, depending on the node's tag and the setting of the property .trace (line 13). The method might change the contents of the node; therefore, part of the display is computed before the method is called (line 13) and it is shown together with the result returned by the method (line 17). Visit has a few more methods. _tree() acts as an assertion. It recursively walks a tree, nodes before subtrees, and checks if there are methods for all the node tags. If not it throws an error message. _tree (node) { // recursively validates a tree if (!(node instanceof Array)) return; if (!node.length) throw 'empty node'; if (typeof node[0] != 'string') throw 'node tag is not a string'; if (!node[0].length) throw 'empty node tag'; if (node[0] == 'visit') throw \"'visit' cannot be a tag\"; if (typeof this.constructor.prototype[node[0]] != 'function') throw node[0] + ': unknown node tag'; node.slice(1).forEach(node =&gt; this._tree(node)); } _dump() recursively converts a tree into a string — up to a certain depth. If the argument is not a tree it is decoded (line 2 below). Otherwise the tag and — depending on depth — the other entries are shown (line 10). If present as .lineno, the source line number is appended to the node display (line 12). Similarly, information from .type would be shown (line 13). _dump (node, shallow = -1) { // recursively dumps a tree if (!(node instanceof Array)) switch (typeof node) { case 'boolean': case 'number': return node; case 'string': return \"'\" + node.replace(/(['\\\\\\n])/g, \"\\\\$1\") + \"'\"; default: return typeof node; } let result = '[ ' + (!shallow ? this._dump(node[0]) : node.map(item =&gt; this._dump(item, shallow - 1)).join(' ')) + ' ]'; if ('lineno' in node) result += '.' + node.lineno; if ('type' in node) result += ':' + node.type; return result; } Finally, _error() is used to report and count errors during a visit: errors = 0; // counts calls to _error() _error (lno, ... s) { if (typeof lno == 'number' &amp;&amp; lno &gt; 0) lno = `line ${lno}:`; else lno = s.splice(0, 1)[0]; puts(`error ${++ this.errors}: ${lno}`, ... s); } }; Methods such as _tree(), _dump(), and _error() should not be mistakenly used for node tags; therefore, these \"private\" method names start with an underscore. Because of it's importance for the concept, visit() is a deliberate exception to this convention. Interpreting Arithmetic Expressions With the infrastructure provided by Visit, interpretation of an arithmetic expression amounts to a traversal of the tree, i.e., evaluation visits to the subtrees before an operation specific to a node is applied: const Eval_Number = superclass =&gt; class extends superclass { add (node) { return this.visit(node[1]) + this.visit(node[2]); } subtract (node) { return this.visit(node[1]) - this.visit(node[2]); } multiply (node) { return this.visit(node[1]) * this.visit(node[2]); } divide (node) { return this.visit(node[1]) / this.visit(node[2]); } power (node) { return this.visit(node[1]) ** this.visit(node[2]); } minus (node) { return - this.visit(node[1]); } number (node) { return this.visit(node[1]); } }; Each node has a tag defining the operation and one or two operand values or subtrees which have to be evaluated first. In the implementation shown above the evaluation order for the subtrees is defined by the implementation language, i.e., strictly left-to-right for JavaScript. This could be changed by temporarily storing the second subtree value in a local variable in each method. Main Program The mix-in Main() contains action methods which let new top-level rules for the grammar do the job of a main program — at the expense of not discarding the parser first. Here are the new rules, start rule first: run: main; main: dump; dump: expr; expr: add | subtract | ... ; The action for dump will display and return the tree built by expr: const Main = (superclass, ...args) =&gt; class extends superclass { dump (tree) { puts(new Visit()._dump(tree)); return tree; } The action for main (discussed below) arranges for one or more visits to the tree and returns the last visit — in this case expression evaluation — as a parameterless function and the action for run executes this function and returns the result: run (funct) { return funct(); } The rules for dump or run can be omitted and the other rules adjusted if there is no need to display the tree or if main is expected to create an executable which can be run more than once. Classes or mix-ins for visitors can be imported or the anonymous function pattern in the can be used to define them. The call on the mix-in Main() determines in which order the visitors are applied: (() =&gt; { // define and immediately use an anonymous function // base class with visitor methods class Visit { ... } // mix-in for expression evaluation const Eval_Number = superclass =&gt; class extends superclass { ... }; // mix-in with top-level actions, runs visitors const Main = (superclass, ...args) =&gt; class extends superclass { dump (tree) { ... } main (tree) { ... } run (funct) { ... } }; // result of anonymous function return Main(Eleven.Build_Number(Eleven.Build), // builder actions Eval_Number(Visit), // evaluation visitor /./); // node selector for trace, if any }) () The action for main depends on a closure over extra arguments of the mix-in Main(). ...args consists of one or more visitor classes (lines 11 and 18 above) and optionally one regular expression to control tracing (line 19). The last visit, if any, is returned as a function: main (tree) { let [lastVisitor, lastTree, trace] = this._doVisits(tree, args); return () =&gt; lastVisitor.visit(lastTree, trace); } The private method _doVisits() is called with a tree and a list of extra arguments to consume. It returns a list containing the last visitor object, the tree to apply it to, and the tracing expression, if any: _doVisits (tree, args) { let trace; // (first) trace pattern, if any const visitors = args.filter(arg =&gt; { // remove patterns if (!(arg instanceof RegExp)) return true; if (!trace) trace = arg; return false; }), tail = visitors.splice(-1, 1); // last visitor, others if (!tail.length) throw 'main: no visitors'; let caller; // each visitor is constructed with caller [tree, caller] = visitors.reduce(([tree, caller], Visitor) =&gt; { const visitor = new Visitor (caller); // create next visitor visitor._tree(tree); // validate tree tree = visitor.visit(tree, trace); // visit if (trace) { puts(visitor._dump(tree)); } // trace, if any if (visitor.errors) throw `${visitor.errors} error(s)`; return [tree, visitor]; // done; next visit if any }, [tree, this]); // first caller is the builder const lastVisitor = new tail[0](caller); // last visitor object lastVisitor._tree(tree); // validate tree return [ lastVisitor, tree, trace ]; } First the arguments are split into a trace pattern, if any, a list of all but the last class, if any, and the last class (lines 2 to 9 above). One after another, a visitor is created from a class, each incoming tree is checked and visited, and each resulting tree is shown if requested (lines 11 to 15). The last (or possibly only) visitor is created, the last tree is checked, and the visitor, tree, and trace pattern are returned (lines 19 to 21). In example 11/03 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the tree which is built for the expression in the , followed by the result of interpreting the expression. Remove the run rule, press to represent and check the new grammar, press to see the tree, and press to interpret. Remove the dump rule, adjust the main rule, and repeat the steps. Finally, add a regular expression such as /./ to the call to Main() near the end of the to trace interpretation. Representing a Little Language Example 11/04 adds variable names, comparisons, control structures, and a few other statements to the grammar: %nonassoc '=' '&lt;&gt;' '&gt;' '&gt;=' '&lt;' '&lt;='; %left '+' '-'; ... stmts: stmt [{ ';' stmt }]; stmt: assign | print | loop | select; assign: Name '=' expr; print: 'print' expr [{ ',' expr }]; loop: 'while' expr 'do' stmts 'od'; select: 'if' expr 'then' stmts [ 'else' stmts ] 'fi'; expr: eq | ne | gt | ge | lt | le | add | ... | number | name; eq: expr '=' expr; ... le: expr '&lt;=' expr; add: expr '+' expr; ... name: Name; Comparisons have lower precedence than arithmetic operators (line 1 above) and — different from JavaScript — are not associative, i.e., they cannot be chained. They are added to the rule for expressions (line 11). Any expression can be the condition for a while loop (line 8) or an if statement (line 9) — this will be restricted later with type checking. A name can be a term in an expression (line 12). It can be used in an assignment statement (line 6). Tree building reuses Build_Number() to support arithmetic expressions and add the mix-ins Build_Cmps() for comparisons, Build_Stmts() for statements, and Build_Names() for names. Comparisons are represented just like arithmetic operations: const Build_Cmps = superclass =&gt; class extends superclass { // eq: expr '=' expr; eq (a, x, b) { return this._lineno([ 'eq', a, b ]); } ... }; A single statement is just returned, but a list of two or more statements is collected into one 'stmts' node: const Build_Stmts = superclass =&gt; class extends superclass { // stmt: assign | print | loop | select; stmt (stmt) { return stmt; } // stmts: stmt [{ ';' stmt }]; stmts (stmt, many) { return many == null ? stmt : this._lineno([ 'stmts', ...many[0].reduce( (stmts, alt) =&gt; { stmts.push(alt[1]); return stmts; }, [ stmt ]) ]); } A print statement is represented as a 'print' node with a list of expression subtrees: // print: 'print' expr [{ ',' expr }]; print (x, expr, many) { return this._lineno([ 'print', ...(many ? many[0] : [ ]).reduce( (exprs, alt) =&gt; { exprs.push(alt[1]); return exprs; }, [ expr ]) ]); } A while loop is represented as a 'loop' node with a condition expression and a single statement or a list of statements: // loop: 'while' expr 'do' stmts 'od'; loop (w, expr, d, stmts, o) { return this._lineno([ 'loop', expr, stmts ]); } An if statement is represented as a 'select' node with a condition and one or two dependent statements or lists: // select: 'if' expr 'then' stmts [ 'else' stmts ] 'fi'; select (i, expr, t, left, opt, f) { const result = this._lineno([ 'select', expr, left ]); if (opt) result.push(opt[1]); return result; } }; In this little language, names are simply Name tokens referencing variables; however, they could be references to functions or array elements, etc. Therefore, tree building actions for statements and operands involving names are collected into a separate mix-in: const Build_Names = superclass =&gt; class extends superclass { // assign: Name '=' expr; assign (name, x, expr) { return this._lineno([ 'assign', name, expr ]); } // name: Name; name (name) { return this._lineno([ 'name', name ]); } }; As an example, Euclid's Algorithm x = 36; y = 54; while x &lt;&gt; y do if x &gt; y then x = x - y else y = y - x fi od; print x is represented as the following tree: [ 'stmts' [ 'assign' 'x' [ 'number' 36 ] ] [ 'assign' 'y' [ 'number' 54 ] ] [ 'loop' [ 'ne' [ 'name' 'x' ] [ 'name' 'y' ] ] [ 'select' [ 'gt' [ 'name' 'x' ] [ 'name' 'y' ] ] [ 'assign' 'x' [ 'subtract' [ 'name' 'x' ] [ 'name' 'y' ] ] ] [ 'assign' 'y' [ 'subtract' [ 'name' 'y' ] [ 'name' 'x' ] ] ] ] ] [ 'print' [ 'name' 'x' ] ] ] In example 11/04 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the tree. Change the grammar so that assignment uses a name reference rather than a Name token. How does the tree change and what would be the consequence for evaluation? Add a start rule to dump the resulting tree with line numbers and use the mix-in Eleven.Main() to provide the action. Interpreting a Little Language Example 11/05 reuses Eleven.Main() for the top-level rules and the classes and mix-ins discussed so far for the build actions and to interpret arithmetic expressions. It adds new mix-ins Eval_Cmps() to interpret comparisons, Eval_Stmts() to interpret statements, and Eval_Names() to interpret names with a symbol table: (() =&gt; { // define and immediately use an anonymous function // ... new mix-ins ... // builder and interpreter-visitor return Eleven.Main(Eleven.Build_Stmts( Eleven.Build_Names( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build)))), Eval_Stmts( Eval_Names( Symbols( Eval_Cmps( Eleven.Eval_Number(Eleven.Visit)))))); }) () Comparisons are interpreted just like arithmetic operations with a postorder traversal, i.e., the subtrees are visited and interpreted first and then the comparison is applied: // mix-in with comparisons const Eval_Cmps = superclass =&gt; class extends superclass { // [ 'eq' a b ] eq (node) { return this.visit(node[1]) == this.visit(node[2]); } ... }; A list of statement nodes is interpreted one by one: // mix-in with statements and list evaluation const Eval_Stmts = superclass =&gt; class extends superclass { // [ 'stmts' stmt ... ] stmts (node) { node.slice(1).forEach(stmt =&gt; this.visit(stmt)); } For a 'print' node all expression subtrees are visited and interpreted and the results are displayed together, separated by blanks: // [ 'print' value ... ] print (node) { puts(...node.slice(1).map(value =&gt; this.visit(value))); } A 'loop' node is interpreted by repeatedly interpreting the condition subtree followed by the loop body subtree if the condition is true and returning as soon as the condition is false: // [ 'loop' cond stmt ] loop (node) { while (this.visit(node[1])) this.visit(node[2]); } A 'select' node is interpreted by evaluating the condition subtree followed by the then subtree if the condition is true or the else subtree if the condition is false and there is one: // [ 'select' cond then else? ] select (node) { if (this.visit(node[1])) this.visit(node[2]); else if (node.length &gt; 3) this.visit(node[3]); } }; In this little language, names are simply Name tokens referencing variables; however, they could be references to functions or array elements, etc. Therefore, statements and operands involving names are collected into a separate mix-in which requires a symbol table. The mix-in Symbols() uses a Map to store objects with arbitrary properties as descriptions for names. If available, this Map is imported from the preceding visitor so that a sequence of visitors can add more information (line 5 below): // mix-in with symbol table const Symbols = superclass =&gt; class extends superclass { constructor (prev, ... more) { super(prev, ... more); this.symbols = prev?.symbols ?? new Map (); } _alloc (name) { let symbol = this.symbols.get(name); // check if exists if (!symbol) // create with ordinal this.symbols.set(name, symbol = { ord: this.symbols.size + 1 }); return symbol; } }; The mix-in construction creates an anonymous class which can have an explicit constructor. If it does one has to be careful how arguments are managed — it is probably best to assume that all mix-ins along the chain receive the same set of arguments (line 3 above). A private method _alloc() returns a description for a name and creates one if none exists. Each symbol receives a property .ord which labels them in order of creation, starting with 1 (line 12) The mix-in Eval_Names() can use Symbols() to interpret operations on a name: // mix-in with name evaluation const Eval_Names = superclass =&gt; class extends superclass { // [ 'name' name ] name (node) { const symbol = this._alloc(node[1]); if (!('value' in symbol)) symbol.value = 0; return symbol.value; } // [ 'assign' name value ] assign (node) { this._alloc(node[1]).value = this.visit(node[2]); } }; When a reference to a name is interpreted, a description is located or created (line 5 above), initialized with zero if there is no value (line 6), and the current value is returned (line 7). To interpret an 'assign' node a description for the name is located or created and the value is computed by a visit to the subtree and stored in the description. Note that the evaluation order of the implementation language might play a role: should the name be defined and initialized before or after the value to be assigned is computed? In example 11/05 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to create the executable. Press to execute; supply different values for x and y. Add a top-level run rule to interpret immediately and repeat the steps. Remove the dump rule, adjust the main rule, and repeat the steps. Add a regular expression such as /./ to the call to Main() to trace interpretation. Finally, change the so that all code is imported from module Eleven (this just requires small changes to the return statement), recompile, and execute. Rewriting a Tree A visitor can copy a tree or modify it in place, e.g., when type checking a program. In chapter seven it was demonstrated in example 7/02 that type checking is very similar to evaluation, with types replacing actual values. Result types are propagated from the leaves of the tree through the operator nodes to the statement nodes, and at each level the expectations are checked against the incoming types, e.g., a Boolean condition for a loop, or a string value for assignment to a variable declared with a string type. Mismatches can be reported as errors or corrected by applying implicit conversions. Alternatively, for type inference, sets of types acceptable to operators are pushed to the leaves of the tree, pruned for literals, and act as constraints on variables. Typed Expressions Example 11/06 implements evaluation for expressions which include bool, number, and string values. The grammar is extended with the typical operations: %left 'or'; %left 'and'; %nonassoc '=' '&lt;&gt;' '&gt;' '&gt;=' '&lt;' '&lt;='; ... main: expr; expr: or | and | eq | ... | minus | not | len | input | cast | '(' expr ')' | bool | number | string; ... or: expr 'or' expr; and: expr 'and' expr; not: 'not' expr %prec Number; bool: 'true' | 'false'; len: 'len' expr %prec Number; input: 'input' [ String String ]; string: String; cast: '(' type ')' expr %prec Number; type: 'bool' | 'number' | 'string'; ... String is a new kind of token: a nonempty literal string value enclosed in single quotes, with single quotes, linefeeds, and backslashes escaped by backslashes: String: /'(?:\\\\['\\\\\\n]|[^'\\\\\\n])+'/ Extending the grammar requires a few new actions for tree building: const Build_Bool = superclass =&gt; class extends superclass { // or: expr 'or' expr; or (a, x, b) { return this._lineno([ 'or', a, b ]); } ... or(), and similarly and() and not(), build nodes for the Boolean operations. It is left up to interpretation or code generation whether or not and and or are short circuited. // bool: 'true' | 'false'; bool (bool) { return this._lineno([ 'bool', bool == 'true' ]); } }; bool() represents one of the new literals 'true' and 'false' as a 'bool' node with the corresponding raw Boolean value. const Build_String = superclass =&gt; class extends superclass { // len: 'len' expr; len (x, b) { return this._lineno([ 'len', b ]); } len() represents a unary operation which computes the length of a string as a 'len' node. // input: 'input' [ String String ]; input (i, opt) { return (opt ? opt : [ ]). reduce((r, s) =&gt; (r.push(s.slice(1, -1).replace(/\\\\(.)/g, '$1')), r), [ 'input' ]); } input() represents an input operation with optional prompt and default strings as an 'input' node which contains the raw strings, if any, without the enclosing quotes and without backslash escapes (line 5 above). // string: String; string (string) { return this._lineno([ 'string', string.slice(1, -1).replace(/\\\\(.)/g, '$1') ]); } }; string() represents a String literal as a 'string' node which contains the raw string value. const Build_Cast = superclass =&gt; class extends superclass { // type: 'bool' | 'number' | 'string'; type (type) { return type; } // cast: '(' type ')' expr; cast (l, type, r, b) { return this._lineno([ 'cast', type, b ]); } }; Finally, cast() represents an explicit type cast with a type name and a value subtree as a 'cast' node. Interpreting Typed Expressions The implementation language JavaScript has enough (and sometimes surprising) implicit type conversions so that '2 ' == 2 &amp;&amp; '2' * '1\\\\3'.length + String(true) produces 6true. Translated to conform to the little language grammar above, the expression '2 ' = 2 and '2' * len '1\\\\3' + (string) true is represented as [ 'and' [ 'eq' [ 'string' '2 ' ].1 [ 'number' 2 ].1 ].1 [ 'add' [ 'multiply' [ 'string' '2' ].2 [ 'len' [ 'string' '1\\\\3' ].2 ].2 ].2 [ 'cast' 'string' [ 'bool' true ] ] ] ] An evaluation visitor needs additional methods corresponding to the additional build actions: const Eval_Bool = superclass =&gt; class extends superclass { // [ 'or' expr expr ] or (node) { return node.slice(1).reduce((result, tree) =&gt; { if (result) return result; // short-circuit result = this.visit(tree); if (typeof result != 'boolean') this._error(node.lineno, \"'or' non-boolean\"); return result; }, false); } ... or(), and similarly and() and not(), implement the Boolean operations. Both binary operations short-circuits evaluation; e.g., in or() subtrees are only visited until a true value is returned (line 5 above). The operations are only intended for Boolean values and report typing issues during evaluation (line 8). // [ 'bool' literal-value ] bool (node) { if (typeof node[1] != 'boolean') this._error(node.lineno, \"'bool' non-boolean\"); return node[1]; } }; bool() evaluates one of the new literals 'true' and 'false' which the build action has already converted. const Eval_String = superclass =&gt; class extends superclass { // [ 'len' expr ] len (node) { const val = this.visit(node[1]); if (typeof val != 'string') this._error(node.lineno, \"'len' non-string\"); return val.length; // undefined if not string } len() implements the unary len operation which computes the length of a string. The result is undefined — and reported — if the subtree value is not a string. // [ 'string' literal-value ] string (node) { if (typeof node[1] != 'string') this._error(node.lineno, \"'string' non-string\"); return node[1]; } string() evaluates a String literal where the build action has already elaborated the backslash escapes. // [ 'concat' a b ] concat (node) { const vals = node.slice(1).map(this.visit.bind(this)); if (vals.some(val =&gt; typeof val != 'string')) this._error(node.lineno, \"'concat' non-string\"); return vals[0] + vals[1]; } }; The little language is going to use + to designate both, number addition and string concatenation. Therefore, concat() is available to interpret a 'concat' node by interpreting the subtrees and concatenating the result. const Eval_Cast = superclass =&gt; class extends superclass { // [ 'cast' type value ] cast (node) { switch (node[1]) { case 'bool': return !! this.visit(node[2]); case 'number': return Number(this.visit(node[2])); case 'string': return String(this.visit(node[2])); default: throw node[1] + ': not expected for cast'; } } Finally, cast() implements an explicit type cast with a type and a value as a node. This method relies on conversions provided by the implementation language JavaScript. As before, builder and interpreter for typed expressions are imported or defined and combined in the : (() =&gt; { // define and immediately use an anonymous function // ... new mix-ins ... // builder and interpreter for typed expressions return Eleven.Main(Build_Cast( Build_String( Build_Bool( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build))))), Eval_Cast( Eval_String( Eval_Bool( Eleven.Eval_Cmps( Eleven.Eval_Number(Eleven.Visit)))))); }) () In example 11/06 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the error message and the result '6true'. Finally, add a regular expression such as /./ to the call to Main() near the end of the to trace interpretation and try expressions like true or 0 and false and 1 to see that the Boolean operations only evaluate as far as they have to. Checking Typed Expressions JavaScript is dynamically typed: every value belongs to a small set of types, variables accept values of any type, and operators implicitly convert argument values so that the operation can be applied. In particular, values can be passed to functions that are not specifically designed to deal with them — often resulting in confusing runtime errors. Statically typed languages try to avoid most implicit conversions and require that variable declarations include types. In particular, function parameters must be declared with types so that unexpected argument types can be detected during compilation. Type checking should be part of compilation and try to ensure that operations will only be applied to the type of values for which they are intended. It has a choice of silently inserting suitable cast operations or reporting errors to prevent execution. Example 11/07 implements type checking for typed expressions and inserts implicit conversions so that, e.g., the evaluation methods in Eval_Bool() will only receive Boolean values and the error message seen in example 11/06 is no longer triggered. The semantics of the typed expressions deliberately are defined to be different from the implementation language JavaScript, e.g., comparisons happen in the type of the left operand, they do not prefer the type 'number'. The grammar for typed expressions, builder, and interpreter remain unchanged from example 11/06. Type checking is implemented as a new visitor based on a new set of mix-ins. This visitor is applied after building and before interpretation, i.e., the has the following structure: (() =&gt; { // define and immediately use an anonymous function // base class for type checking class Check extends Eleven.Visit { ... } // ... type checking mix-ins ... // builder, type-checker, and interpreter for typed expressions return Eleven.Main(Eleven.Build_Cast( Eleven.Build_String( Eleven.Build_Bool( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build))))), Check_Cast( Check_String( Check_Bool( Check_Cmps( Check_Number(Check))))), Eleven.Eval_Cast( Eleven.Eval_String( Eleven.Eval_Bool( Eleven.Eval_Cmps( Eleven.Eval_Number(Eleven.Visit)))))); }) () In example 11/07 the very first button should show . If not, click it until it does. Press to represent and check the grammar and press to see the new result false. Add /./ as last parameter to the call to Main(), specifically to trace evaluation. Analyze why '2 ' = 2 produces false. Remove the type checking visitor from the call to Main() and check out that '2 ' = 2 now produces true. Consult the explanation of the JavaScript less than operator to see why. Check, the base class for type checking, inherits from Visit and adds a few utility methods: // base class for type checking class Check extends Visit { // [ 'bool' literal-value ] etc. _literal (node) { if (!(typeof node[1]).startsWith(node[0])) this._error(node.lineno, `expected ${node[0]} literal`); node.type = node[0]; return node; } _literal() receives a node describing a literal value, makes sure that the literal value has the expected type (line 5 above), notes the type in the .type property for the node (line 7), and returns the typed node. JavaScript passes arrays by reference. Therefore, like all other type checking methods, _literal() can return the node it received and modified — type checking can rewrite the tree in place. // [ tag expr ... ] _toType (type, node, index) { if (this.visit(node[index]).type != type) (node[index] = [ 'cast', type, node[index] ]).type = type; return node; } _toType() ensures that a subtree returns a specific type. _toType() receives the type name, a node — which it will return — and an index selecting a subtree. _toType() visits the subtree to perform type checking (line 3 above). If the subtree type is unexpected _toType() modifies the node by inserting a cast node on top of the subtree in place of the subtree (line 4) — an error could be reported instead. // [ tag expr ... ] _require (type, node) { node.slice(1).forEach((_, n) =&gt; this._toType(type, node, n+1)); node.type = type; return node; } _require() receives a type name and a node and applies _toType() to all subtrees to ensure that they return the type. It then notes the type in the .type property for the node, and returns the typed node. _require() and _literal() implement type checking for all operations on numbers and Boolean values: // mix-in to check arithmetic operations const Check_Number = superclass =&gt; class extends superclass { // [ 'add' expr expr ] add (node) { return this._require('number', node); } ... // [ 'number' value ] number (node) { return this._literal(node); } }; // mix-in to check Boolean operations const Check_Bool = superclass =&gt; class extends superclass { // [ 'or' expr expr ] or (node) { return this._require('bool', node); } ... // [ 'bool' value ] bool (node) { return this._literal(node); } }; Arithmetic operations such as add return a number and all operands have to produce numbers (line 4 above). Logic operations such as or are defined to return bool and the operands should produce Boolean values (line 13). Comparisons are defined to employ the type of the left operand and return a Boolean value: // mix-in to check comparisons const Check_Cmps = superclass =&gt; class extends superclass { // [ compare expr expr ] _cmp (node) { const type = this.visit(node[1]).type; this._toType(type, node, 2); node.type = 'bool'; return node; } // [ 'eq' expr expr ] eq (node) { return this._cmp(node); } ... }; _cmp() uses _toType() to convert the right operand if necessary (line 6 above) and marks that the node returns bool (line 7). _cmp() implements type checking for all comparisons (line 11). A string literal, input, and the len operation are straightforward to check: // mix-in to check string operations const Check_String = superclass =&gt; class extends superclass { // [ 'string' value ] string (node) { return this._literal(node); } // [ 'input' prompt? default? ] input (node) { node.type = 'string'; return node; } // [ 'len' expr ] len (node) { this._require('string', node); node.type = 'number'; return node; } String concatenation is more complicated because an 'add' node should result in concatenation if a string value is involved and in addition if two numbers are involved: // [ 'add' expr expr ] add (node) { const a = this.visit(node[1]), b = this.visit(node[2]); if (a.type != 'string') { if (b.type != 'string') return super.add(node); // any any this._toType('string', node, 1); // any string } else if (b.type != 'string') this._toType('string', node, 2); // string any node[0] = 'concat'; // string string node.type = 'string'; return node; } }; add() overrides Check_Number.add(), i.e., the mix-in Check_String() has to be applied after the mix-in Check_Number(). add() visits both subtrees (line 3 above) and if neither has a string value it defers to super.add() to handle a number result (line 5). Otherwise, the first or second operand might have to be converted into a string value (line 6 or line 8). Finally, the operation is changed to 'concat' (line 9) and the node is marked to produce a string value as result (line 10). The mix-in Check_Cast() only has to deal with a 'cast' node: // mix-in to check a cast operation const Check_Cast = superclass =&gt; class extends superclass { // [ 'cast' type expr ] cast (node) { this.visit(node[2]); node.type = node[1]; return node; } }; The subtree has to be visited but the node is marked with the explicit type (line 6 above) — silently assuming that any kind of conversion is supported. Checking a Typed Little Language Example 11/08 implements type checking for the little language introduced in example 11/05. Variables have to be declared, assignments and input statements have to respect the types, print statements require strings, conditions should return Boolean values, and expressions include the Boolean, string, and cast operations introduced in example 11/06. The grammars of the previous examples are merged and there is a small change at the top level to handle declarations: run: main; main: block; block: item [{ ';' item }]; item: dcl | stmt; dcl: type Name [{ ',' Name }]; type: 'bool' | 'number' | 'string'; The main action will return type checking as a function which the action for run will execute. A sentence consists of one or more items, separated by semicolons (line 3 above). An item is a declaration or a statement (line 4). A declaration starts with one of the types (line 6) followed by one or more variable names, separated by commas (line 5). A block is not permitted at the statement level, i.e., in the body of a loop or selection, but this would be the obvious hook to add block structure as described in chapter seven. The grammar permits declarations and statements in any order, i.e., variables can be used before they are declared, but the block() action will build a node which puts things in order, declarations before statements: // mix-in with building for 'block' and 'dcl' const Build_Dcl = superclass =&gt; class extends superclass { // block: item [{ ';' item }]; block (item, many) { const items = (many ? many[0] : []).reduce( (items, alt) =&gt; { items.push(alt[1][0]); return items; }, [ item[0] ]); return this._lineno([ 'block' ].concat( items.filter(item =&gt; item[0] == 'dcl'), items.filter(item =&gt; item[0] != 'dcl'))); } // dcl: type Name [{ ',' Name }]; dcl (type, name, many) { return this._lineno([ 'dcl', type, name ]. concat(many ? many[0].map(alt =&gt; alt[1]) : [])); } }; The block() action collects all items into one list (line 5 above). There is no action for item, i.e., the item rule will return a list with a single declaration or statement node which block() has to extract (line 6). The list of all items is then split into declarations (line 8) and statements (line 9) and both are combined into a 'block' node (line 7) because concat() flattens one level of arrays. The dcl() action builds a 'dcl' node with the declared type and the list of names (line 13). There is not much to do to check 'block' and 'dcl' nodes: // mix-in with type checking for 'block' and 'dcl' const Check_Dcl = superclass =&gt; class extends superclass { // [ 'block' dcl... stmt... ] block (node) { node.slice(1).forEach((item, n) =&gt; node[n + 1] = this.visit(item)); return node; } // [ 'dcl' type name ... ] dcl (node) { node.slice(2).forEach(name =&gt; { if (this.symbols.has(name)) this._error(node.lineno, name + ': duplicate'); this._alloc(name).type = node[1]; }); return node; } }; The block() method visits each subtree (line 5 above), i.e., it executes declarations before it checks statements. The dcl() method needs a symbols Map, e.g., from the Symbols mix-in. It forbids that a name has already been declared (line 11) and creates a description with a type property (line 13). Most statements require little checking and they have no useful node type upon return: // mix-in with type checking for statements const Check_Stmts = superclass =&gt; class extends superclass { // [ 'stmts' stmt... ] stmts (node) { node.slice(1).forEach(stmt =&gt; this.visit(stmt)); return node; } // [ 'print' expr ... ] print (node) { return this._require('string', node); } // [ 'loop' expr body ] loop (node) { this.visit(node[2]); return this._toType('bool', node, 1); } // [ 'select' expr then else? ] loop (node) { this.visit(node[2]); return this._toType('bool', node, 1); } /** `[ 'select' cond then else? ]` condition cast to `bool`. @param {Array} node - to check. @memberof module:Eleven~Check_Stmts @instance */ select (node) { node.slice(2).forEach(node =&gt; this.visit(node)); return this._toType('bool', node, 1); } }; The stmts() method visits each subtree (line 5 above). The print() method uses _require() to ensure that all arguments are strings (line 8). The loop() method visits both subtrees and uses _toType() to ensure that the loop condition returns a Boolean value (line 12). The select() method visits all subtrees and uses _toType() to ensure that the condition returns a Boolean value (line 17). Checking the use of variables is more complicated. Just like dcl() the methods in Check_Names() require a symbols Map: // mix-in with type checking for names const Check_Names = superclass =&gt; class extends superclass { // [ 'name' name ] name (node) { node.type = this._type(node.lineno, node[1]); return node; } // return the type of a name, or 'number' _type (lineno, name) { const symbol = this._alloc(name); if (!('type' in symbol)) { this._error(lineno, name + ': undefined'); symbol.type = 'number'; } return symbol.type; } // [ 'assign' name expr ] assign (node) { return this._toType(this._type(node.lineno, node[1]), node, 2); } }; The name() method sets the node type to the declared type of the variable (line 5 above). It uses _type() to obtain the type from the symbol table (line 9). The type should have been declared! The assign() method uses _toType() to visit the expression subtree and ensure that the expression delivers the type which is expected by the variable — this information is delivered by _type(). The defines the new mix-ins discussed above and uses Main() to create the builder and type checker: (() =&gt; { // define and immediately use an anonymous function // mix-ins with building actions ... // mix-ins with methods for type checking ... // builder and checker for a typed little language return Eleven.Main(Build_Dcl( Eleven.Build_Stmts( Eleven.Build_Names( Eleven.Build_Cast( Eleven.Build_String( Eleven.Build_Bool( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build)))))))), Check_Dcl( Check_Stmts( Check_Names( Eleven.Symbols( Eleven.Check_Cast( Eleven.Check_String( Eleven.Check_Bool( Eleven.Check_Cmps( Eleven.Check_Number(Eleven.Check)))))))))); }) () Example 11/08 contains a (rather contrived) typed version of Euclid's Algorithm: x = input 'x' '36'; y = input 'y' '54'; string x; number y; eq = x = y; bool eq; while not eq do if (number) x &gt; y then x = x - y else y = y - x fi; eq = x = y od; print 'Greatest common divisor:', x The very first button should show . If not, click it until it does. Remove the run and main rules, press to represent and check the grammar, and press to see the original tree. [ 'block' [ 'dcl' 'string' 'x' ] [ 'dcl' 'number' 'y' ] [ 'dcl' 'bool' 'eq' ] [ 'assign' 'x' [ 'input' 'x' '36' ] ] [ 'assign' 'y' [ 'input' 'y' '54' ] ] [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'name' 'y' ] ] ] [ 'loop' [ 'not' [ 'name' 'eq' ] ] [ 'stmts' [ 'select' [ 'gt' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ] [ 'assign' 'x' [ 'subtract' [ 'name' 'x' ] [ 'name' 'y' ] ] ] [ 'assign' 'y' [ 'subtract' [ 'name' 'y' ] [ 'name' 'x' ] ] ] ] [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'name' 'y' ] ] ] ] ] [ 'print' [ 'string' 'Greatest common divisor:' ] [ 'name' 'x' ] ] ] Note that the block action has sorted the declarations before the statements. Restore the rules, press to represent and check the grammar, and press to see the tree after it was modified by the type checker: [ 'block' [ 'dcl' 'string' 'x' ] [ 'dcl' 'number' 'y' ] [ 'dcl' 'bool' 'eq' ] [ 'assign' 'x' [ 'input' 'x' '36' ] ] [ 'assign' 'y' [ 'cast' 'number' [ 'input' 'y' '54' ] ] ] [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'cast' 'string' [ 'name' 'y' ] ] ] ] [ 'loop' [ 'not' [ 'name' 'eq' ] ] [ 'stmts' [ 'select' [ 'gt' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ] [ 'assign' 'x' [ 'cast' 'string' [ 'subtract' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ] ] ] [ 'assign' 'y' [ 'subtract' [ 'name' 'y' ] [ 'cast' 'number' [ 'name' 'x' ] ] ] ] ] [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'cast' 'string' [ 'name' 'y' ] ] ] ] ] ] [ 'print' [ 'string' 'Greatest common divisor:' ] [ 'name' 'x' ] ] ] Remove or duplicate a declaration to see error messages from type checking. Change the variables' types to see how that changes what casts are inserted. Interpreting a Typed Little Language Example 11/09 adds the necessary methods to interpret the typed version of the little language. The creates the new interpreter and uses Main() to create a new main action which will return the interpreter as a function: (() =&gt; { // define and immediately use an anonymous function // mix-in for blocks and declarations ... // builder, checker, and interpreter for a typed little language return Eleven.Main(Eleven.Build_Dcl( Eleven.Build_Stmts( Eleven.Build_Names( Eleven.Build_Cast( Eleven.Build_String( Eleven.Build_Bool( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build)))))))), Eleven.Check_Dcl( Eleven.Check_Stmts( Eleven.Check_Names( Eleven.Symbols( Eleven.Check_Cast( Eleven.Check_String( Eleven.Check_Bool( Eleven.Check_Cmps( Eleven.Check_Number(Eleven.Check))))))))), Eval_Dcl( Eleven.Eval_Stmts( Eleven.Eval_Names( Eleven.Symbols( Eleven.Eval_Cast( Eleven.Eval_String( Eleven.Eval_Bool( Eleven.Eval_Cmps( Eleven.Eval_Number(Eleven.Visit)))))))))); }) () Most of the interpreter was developed in example 11/05 above. Type checking adds 'block' and 'dcl' nodes. Therefore, just two visitor methods have to be added to the interpreter: // mix-in to interpret 'block' and 'dcl' const Eval_Dcl = superclass =&gt; class extends superclass { // [ 'block' dcl ... stmt ... ] block (node) { node.slice(1).forEach(item =&gt; this.visit(item)); } // [ 'dcl' type name ... ] dcl (node) { node.slice(2).forEach(name =&gt; { if (this.symbols.has(name) &amp;&amp; 'value' in this.symbols.get(name)) this._error(node.lineno, name + ': duplicate'); switch (node[1]) { case 'bool': this._alloc(name).value = false; break; case 'number': this._alloc(name).value = 0; break; case 'string': this._alloc(name).value = ''; break; default: this._error(node.lineno, node[1] + \": not in 'dcl'\"); } }); } The block() method simply visits the subtrees, i.e., the declarations followed by the statements (line 4 above). The dcl() method initializes the variables. The test for duplicates (line 8) should not be necessary because the interpreter uses the symbol table which was created by the type checker, i.e., duplicate variables would have been detected before and Main() does not continue from one visitor to the next if errors are reported. Variables are initialized to \"zero\", but the value is type-specific (line 10). In example 11/09 the very first button should show . If not, click it until it does. Press to represent and check the grammar, press to create the executable, and press to interpret the program. &amp;&amp; 'value' in this.symbols.get(name) Remove the phrase above from the body of the dcl method and press and again to see three error messages because x, y, and eq are already in the symbol table. This demonstrates that the symbol table is copied from the type checker. bool b; print b Change the program to the one shown above and check and interpret it. The output should be false. Remove the body of the dcl method and check and interpret again. The output is 0 because there is no initialization, the reference to a name defaults a missing value to zero, and the cast to a string for printing uses String() which in JavaScript converts anything to a string. Generating Code Code generation for a stack machine using action methods was introduced starting in chapter six with examples 6/09 and 6/10 for arithmetic expressions and example 6/11 for control structures. If a program is represented as a tree code generators are visitors which can apply some code optimization. The stack machines can be reused and extended with new instructions, e.g., for exponentiation or to operate on strings and Boolean values. Compiling Arithmetic Expressions Example 11/10 implements code generation for trees of arithmetic expressions which include exponentiation. Code is the base class for code generators. It extends Visit and manages stack machines. In particular, it reuses machine generators such as Six.Machine10 and it implements an extension mechanism to add instructions: class Code extends Visit { // machine generator class, allows replacement get Machine () { return this.#Machine ??= Six.Machine10; } #Machine; // instructions mix-in, allows extensions get Instructions () { return this.#Instructions ??= superclass =&gt; superclass; } #Instructions; // machine generator, should not change get machine () { return this.#machine ??= new (this.Instructions(this.Machine)) (); } #machine; // for 'compile' rule, overwrite to match machine generator get executable () { return this.machine.run(0); } // visit subtrees, generate 'op' instruction, returns end address _postfix (node, op) { node.slice(1).forEach(node =&gt; this.visit(node)); return this.machine.gen(op); } } The stack machine generators in chapter six and chapter seven form a linear inheritance hierarchy and define the machine instructions. Code defines getters as hooks which can be overwritten in mix-ins to change which machine generator class will be used (line 3 above), to add new instructions in a cumulative fashion (line 6), and to access the executable as befits the underlying machine generator (line 16). The private method _postfix() generates code for many operators. Given a node, the subtrees are visited to generate code to push values onto the runtime stack and then an instruction corresponding to the node is generated to operate on the values (lines 19 and 20). The mix-in Code_Number() extends the Instructions() mix-in to add a Power instruction (lines 3 to 11 below) and it contains the methods to visit the trees built for arithmetic expressions: const Code_Number = superclass =&gt; class extends superclass { // overwrite instructions mix-in, add 'Power' get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a b -&gt; ... a**b` */ Power (memory) { memory.splice(-2, 2, memory.at(-2) ** memory.at(-1)); } }; } #Instructions; ... // [ 'power' a b ] power (node) { return this._postfix(node, 'Power'); } // [ 'minus' a ] minus (node) { return this._postfix(node, 'Minus'); } // [ 'number' n ] number (node) { if (typeof node[1] != 'number') this._error(node.lineno, \"'number' non-number\"); return this.machine.gen('Push', node[1]); } }; For nodes like 'power' or 'minus' _postfix() visits the subtrees from left to right for code generation and then generates the instruction required for the node (lines 15 and 17 above). For a 'number' node 'Push' is generated to load a constant onto the runtime stack (line 22). Finally, the mix-in Compile() works exactly like the mix-in Main() discussed above: const Compile = (superclass, ...args) =&gt; class extends superclass { // compile: expr; compile (tree) { const [lastVisitor, lastTree, trace] = this._doVisits(tree, args); lastVisitor.visit(lastTree, trace); if (trace) puts(lastVisitor.machine.toString()); return lastVisitor.executable; } }; It defines a build action for a compile rule which expects a tree, runs a list of visitors such as type checking and code generation, and returns the executable from the last visitor. The contains the compiler for arithmetic expressions: (() =&gt; { // define and immediately use an anonymous function // mix-in to run the visitors const Compile ... // base class to generate code class Code ... // mix-in to generate code for arithmetic expressions const Code_Number ... // builder and code generator for arithmetic expressions return Compile( Eleven.Main(Eleven.Build_Number(Eleven.Build)), Code_Number(Code)); }) () Main() is needed in the inheritance chain of mix-ins to supply _doVisits() which does the actual work for the compile() build action. The construction still supports dump and run rules to display the tree and immediately run the executable returned by compile(). The grammar for this example starts with: compile: expr; expr: add | subtract | multiply | divide | power | minus | '(' expr ')' | number; The precedence table, expr, and the remaining rules are unchanged from from example 11/02. In example 11/10 the very first button should show . If not, click it until it does. Press to represent and check the grammar, press to create the executable, and press to execute the generated code. Insert dump between the compile and expr rules to display the expression tree. Add a regular expression such as /./ to the call to Compile() to trace code generation, i.e., display the successive last addresses and then dump code memory. Add run as the start rule to immediately execute the generated code: &gt; run = g.parser().parse(program, actions) [ 'subtract' [ 'add' [ 'number' 1 ].1 ... [ 'number' ].1 returns 1 [ 'number' ].1 returns 2 ... [ 'subtract' ] returns 20 0: memory =&gt; this.Push(1)(memory) 1: memory =&gt; this.Push(2)(memory) ... 19: memory =&gt; this.Subtract(memory) [ -10 ] Compiling a Little Language Example 11/11 extends code generation to comparisons, variables, constrol structures, and a few other statements. It reuses the grammar and build actions from example 11/04. The contains the compiler for a little language: (() =&gt; { // define and immediately use an anonymous function // mix-in to generate stack machine code for comparisons const Code_Cmps = ... // mix-in to generate stack machine code for names const Code_Names = ... // mix-in to generate stack machine code for statements const Code_Stmts = ... // builder and code generator for a little language return Eleven.Compile( Eleven.Main(Eleven.Build_Stmts( Eleven.Build_Names( Eleven.Symbols( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build)))))), Code_Stmts( Code_Names( Code_Cmps( Eleven.Symbols( Eleven.Code_Number(Eleven.Code)))))); }) () Code generation for comparisons is implemented using _postfix(): const Code_Cmps = superclass =&gt; class extends superclass { // [ 'eq' a b ] eq (node) { return this._postfix(node, 'Eq'); } ... The necessary instructions were implemented in Six.Machine11 which the mix-in Code_Cmps() has to request: // [override] use Six.Machine11 get Machine () { return this.#Machine ??= Six.Machine11; } #Machine; This stack machine generator significantly redefines run(), therefore, access to the executable has to be overwritten: // [override] size memory, check for 'trace' variable get executable () { const trace = this.symbols.get('trace'); return this.machine.run(this.symbols.size, 0, trace ? trace.ord - 1 : false); } }; As a consequence, Code_Cmps() silently assumes that the mix-in Symbols() has been included. The mix-in Code_Names() implements code generation for name references: const Code_Names = superclass =&gt; class extends superclass { // [ 'name' name ] name (node) { return this.machine.gen('Load', this._alloc(node[1]).ord - 1); } // [ 'assign' name value ] assign (node) { this.visit(node[2]); this.machine.gen('Store', this._alloc(node[1]).ord - 1); return this.machine.gen('Pop'); } }; The instructions Load, Store, and Pop were implemented in Six.Machine11 and variable addresses are managed by _alloc() which is part of the mix-in Symbols(). Generating optimized code for statements is a bit more interesting. First, the mix-in Code_Stmts() adds a Bnzero instruction which pops the runtime stack and branches if the popped value was non-zero (lines 7 to 9 below). const Code_Stmts = superclass =&gt; class extends superclass { // [ extend ] add 'Bnzero' to optimize 'while' loops get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... bool -&gt; ... | pc: bool? a` */ Bnzero (a) { return memory =&gt; { if (memory.pop()) memory.pc = a; } } }; } #Instructions; Referring to super.Instructions ensures that the Power instruction defined by Code_Number() remains available (line 5 above). Code generation itself deals with 'stmts', 'print', 'select', and 'loop' nodes: // [ 'stmts' stmt ... ] stmts (node) { return node.slice(1).reduce((end, stmt) =&gt; this.visit(stmt), 0); } // [ 'print' value ... ] print (node) { node.slice(1).forEach(value =&gt; this.visit(value)); return this.machine.gen('Print', node.length - 1); } stmts() visits each subtree in turn to generate code for each statement (line 3 above). Like all of code generation it returns the end address of the generated code. print() visits each subtree in turn to generate code to push all values onto the runtime stack (line 7) and then generates a Print instruction (line 8) which will print the values together and remove them from the stack. // [ 'select' expr stmt stmt? ] select (node) { const a = this.visit(node[1]); // cond this.machine.code.push(null); // a: Bzero b let b = this.visit(node[2]), end = b; // then if (node.length &gt; 3) { // b:end: this.machine.code.push(null); // Branch end end = this.visit(node[3]); // b: else // end: this.machine.code[b ++] = this.machine.ins('Branch', end); } this.machine.code[a] = this.machine.ins('Bzero', b); // fixup return end; } select() visits the first subtree to generate code for the condition of an if statement (line 3 above), leaves room for a conditional branch (line 4), and visits the second subtree to generate code for the then part (line 5). If there is no else part there is only one repair: the conditional branch has to bypass the then part (line 12). Otherwise there has to be room for an unconditional branch (line 7) followed by the code for the else part generated by a visit to the third subtree (line 8). In this case there are two repairs: the conditional branch has to reach the else part (line 10) and the unconditional branch has to bypass the else part (line 12). Either way, select() returns the next code address (line 13). The comments above indicate with symbolic labels such as a:, b:, etc., how convenient this is to generate the branch instructions for control structures. select() generates the same code as example 6/11 but the tree representation collects branch address management into a single method rather than having to distribute it over a number of rules and actions. // [ 'loop' expr stmt ] loop (node) { const a = this.machine.code.push(null) - 1, // a: Branch b b = this.visit(node[2]); // a+1: stmt this.visit(node[1]); // b: cond this.machine.code[a] = this.machine.ins('Branch', b); // fixup return this.machine.gen('Bnzero', a + 1); // Bnzero a+1 } }; The tree representation makes it possible for loop() to generate code for the loop body (line 4 above) ahead of the code for the condition (line 5). An unconditional Branch instruction is inserted before the loop body (line 6) and is executed just once to initially transfer control to the condition. The conditional Bnzero instruction follows the condition (line 7) and transfers control each time back to the loop body. If the condition is false initially it takes two branch instruction cycles (rather than one in example 6/11) to bypass the loop, but once the loop takes place almost half the branch instruction cycles are saved! In example 11/11 the very first button should show . If not, click it until it does. Press to represent and check the grammar, press to create the executable for Euclid's algorithm: trace = -1; input x, y; while x &lt;&gt; y do if x &gt; y then trace = 1; x = x - y; trace = -1 else y = y - x fi od; print x Add a regular expression such as /./ to the call to Compile() to trace code generation, i.e., display the successive last addresses and then dump code memory. Check out the loop optimization: ... 10: memory =&gt; this.Branch(33)(memory) 11: memory =&gt; this.Load(1)(memory) // if x &gt; y 12: memory =&gt; this.Load(2)(memory) 13: memory =&gt; this.Gt(memory) 14: memory =&gt; this.Bzero(28)(memory) ... then ... 27: memory =&gt; this.Branch(33)(memory) ... else ... 33: memory =&gt; this.Load(1)(memory) // while x &lt;&gt; y 34: memory =&gt; this.Load(2)(memory) 35: memory =&gt; this.Ne(memory) 36: memory =&gt; this.Bnzero(11)(memory) ... Compiling a Typed Little Language Example 11/12 reuses the grammar, tree building actions, and type checker from example 11/08 and extends stack machine and code generation from example 11/11 to produce the last compiler in this book. The contains the compiler for a typed little language: (() =&gt; { // define and immediately use an anonymous function // additional mix-ins to generate code for Boolean expressions ... // builder, type checker, and code generator for a typed little language return Eleven.Compile(Eleven.Main(Eleven.Build_Dcl( Eleven.Build_Stmts( Eleven.Build_Names( Eleven.Symbols( Eleven.Build_Cast( Eleven.Build_String( Eleven.Build_Bool( Eleven.Build_Cmps( Eleven.Build_Number(Eleven.Build)))))))))), Eleven.Check_Dcl( Eleven.Check_Stmts( Eleven.Check_Names( Eleven.Symbols( Eleven.Check_Cast( Eleven.Check_String( Eleven.Check_Bool( Eleven.Check_Cmps( Eleven.Check_Number(Eleven.Check))))))))), Code_Dcl( Eleven.Code_Stmts( Eleven.Code_Names( Code_Cast( Code_String( Code_Bool( Eleven.Code_Cmps( Eleven.Symbols( Eleven.Code_Number(Eleven.Code)))))))))); }) () The binary Boolean operations are a bit tricky: short-circuit evaluation turns them into something akin to control structures but they still have to push a value onto the runtime stack: const Code_Bool = superclass =&gt; class extends superclass { // [ 'or' a b ] or (node) { this.visit(node[1]); // push a const x = this.machine.code.push(null) - 1; // x: IfTrue y this.machine.gen('Pop'); // pop a const y = this.visit(node[2]); // push b // y: this.machine.code[x] = this.machine.ins('IfTrue', y); // fixup return y; } or() generates code to evaluate the left operand (line 4 above) and leaves room for a branch instruction (line 5). If the left operand leaves false on top of the runtime stack, this value has to be removed (line 6) and there has to be code to evaluate the right operand (line 7) which will leave the ultimate result of the or operation on the stack. Therefore, the branch instructions IfTrue and IfFalse should check the value on the stack but not remove it: // [extend] add short-circuit branches and 'Not' get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... bool -&gt; ... bool | pc: bool? a` */ IfTrue (a) { return memory =&gt; { if (memory.at(-1)) memory.pc = a; }; } /** `stack: ... bool -&gt; ... bool | pc: !bool? a` */ IfFalse (a) { return memory =&gt; { if (!memory.at(-1)) memory.pc = a; }; } /** `stack: ... a -&gt; ... !a` */ Not (memory) { memory.splice(-1, 1, !memory.at(-1)); } }; } #Instructions; and() follows the same pattern as or() but uses IfFalse instead: // [ 'and' a b ] and (node) { this.visit(node[1]); // push a const x = this.machine.code.push(null) - 1; // x: IfFalse y this.machine.gen('Pop'); // pop a const y = this.visit(node[2]); // push b // y: this.machine.code[x] = this.machine.ins('IfFalse', y); // fixup return y; } The comments again illustrate the advantage of generating control structure code in a single method for a tree node. // [ 'not' a ] not (node) { return this._postfix(node, 'Not'); } not() uses _postfix() to generate code to push a Boolean value onto the stack and generates Not to complement it. // [ 'bool' a ] bool (node) { if (typeof node[1] != 'boolean') throw `[ 'bool' ${node[1]} ]: not boolean`; return this.machine.gen('Push', node[1]); } }; Finally, bool() has a Boolean literal in the node and generates Push to push it onto the runtime stack. The rest of the additional code generation for the typed little language follows the usual pattern. cast() visits the value subtree to generate code to push the value onto the stack (line 4 below) and generates a Cast instruction: const Code_Cast = superclass =&gt; class extends superclass { // [ 'cast' type b ] cast (node) { this.visit(node[2]); return this.machine.gen('Cast', `'${node[1]}'`, `'${node[2].type}'`); } // [extend] add 'Cast' instruction get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a -&gt; ... cast a` */ Cast (to, from) { let cast; switch (to + '-' + from) { case 'bool-number': cast = x =&gt; !!x; break; case 'bool-string': cast = x =&gt; /^\\s*true\\s*$/i.test(x); break; case 'number-bool': case 'number-string': cast = Number; break; case 'string-bool': case 'string-number': cast = String; break; default: throw `Cast ${to} ${from}: illegal cast`; } return memory =&gt; memory.splice(-1, 1, cast(memory.at(-1))); } }; } #Instructions; }; The Cast instruction is added to the stack machine generator as usual (lines 8 to 28 above). It selects one of several functions — based on on JavaScript conversions — depending on the combination of to and from types (lines 13 to 20) and creates an instruction which applies the selected function to the top of the runtime stack (line 24). The implementation verifies that the function is only applied to a value of the intended JavaScript type (line 21). Code generation for string nodes again uses _postfix() but there have to be new machine instructions: const Code_String = superclass =&gt; class extends superclass { // [ 'concat' value value ] concat (node) { return this._postfix(node, 'Concat'); } // [ 'len' value ] len (node) { return this._postfix(node, 'Len'); } // [ 'string' literal ] string (node) { if (typeof node[1] != 'string') throw `[ 'string' ${node[1]} ]: not string`; return this.machine.gen('Push', this._escape(node[1])); } // [ 'input' prompt? default? ] input (node) { return this.machine.gen('InputString', this._escape(node[1] ?? \"''\"), this._escape(node[2] ?? \"''\")); } // [extend] add 'InputString', 'Len', and 'Concat' instructions get Instructions () { return this.#Instructions ??= superclass =&gt; class extends super.Instructions(superclass) { /** `stack: ... a b -&gt; ... a+b` */ Concat (memory) { memory.splice(-2, 2, memory.at(-2) + memory.at(-1)); } /** `stack: ... a -&gt; ... a.length` */ Len (memory) { memory.splice(-1, 1, memory.at(-1).length); } /** `stack: ... -&gt; ... val` */ InputString (prmpt, dflt) { return memory =&gt; memory.push(prompt(prmpt, dflt)); } }; } #Instructions; concat() and len() call _postfix() to generate code (lines 3 and 5 above) using the new instructions Concat (line 22) and Len (line 26). It is assumed that a string requires just one memory slot, just like a number. Therefore, string() can use Push to push a string constant onto the runtime stack (line 10). Finally, input() generates an InputString instruction (line 14) which is implemented using prompt() (line 30). There is one glitch, however. The method gen() was introduced in chapter six. It uses eval() so that the instructions can be displayed with meaningful names and argument values. Therefore, string arguments have to be escaped before they are handed to eval(). Assuming that backslash is only needed to escape backslashes, single quotes, and newlines, this can be handled by replace(): _escape (s) { return `'${s.replace(/['\\n\\\\]/g, '\\\\$&amp;')}'`; } A more comprehensive method would be Tuple.escape(). The stack machine's memory contains the variable values and the runtime stack. JavaScript will distinguish numbers and Boolean values for a trace or a memory dump. However, here too, string values need to be escaped: get Machine () { const escape = this._escape.bind(this); return this.#Machine ??= class extends super.Machine { /** Show strings in memory. */ get Memory () { return this.#Memory ??= class extends super.Memory { toString () { return '[ ' + this.map( v =&gt; typeof v == 'string' ? escape(v) : v ).join(' ') + ' ]'; } }; } #Memory; }; } #Machine; }; Memory is defined as a subclass of Array and toString() needs to be replaced (line 7 to 11 above). The actual work can be handled by _escape(); however, _escape() is a method in a mix-in and cannot be static because there is no class name. It can be used as a function with bind() (line 2). Finally, the mix-in Code_Dcl handles 'block' and 'dcl' nodes and requires no new instructions: const Code_Dcl = superclass =&gt; class extends superclass { // [ 'block' dcl ... stmt ... ] block (node) { return node.slice(1).reduce((end, node) =&gt; this.visit(node), 0); } // [ 'dcl' type name ... ] dcl (node) { return node.slice(2).reduce((end, name) =&gt; { const addr = this._alloc(name).ord - 1; switch (node[1]) { case 'number': return this.machine.code.length; case 'bool': this.machine.gen('Push', false); break; case 'string': this.machine.gen('Push', \"''\"); break; } this.machine.gen('Store', addr); return this.machine.gen('Pop'); }, 0); } }; Just as in the type checker, block() visits each subtree in turn, declarations before statements (line 4 above). dcl() assumes that there is a symbol table and calls _alloc() for each name (line 9). This will allocate a memory slot for new names if there is no type checking. Memory is initialized to zero, but variables of other types are initialized to false and empty strings, respectively (lines 12 and 13). In example 11/12 the very first button should show . If not, click it until it does. Press to represent and check the grammar, press to create the executable for the typed version of Euclid's algorithm used before, and press to run the program. The execution output shows how zero-filled memory is allocated for the string variable x, the number variable y, and the bool variable eq, and how the variables x and eq are initialized to values of proper type: &gt; memory = run(null, 100) [ 0 0 0 ] [ 0 0 0 '' ] 0: memory =&gt; this.Push('')(memory) [ '' 0 0 '' ] 1: memory =&gt; this.Store(0)(memory) [ '' 0 0 ] 2: memory =&gt; this.Pop(memory) [ '' 0 0 false ] 3: memory =&gt; this.Push(false)(memory) [ '' 0 false false ] 4: memory =&gt; this.Store(2)(memory) [ '' 0 false ] 5: memory =&gt; this.Pop(memory) [ '' 0 false '36' ] 6: memory =&gt; this.InputString('x', '36')(memory) [ '36' 0 false '36' ] 7: memory =&gt; this.Store(0)(memory) [ '36' 0 false ] 8: memory =&gt; this.Pop(memory) ... [ '18' 18 true 'Greatest common divisor:' ] 48: memory =&gt; this.Push('Greatest common divisor:')(memory) [ '18' 18 true 'Greatest common divisor:' '18' ] 49: memory =&gt; this.Load(0)(memory) Greatest common divisor: 18 [ '18' 18 true ] 50: memory =&gt; this.Print(2)(memory) [ '18' 18 true ] From that point on until the end of execution the types of the variables' memory cells don't change anymore. And More... In example 11/12 the nonsensical program if not trace or false then print 'ok' fi; bool trace is compiled into 0: memory =&gt; this.Push(false)(memory) // bool trace = false 1: memory =&gt; this.Store(0)(memory) 2: memory =&gt; this.Pop(memory) 3: memory =&gt; this.Load(0)(memory) // if not trace 4: memory =&gt; this.Not(memory) 5: memory =&gt; this.IfTrue(8)(memory) // or 6: memory =&gt; this.Pop(memory) 7: memory =&gt; this.Push(false)(memory) // false 8: memory =&gt; this.Bzero(11)(memory) 9: memory =&gt; this.Push('ok')(memory) // then print 'ok 10: memory =&gt; this.Print(1)(memory) and produces the expected ok. However, the code could be optimized: the IfTrue branch at address 5 should not end up at the Bzero branch at address 8, it should directly branch into then at address 9. More generally, if short-circuit evaluations are at the top level of a control structure their branches should be integrated into the control structure. An intermediate representation such as tagged nested lists has many advantages. Code can be optimized by moving parts of the program — e.g., the condition of loop. Branching around nested function can be avoided. Type checking, interpretation, and code generation can be reused by targeting an existing intermediate representation from a new grammar. It is all about the separation of concerns: the frontend uses a grammar to deal with recognition, the intermediate language is convenient for the visitor pattern and different processing steps such as type checking, interpretation, optimization, and code generation can be implemented as separate visitors. Quick Summary One-pass compilation uses the semantic actions executed when rules are reduced to immediately perform type checking and interpretation or code generation, all in the same action. Alternatively, there can be an intermediate representation of the recognized input, designed to be easy to create in the actions and to process in separate passes for type checking, memory allocation, interpretation, code generation, optimization, etc. In JavaScript, trees created from nested lists with leading, unique string tags are easy to create because they match grammar and program structure and they are easy to modify in place. The tags can be dispatched to methods of visitor classes which facilitates separation of concerns, i.e., a divide and conquer approach, and is very similar in spirit to the way semantic actions are selected by rules. Dispatching tags to methods creates a loose but precise coupling, i.e., it is easy to replace an implementation, e.g., to replace an interpreter by a code generator, retarget a code generator, or map a language to a processor. Singleton objects are very useful to provide a common context, e.g., access to a table of symbol descriptions, for visits to different nodes in a tree. Classes can be extended to add or replace functionality; however, overridden methods are not deleted even if they remain unused. Mix-ins are a way to add methods to classes, e.g., to package support for subsets of nodes, and they can be selectively added. In JavaScript, one way to implement a mix-in is as a function which extends a class — creating an anonymous subclass. In this case, the new methods close over the function parameters, i.e., different invocations of the mix-in can create different methods. The technique can lead to a set of building blocks for compilers; however, creating a flexible and comprehensive architecture is still a challenge. Previous: 10. Recognition Revisited × Search results Close "},"tutorial-a-webpage.html":{"id":"tutorial-a-webpage.html","title":"Tutorial: A: The Practice Page","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit A: The Practice Page The Model Scripting and Buttons Explained Execution of the examples in this book is implemented as a model which represents the state of an example and manipulates it, e.g., by using the parser generators or executing a function produced by action methods. The model can be controlled by scripting with a Node.js program or through the graphical interface in the Practice Page. Scripting script.js is a Node.js module which reads command words from standard input, separated by white space, and applies them to a current Model. As such the code of this script illustrates how the EBNF and BNF modules are used as parser generators. For example $ node script.js &lt;&lt; 'end' model eg/02/11.eg new parse stack new parse ebnf tests/02-11a.eg new parse stack new parse end creates a Model, loads the initial texts from an example file, represents and checks the grammar and performs syntax analysis first with the LL(1) generator implemented by EBNF and next with the SLR(1) generator implemented by BNF, overwrites some texts using a different file, and performs syntax analysis with each generator again. The command words have the following effects: word effect model resets all flags and variables load resets global strings ebnf, stack, and bnf clear all flags and select a parser generator ebnf clears all flags and selects the LL(1) generator greedy toggles a flag to use the expect() rather than check() algorithm shallow, deep, and follow toggle flags to trace the corresponding algorithms lookahead, parser, and actions toggle flags to trace the corresponding operations noargs toggles a flag to suppress argument count checking for actions stack clears all flags and selects the SLR(1) generator using translation from EBNF error toggles a flag to insert $error when translating from EBNF sets and states toggle flags to add information to the grammar description bnf clears all flags and selects the SLR(1) generator using strict BNF build toggles a flag to create lists when parsing with the SLR(1) generator new represents and checks the grammar scan performs lexical analysis on the program parse performs syntax analysis on the program, calling actions if any run runs the executable, if any 1, 10, and 100 execute a number of instructions in a stack machine, if any exit terminates the script Any other word is interpreted as a path to a file from which to load texts. In the file each text is preceded by %% and one of the names actions, grammar, output, program, or tokens, enclosed in white space, to overwrite the corresponding global string. Graphical User Interface The Practice Page contains resizable text areas which contain grammar rules in the , token definitions as object properties defined in JavaScript in the , optionally a class or an object with action methods defined in JavaScript in the , program text in the , and output from the model. The page also contains buttons which are functionally equivalent to most of the scripting command words described above. Each text area can be resized by dragging the bottom right corner, and all but the output area can be maximized relative to the others by clicking on the label near the top right of an area; shift-click restores the original layout. An alt-, meta-, or command-click on the label of a non-empty text area opens a pop-up window containing the text, with syntax highlighting by Sunlight for the tokens and actions areas. Text in the output area at the bottom can be selected and copied. All other text areas can be edited and their content is available in global variables for programming. Button states are reflected in their background color, where white indicates that a condition is not set or that a function cannot be executed yet. Buttons are inactive while a text area has focus. The state of the very first button and the color of all buttons indicates which grammar notation and parser are used: button state implementation parsing technique grammar notation EBNF recursive descent LL(1) EBNF BNF stack-based SLR(1) EBNF BNF stack-based SLR(1) strict BNF The label at the top right of each text area indicates which global string the text area corresponds to. If a stored example is loaded, the button near the top right of the output area connects to this book, near the first reference to the example. Otherwise the button connects to this appendix. The remaining buttons have the following effects: button effect if set, configures new grammar creation to not use the check() algorithm, i.e., to suppress checking for ambiguity; the recursive descent parser will be greedy if set, configures new grammar creation to trace the shallow() algorithm and display the resulting sets if set, configures new grammar creation to trace the deep() algorithm and display the resulting sets if set, configures new grammar creation to trace the follow() algorithm and display the resulting sets if set, configures new grammar creation to insert $error alternatives when translating braces to BNF; likely to cause shift/reduce conflicts (which are usually benign) if set, displays the lookahead sets when a BNF grammar is processed if set, displays the states when a BNF grammar is processed represents and checks a Grammar and assigns it to g; all but white space in the is significant applies the scanner created from g, if any, to program; output is a list of tuples if set, traces scanner progress during parsing if set, traces parsing program if set, traces calls to actions, if any, while parsing program if set, suppresses argument count checking for actions while parsing program if set, adds an observer to collect input into lists when parsing with a BNF grammar applies the parser created from g, if any, to program; output can contain nested lists of terminals or results of actions; a function will be assigned to run executes run, if any, and displays the result , , and execute and trace a number of instructions in the stack machine, if any Globals Constructing a Model creates some global variables which operations on the Model will affect. A question mark after a type below indicates that the global will not be overwritten if it already exists. name type content actions string defines the class and action methods to be called by a parser g Grammar represents grammar if not null grammar string rules of a grammar, argument for the construction of g newOutput function? displays it's arguments, blank-separated and marked as a new section program string should be a sentence conforming to grammar, argument for recognition prompt function? displays a prompt string, returns input or a default string, else error puts function? displays it's arguments, blank-separated run function null or an executable compiled from program by the actions;a stack machine has two arguments, other executables have none tokens string defines an object with pattern properties defining the tokens used in grammar and compiled into g. A property with an empty key overwrites white space as text to be skipped in both, grammar and program The parser generator modules and the modules with classes from the examples are also available through global variables. tokens are evaluated when grammar is processed by a parser generator. actions are evaluated and used, if available, when a program is parsed. Errors are reported to the output area. Malicious content should be avoided... Examples and Local Storage Many examples are available and can be loaded into the Practice Page using a search string, e.g., from the following list: search string example explained ?eg=interpret interpret arithmetic expressions with numbers. ?eg=compile compile arithmetic expressions into functions. ?eg=postfix compile arithmetic expressions into postfix. ?eg=stack compile arithmetic expressions for a stack machine. ?eg=little compile a little language for a stack machine. ?eg=little_fn compile a little language into functions. ?eg=typing compile a typed little language for a stack machine. ?eg=recursion compile mutually recursive functions. ?eg=functions compile functions with parameters and local variables. ?eg=scopes compile block scopes. ?eg=nesting compile nested functions. ?eg=first_glob compile global first-order functions. ?eg=fn_parameter compile nested functions as parameters. ?eg=first compile first-order functions. ?eg=curry currying. ?eg=compose function composition. ?eg=bootstrap compile the EBNF parser generator. ?eg=extend extend EBNF notation. With an eg= parameter the search string can select any file with an extension .eg in the folder eg and subfolders, relative to the page. If the search fails the Practice Page is reset and contains brief hints as to the use of the different text areas. Additionally, the search string can contain a mode= parameter with the values ebnf, stack, or bnf corresponding to the command words described above. If possible, the current state of the text areas is saved in local storage with the key EBNF/state once the practice page loses visibility. This state is normally reloaded once the practice page is visible again. It is destroyed if the search string is invalid. Stored examples and local storage use the file format described above. A Note on eval() The Practice Page critically depends on the use of eval() and thus can fail if destructive text is entered into the text areas. tokens and actions are compiled with eval?.(). Interestingly, the executable run is not — because it is created by the compiled actions. The rules for specifying grammar could be changed to require that tokens be specified as part of the grammar specification, e.g., as assignments of pattern strings to token names before or after the grammar rules. This would eliminate the need for the . However the action methods themselves have to be compiled from the text in the before they can be called during parsing. Once they are compiled with eval?.() — just before parsing — they can be called during parsing to create any kind of JavaScript data. This, specifically, includes functions. The executable run is the result of the actions during parsing and as such is a function created by the actions, i.e., it needs no further compilation. × Search results Close "},"tutorial-b-machine.html":{"id":"tutorial-b-machine.html","title":"Tutorial: B: The Stack Machine","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit B: The Stack Machine Memory Architecture Instructions The Stack Machine uses JavaScript functions to simulate machine instructions. Beginning with Machine10 the machine classes generate and store the instructions in an array code[] which is considered immutable once filled. To simplify visual inspection of code[], the instructions are implemented through methods of the machine classes. Methods for simple instructions such as Add directly use memory as an argument, i.e., they are instruction functions. Other methods such as Branch require a memory address, etc., as arguments and return the actual instruction functions. All of the instruction functions manipulate memory in some way. There are two interpreters which call the instruction functions: The stack machine uses one JavaScript array memory for frames and the value stack. The garbage-collected stack machine uses memory for global information followed by the value stack, and individually allocated arrays for the frames. These arrays have a property .id with a unique value for tracing; .id is initialized from memory.id. To enable single step execution the interpreters return memory with a property .continue indicating if the program is suspended (true) or has terminated (false). Example 6/10: Arithmetic Expressions memory use 0 ... values of global variables size ... value stack Six.Machine10 Add (memory) // stack: ... a b -&gt; ... a+b Divide (memory) // stack: ... a b -&gt; ... a/b Input (dflt) // stack: ... -&gt; ... input Load (addr) // stack: ... -&gt; ... memory[addr] Minus (memory) // stack: ... a -&gt; ... -a Multiply (memory) // stack: ... a b -&gt; ... a*b Pop (memory) // stack: ... val -&gt; ... Push (result) // stack: ... -&gt; ... result Puts (memory) // stack: ... val -&gt; ... | puts(val) Store (a) // stack: ... val -&gt; ... val | memory[a]: val Subtract (memory) // stack: ... a b -&gt; ... a-b Example 6/11: Control Structures memory use .pc register next address in code to execute 0 ... values of global variables size ... value stack Six.Machine11 extends Six.Machine10 Branch (a) // stack: ... -&gt; ... | pc: a Bzero (a) // stack: ... bool -&gt; ... | pc: !bool? a Eq (memory) // stack: ... a b -&gt; ... a == b Ge (memory) // stack: ... a b -&gt; ... a &gt;= b Gt (memory) // stack: ... a b -&gt; ... a &gt; b Le (memory) // stack: ... a b -&gt; ... a &lt;= b Lt (memory) // stack: ... a b -&gt; ... a &lt; b Ne (memory) // stack: ... a b -&gt; ... a != b Print (n) // stack: ... n*val -&gt; ... Example 7/04: Functions memory use .pc register next address in code to execute 0 ... values of global variables frame +0 result value of function call +1 return address in code for function call ... stack Seven.Machine04 extends Six.Machine11 // stack: ... -&gt; ... old-pc | pc: addr Call (addr) // stack: ... old-pc -&gt; ,,, 0 old-pc Entry (memory) // stack: ... old-pc -&gt; ... | pc: old-pc Return (memory) // stack: ... x old-pc result -&gt; ... result old-pc result ReturnValue (memory) Example 7/06: Local Variables memory use .pc register next address in code to execute .fp register base address of current frame in memory 0 ... values of global variables frame +0 ... argument values for the parameters +parms return address in code for function call +parms+1 dynamic link, i.e., address in memory of previous frame +parms+2 result value of function call +parms+3 ... values of local variables ... stack Seven.Machine06 extends Seven.Machine04 // stack: ... arguments old-pc // -&gt; ... arguments old-pc old-fp result locals Entry (parms, size) // stack: ... arguments old-pc old-fp result locals // -&gt; ... result old-pc Exit (parms) // stack: ... -&gt; ... frame[addr] LoadFP (addr) // stack: ... val -&gt; ... val | frame[addr]: val StoreFP (addr) Example 7/13: Nested Functions memory use .pc register next address in code to execute .fp register base address of current frame in memory .dp register base address of current display in memory 0 ... values of global variables frame +0 ... values of parameter arguments +parms return address in code for function call +parms+1 address in memory of previous frame +parms+2 address in memory of previous display +parms+3 result value of function call — memory.dp points here +parms+3+1 ... base addresses of visible frames +parms+3+depth base address of this frame — at depth +parms+4+depth ... values of local variables ... stack Seven.Machine13 extends Seven.Machine06 // stack: ... arguments old-pc // -&gt; ... arguments old-pc old-fp old-dp result display locals Entry (parms, depth, size) // stack: ... arguments old-pc old-fp old-dp result display locals // -&gt; ... result old-pc Exit (memory) // stack: ... -&gt; ... frame[depth][addr] LoadDP (addr, depth) // stack: ... val -&gt; ... val | frame[depth][addr]: val StoreDP (addr, depth) Example 8/01: Global first-order Functions Same memory layout as Local Variables above. mix-in Eight.Machine01() // stack: ... addr -&gt; ... old-pc | pc: addr` CallValue (memory) // stack: ... x-len n*val -&gt; ... n*val x-len` Rotate (n, len = 1) Example 8/08: Functions as Argument Values Same memory layout as Nested Functions above. This machine requires two slots to represent a function value: display pointer followed by function start address. This does not affect the Call, CallValue, and Return instructions. mix-in Eight.Machine08() // stack: ... arguments dp old-pc // -&gt; ... arguments old-pc old-fp old-dp result display locals` Entry (args, depth, vars) // stack: ... arguments old-pc old-fp old-dp result display locals // -&gt; ... result old-pc` Exit (args) // stack: ... -&gt; ... dp` PushDP (memory) Example 8/14: Nested first-order Functions This machine manages frames dynamically: frames are separate arrays subject to JavaScript's garbage collection. This machine requires two slots to represent a function value: frame pointer followed by function start address. This does not affect the Call, CallValue, and Return instructions. memory use .pc register next address in code to execute .fp register null or Array of current frame 0 ... values of global variables ... stack frame use 0 return address in code for function call 1 null or Array of previous frame 1+1 ... arrays of visible frames 1+depth Array of this frame (at depth) 2+depth result value of function call 3+depth extra slot, exactly if result value is function value ... argument values ... frame size-1 local variable values mix-in Eight.Machine14() // stack: ... arguments fp old-pc // -&gt; ... | frame: old-pc old-fp display result arguments locals` Entry (args, depth, result, vars) // stack: ... | frame: old-pc old-fp display result ... // -&gt; ... result old-pc | fp: old-fp | frame unchanged` Exit (depth, result) // stack: ... -&gt; ... frame[depth][addr]` LoadGC (addr, depth) // stack: ... -&gt; ... fp` PushFP (memory) // stack: ... val -&gt; ... val | frame[depth][addr]: val` StoreGC (addr, depth) Example 11/10: Compiling Arithmetic Expressions This mix-in for code generation extends Six.Machine10 with a Power instruction to support exponentiation. mix-in Eleven.Code_Number() Power (memory) // stack: ... a b -&gt; ... a**b Example 11/11: Compiling a Little Language This mix-in for code generation extends Six.Machine11 with a Bnzero instruction to optimize code generation for while loops. It requires Eleven.Symbols. mix-in Eleven.Code_Stmts() Bnzero (a) // stack: ... bool -&gt; ... | pc: bool? a Example 11/12: Compiling a Typed Little Language These mix-ins for code generation extend Six.Machine11 with instructions to support code generation for Boolean and string values and conversions. mix-in Eleven.Code_Bool() IfTrue (a) // stack: ... bool -&gt; ... bool | pc: bool? a IfFalse (a) // stack: ... bool -&gt; ... bool | pc: !bool? a Not (memory) // stack: ... a -&gt; ... !a mix-in Eleven.Code_String() Concat (memory) // stack: ... a b -&gt; ... a+b Len (memory) // stack: ... a -&gt; ... a.length InputString ('prompt', 'default') // stack: ... -&gt; ... string mix-in Eleven.Code_Cast() Cast ('to', 'from') // stack: ... a -&gt; ... cast a × Search results Close "},"tutorial-c-compilers.html":{"id":"tutorial-c-compilers.html","title":"Tutorial: C: The One-Pass Compilers","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit C: The One-Pass Compilers The Method Browser Rules and Actions Symbol Table Appendix B summarized the different versions of the stack machine. This appendix contains tables which index the stack machine compilers for the little language developed in chapters six, seven, and eight. The table entries are linked to the examples, to the documentation, and from there to the sources. These compilers generate code during recognition, i.e., in the action methods. The action classes extend from example 6/10 (Arithmetic10) to example 6/11 (Control11), 7/4 (Functions04), 7/6 (Parameters06), and 7/9 (Blocks09). To implement nested functions example 7/13 defines the mix-in Nest13 to extend Blocks09 and support function definitions at greater depth — which requires a static link. To implement global first-order functions example 8/1 defines the mix-in Global01 to extend Blocks09 and primarily support type checking with function types for variables, functions, parameters, and argument values. To implement nested functions as argument values example 8/8 defines the mix-in Pass08 to extend Blocks09 and Nest13; the language forbids using functions and results or variables with function values. Finally, to implement nested first-order functions, example 8/14 defines the mix-in First14 to extend the implementation in example 8/1 and support dynamic memory management for frames. The Method Browser The method browser can be used to study the evolution of the action classes and methods and, in particular, to see where a method is first defined. By default it will load the sources of the implementation of the little language in chapters six through eight, but file parameters can be used in a search string to load JavaScript files from the modules directory. Patterns are used to extract module, class or mix-in, and method names, and the source text of the methods. The patterns assume a particular coding style, mostly based on white space and nesting. The names are displayed in a table with columns for modules, classes or mix-ins, methods, and nested methods. Names can be selected by clicking in each column. Multiple selections within a column are considered alternatives, selections across columns must all be satisfied. A column without selections is a wildcard. Selected names have a darker blue background, names that could be added to a selection have a lighter blue background. Each column can be scrolled vertically. If the mouse hovers over a column (indicated by a focus border) a keypress will scroll to names with the corresponding initial and the delete key will clear all selections in the column. A combination of names selects methods which can be displayed, sorted alphabetically by method name, or by class or mix-in. A single method is displayed as soon as it is selected. An initial selection can be defined by specifying one or more module, item, method, and op parameters in a search string for the page. A show parameter requests immediate display of the selection. op refers to nested methods, i.e., methods within classes which are nested into top-level classes, e.g., the classes which are used to represent types, variables, and functions in the implementation of the little language. The nested methods are also located by patterns based on coding style. Grammar Rules and Actions This table shows how the grammar rules and actions are defined or overridden. Numbers reference the example where a rule was used and ⊕ references action method definitions or overrides. rules list: stmt [{ ';' stmt }]; 6/10 prog: stmts; 6/11 ⊕ prog: [ vars ] funs; 7/4 ⊕ 7/6 7/9 7/13 prog: [ typedcls ] [ vars ] funs; 8/1 ⊕ 8/8 8/14 typedcls: { 'type' typedcl [{ ',' typedcl }] ';' }; 8/1 ⊕ 8/8 8/14 typedcl: Name '(' [ types ] ')' [ ':' typename ]; 8/1 ⊕ 8/14 typedcl: Name '(' [ types ] ')' [ ':' number' ]; 8/1 ⊕ 8/8 types: typename [{ ',' typename }]; 8/1 ⊕ 8/8 8/14 typename: Name | 'number'; 8/1 ⊕ 8/8 8/14 vars: 'var' names ';'; 7/4 7/6 7/9 7/13 vars: 'var' varname [{ ',' varname }] ';'; 8/1 8/8 8/14 varname: Name [ ':' type ]; 8/1 ⊕ 8/14 ⊕ varname: Name; 8/8 type: Name | 'number'; 8/1 ⊕ 8/14 names: Name [{ ',' Name }]; 7/4 ⊕ 7/6 7/9 7/13 8/1 8/8 8/14 funs: { fun }; 7/4 7/6 7/9 7/13 8/1 8/8 8/14 fun: head [ 'begin' stmts 'end' ] ';'; 7/4 ⊕ fun: head parms [ block ] ';'; 7/6 ⊕ 7/9 7/13 8/1 8/8 8/14 head: 'function' Name; 7/4 ⊕ 7/6 7/9 7/13 ⊕ 8/1 8/8 8/14 parms: '(' [ names ] ')'; 7/6 ⊕ 7/9 7/13 parms: '(' [ names ] ')' [ ':' Name ]; 8/1 ⊕ 8/8 8/14 block: 'begin' [ vars ] stmts 'end'; 7/6 block: begin [ vars ] stmts 'end'; 7/9 ⊕ 8/1 block: begin body 'end'; 7/13 ⊕ 8/8 8/14 begin: 'begin'; 7/9 ⊕ 7/13 8/1 8/8 8/14 body: [ vars ] [ funs ] stmts; 7/13 stmts: stmt [{ ';' stmt }]; 6/11 7/4 7/6 7/9 7/13 8/1 8/8 8/14 stmt: sum; 6/10 ⊕ stmt: assign | print | loop | select; 6/11 ⊕ stmt: assign | print | return | loop | select; 7/4 7/6 stmt: assign | print | return | block | loop | select; 7/9 7/13 8/1 8/8 8/14 assign: Name '=' sum; 6/11 ⊕ assign: Name [ '=' sum ]; 7/4 ⊕ assign: symbol action; 7/6 ⊕ 7/9 7/13 8/1 8/8 8/14 action: store | call; 7/6 7/9 7/13 8/1 8/8 8/14 store: '=' sum; 7/6 ⊕ 7/9 7/13 8/1 ⊕ 8/8 8/14 ⊕ call: args; 7/6 7/9 7/13 8/8 call: { args }; 8/1 8/14 ⊕ args: '(' [ sums ] ')'; 7/6 ⊕ 7/9 7/13 8/1 ⊕ 8/8 8/14 print: 'print' sums; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 sums: sum [{ ',' sum }]; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 return: 'return' [ sum ]; 7/4 ⊕ 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 ⊕ loop: While cmp Do stmts 'od'; 6/11 ⊕ 7/4 7/6 loop: While cmp Do [ vars ] stmts 'od'; 7/9 ⊕ 8/1 loop: While cmp Do body 'od'; 7/13 ⊕ 8/8 8/14 While: 'while'; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 8/8 8/14 Do: 'do'; 6/11 ⊕ 7/4 7/6 7/9 ⊕ 7/13 8/1 8/8 8/14 select: 'if' cmp Then stmts [ Else stmts ] 'fi'; 6/11 ⊕ 7/4 7/6 select: 'if' cmp then [ else ] 'fi'; 7/9 ⊕ 7/13 8/1 8/8 8/14 then: Then [ [ vars ] stmts ]; 7/9 ⊕ 8/1 then: Then [ body ]; 7/13 8/8 8/14 else: Else [ vars ] stmts ; 7/9 ⊕ 8/1 else: Else body ; 7/13 ⊕ 8/8 8/14 Then: 'then'; 6/11 ⊕ 7/4 7/6 7/9 ⊕ 7/13 8/1 8/8 8/14 Else: 'else'; 6/11 ⊕ 7/4 7/6 7/9 ⊕ 7/13 8/1 8/8 8/14 cmp: sum rel; 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 rel: eq | ne | gt | ge | lt | le; 6/11 7/4 7/6 7/9 7/13 8/1 8/8 8/14 eq: '=' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 ne: '&lt;&gt;' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 gt: '&gt;' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 ge: '&gt;=' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 lt: '&lt;' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 le: '&lt;=' sum; 6/11 ⊕ 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 sum: 'let' Name '=' sum | product [{ add | subtract }]; 6/10 ⊕ sum: product [{ add | subtract }]; 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 add: '+' product; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 subtract: '-' product; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 product: signed [{ multiply | divide }]; 6/10 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 multiply: '*' signed; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 divide: '/' signed; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 signed: [ '-' ] term; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 term: input | number | name | '(' sum ')'; 6/10 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 input: 'input' [ Number ]; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 number: Number; 6/10 ⊕ 6/11 7/4 7/6 7/9 7/13 8/1 ⊕ 8/8 8/14 name: Name; 6/10 ⊕ 6/11 7/4 ⊕ name: symbol [ args ]; 7/6 ⊕ 7/9 7/13 8/8 name: symbol [{ args }]; 8/1 ⊕ 8/14 symbol: Name; 7/6 ⊕ 7/9 7/13 8/1 8/8 8/14 Symbol Table Entries Symbol table entries have a common base class Symbol which ensures that every symbol has a name and can reference the owner, i.e., the action class which defines the symbol's class; therefore, the symbol classes are inner classes of an action class as the owner. Getters in the action classes are used to access the symbol classes because getters can be overwritten in subclasses to silently return extended symbol classes. It should be noted, however, that a reference to a getter can be confused with a reference to a method with the same name, i.e., given the class definition class X { get x () { /* ... */ } x () { /* ... */ } } the reference (new X()).x is ambiguous; e.g., the Node.js JavaScript compiler will return the method function and not note an error. property Symbol usage .owner 7/4 outer class' object .name 7/4 symbol's name Variables Variable descriptions have a common base class Var which is extended by the various action classes. The table links the properties of the descriptions to the classes and examples where they are defined or overridden. () indicates a method. + indicates that an override references super. property Var Var Var Var Var Var usage .addr 7/4 memory address or offset .depth 7/6 7/13 (static) level .type 8/1 variable's type .load() 7/4 7/6 7/13 8/8 8/14 generates Load* .storeOk() 7/4 8/1 +8/8 true unless store() is in error .store() 7/4 7/6 7/13 8/14 generates Store* .call() 8/1 generates Call* .toString() 7/4 7/6 7/13 +8/1 text representation Functions Function descriptions have a common base class Fun which is extended by the various action classes. The table links the properties of the descriptions to the classes and examples where they are defined or overridden. [] indicates that a property is a list. () indicates a method. + indicates that an override references super. property Fun Fun Fun Fun Fun Fun Fun usage .start 7/4 false or code address .calls[] 7/4 slots for Call* .returns[] 7/4 slots for Branch exit .parms 7/6 number of parameters .addr 7/6 result value offset .locals get/set 7/6 7/9 maps local names to descriptions .size get/set 7/6 7/9 next address in frame .blocks[] 7/9 .locals/.size stack .frameSize 7/9 frame size .depth 7/13 (static) level .scope 7/13 block containing definition .type 8/1 function's type .loads[] 8/1 slots for Push* .entry() 7/4 7/6 +7/13 sets start, reserves Entry .undo() 7/4 +7/6 undoes entry() .setParms() 7/6 +7/13 8/1 8/8 8/14 sets .parms .addr, types .call() 7/4 +8/8 +8/14 generates Call* .return() 7/4 generates Branch exit .storeOk() 7/4 7/13 +8/1 true unless store() is in error .store() 7/4 7/6 7/13 8/14 generates Store* result, types .load() 8/1 +8/8 +8/14 generates Push* .push() 7/9 pushes .blocks[] .pop() 7/9 +7/13 pops .blocks[], sets frame size .end() 7/4 +7/9 +8/1 fixes forward references, exit() .exit() 7/4 7/6 7/9 7/13 8/8 8/14 generates Entry, Exit, Return .toString() 7/4 7/6 7/9 +7/13 +8/1 text representation Blocks A Block represents a scope of names to support block structure. property Block usage .locals 7/9 maps names in scope to descriptions .size 7/9 next address in scope .toString() 7/9 text representation .bypass 7/13 address of branch bypassing functions Types There is just one type description class Type and there is a separate, global symbol table typeSymbols for types to allow matching of functions and types on their names. Two type values have reserved names: number describes number values and, for convenience, main describes a function without arguments which returns a number. property Type usage .parms[] 8/1 null or list of parameter types .returns 8/1 null or result type .isFun 8/1 true if function type .toString() 8/1 text representation × Search results Close "},"tutorial-d-kit.html":{"id":"tutorial-d-kit.html","title":"Tutorial: D: The Compiler Kit","body":" EBNF Modules BNFBaseEBNFEightElevenFiveGUIPracticeScriptSevenSixTen Classes BNF~ActionsBNF~GrammarBNF~LitBNF~MarkBNF~MessageBNF~NTBNF~ParserBNF~RuleBNF~StateBNF~TokenBase~FactoryBase~LitBase~NTBase~ParserBase~PrecedenceBase~ScannerBase~SymbolBase~TBase~TokenBase~TupleEBNF~ActionsEBNF~AltEBNF~GrammarEBNF~LitEBNF~NTEBNF~OptEBNF~ParserEBNF~RuleEBNF~SeqEBNF~SetEBNF~SomeEBNF~TokenEight~First14#FunEight~First14#VarEight~Global01#FunEight~Global01#TypeEight~Global01#VarEight~Machine14#MemoryEight~Pass08#FunEight~Pass08#VarEleven~BuildEleven~CheckEleven~CodeEleven~VisitFive~Actions14Five~Actions15Five~Actions16Practice~ModelSeven~Blocks09Seven~Blocks09#BlockSeven~Blocks09#FunSeven~Blocks09#SymbolSeven~Blocks09#VarSeven~Functions04Seven~Functions04#FunSeven~Functions04#SymbolSeven~Functions04#VarSeven~Machine04Seven~Machine04#MemorySeven~Machine06Seven~Machine06#MemorySeven~Machine13Seven~Machine13#MemorySeven~Nest13#FunSeven~Nest13#VarSeven~Parameters06Seven~Parameters06#FunSeven~Parameters06#SymbolSeven~Parameters06#VarSeven~TCheck01Seven~TCheck02Six~Arithmetic09Six~Arithmetic10Six~Control11Six~Eval02Six~Eval03Six~Eval04Six~Functions05Six~Functions06Six~Functions07Six~Functions12Six~Machine09Six~Machine10Six~Machine11Six~Machine11#MemorySix~Postfix08Ten~Actions07Ten~Actions09 Mixins BNF~TEBNF~NodeEight~First14Eight~Global01Eight~Machine01Eight~Machine08Eight~Machine14Eight~Pass08Eleven~Build_BoolEleven~Build_CastEleven~Build_CmpsEleven~Build_DclEleven~Build_NamesEleven~Build_NumberEleven~Build_RDEleven~Build_StmtsEleven~Build_StringEleven~Check_BoolEleven~Check_CastEleven~Check_CmpsEleven~Check_DclEleven~Check_NamesEleven~Check_NumberEleven~Check_StmtsEleven~Check_StringEleven~Code_BoolEleven~Code_CastEleven~Code_CmpsEleven~Code_DclEleven~Code_NamesEleven~Code_NumberEleven~Code_StmtsEleven~Code_StringEleven~CompileEleven~Eval_BoolEleven~Eval_CastEleven~Eval_CmpsEleven~Eval_DclEleven~Eval_NamesEleven~Eval_NumberEleven~Eval_StmtsEleven~Eval_StringEleven~MainEleven~SymbolsSeven~Nest13 The Book Overview1. Compiler Terminology2. Writing Grammars3. Scanning Input4. Recognizing Sentences5. Translating Sentences6. Compiling Little Languages7. Language Features8. Functions as Values9. Compiling Grammars10. Recognition Revisited11. Compiling RevisitedA: The Practice PageB: The Stack MachineC: The One-Pass CompilersD: The Compiler Kit D: The Compiler Kit Tree Builders Visitors This appendix contains tables which index the tree builders, interpreters, type checkers, and stack machine code generators for the little language developed in chapter eleven. The table entries are linked to the examples, to the documentation, and from there to the sources. All code is structured as mix-ins which are mostly independent of each other to be combined for different types of language processing. All classes and mix-ins are contained in module Eleven. The method browser described in appendix C can be used to compare the action methods for the tree builders and the processing methods in the visitors. Tree Builders Trees are built during recognition, i.e., in action methods. Tree builder mix-ins are applied to the base class Build which provides a small amount of infrastructure. Tree building employs an SLR(1) grammar with a precedence table which allows a symmetric definition of the operations in expressions. This table links the precedence levels to the builders and examples which require them: precedence builder mix-in used in %left 'or';%left 'and'; Build_Bool 06 07 08 09 12 %nonassoc '=' '&lt;&gt;' '&gt;' '&gt;=' '&lt;' '&lt;='; Build_Cmps 04 05 06 07 08 09 11 12 %left '+' '-';%left '*' '/';%right '**';%right Number; Build_Number 02 03 04 05 06 07 08 09 10 11 12 The following table links tree builder mix-ins to the examples which use them, lists their grammar rules and links them to the builder actions and from there to the sources, and specifies the resulting tree nodes or values. The table in the next section of this appendix relates the tree nodes to visitor mix-ins which can process them and to the examples which use the visitors. The Main mix-in supports a build rule main: tree; which applies a list of visitors, specified as mix-in arguments, to the tree and returns a function which will apply the last visitor. Convenience methods support build rules dump: tree; to dump a tree and run: function; to execute the function. The Compile mix-in supports a build rule compile: tree; which applies a list of visitors, specified as mix-in arguments, to the tree and returns the executable created by the last visitor which must be a code generator. Operations on names require a symbol table which is supported by the Symbols mix-in and forwarded from one visitor to the next. Compile, used in 10 11 12 action returns compile: tree; compile() (memory, steps) =&gt; StackMachine(memory, steps) Main, used in 03 05 06 07 08 09 10 11 12 action returns run: function; run() function's result main: tree; main() () =&gt; last visitor(tree) dump: tree; dump() tree Build_Dcl, used in 08 09 12 action returns block: item [{ ';' item }]; block() [ 'block' dcl ... stmt ... ] item: dcl | stmt; dcl: type Name [{ ',' Name }]; dcl() [ 'dcl' type Name ... ] Build_Stmts, used in 04 05 08 09 11 12 action returns stmts: stmt [{ ';' stmt }]; stmts() stmt | [ 'stmts' stmt ... ] stmt: print | ...; stmt() tree print: 'print' expr [{ ',' expr }]; print() [ 'print' expr ... ] loop: 'while' expr 'do' stmts 'od'; loop() [ 'loop' expr stmts ] select: 'if' expr 'then' stmts [ 'else' stmts ] 'fi'; select() [ 'if' expr stmts stmts? ] Build_Names, used in 04 05 08 09 11 12 action returns assign: Name '=' expr; assign() [ 'assign' Name expr ] name: Name; name() [ 'name' Name ] Build_Cast, used in 06 07 08 09 12 action returns type: 'bool' | 'number' | 'string'; type() typename cast: '(' type ')' expr %prec Number; cast() [ 'cast' type expr ] Build_String, used in 06 07 08 09 12 action returns input: 'input' [ String String ]; input() [ 'input' String? String? ] len: 'len' expr %prec Number; len() [ 'len' expr ] string: String; string() [ 'string' String ] Build_Bool, used in 06 07 08 09 12 action returns or: expr 'or' expr; or() [ 'or' expr expr ] and: expr 'and' expr; and() [ 'and' expr expr ] not: 'not' expr %prec Number; not() [ 'not' expr ] bool: 'true' | 'false'; bool() [ 'bool' Boolean ] Build_Cmps, used in 04 05 06 07 08 09 11 12 action returns eq: expr '=' expr; eq() [ 'eq' expr expr ] ne: expr '&lt;&gt;' expr; ne() [ 'ne' expr expr ] gt: expr '&gt;' expr; gt() [ 'gt' expr expr ] ge: expr '&gt;=' expr; ge() [ 'ge' expr expr ] lt: expr '&lt;' expr; lt() [ 'lt' expr expr ] le: expr '&lt;=' expr; le() [ 'le' expr expr ] Build_Number, used in 02 03 04 05 06 07 08 09 10 11 12 action returns expr: add | ... | '(' expr ')'; expr() tree add: expr '+' expr; add() [ 'add' expr expr ] subtract: expr '+' expr; subtract() [ 'subtract' expr expr ] multiply: expr '+' expr; multiply() [ 'multiply' expr expr ] divide: expr '+' expr; divide() [ 'divide' expr expr ] power: expr '+' expr; power() [ 'power' expr expr ] minus: '-' expr %prec Number; minus() [ 'minus' expr ] number: Number; number() [ 'number' Number ] Visitors The visitor pattern is useful to process trees. Module Eleven implements three kinds of visitors: Ⓔ Interpreters visit trees and evaluate the nodes — basically in postorder. Interpreter mix-ins are applied to the base class Visit which implements the visitor pattern and provides tracing. Ⓒ Type Checkers visit, annotate, and modify trees in place prior to interpretation or code generation. Type checker mix-ins are applied to the base class Check which extends Visit and implements convenience methods. Ⓖ Code generators visit trees, perhaps modified by type checking. Code generators use a stack machine generator ultimately based on Machine10 to generate code and create a stack machine executable. Code generator mix-ins are applied to the base class Code which extends Visit, implements convenience methods, and by default imports Machine10. Visiting names requires a symbol table which is supported by the Symbols mix-in and forwarded from one visitor to the next. The following table links visitor mix-ins to the examples which use them, lists their tree nodes and links them to the visitor methods and from there to the source code, and specifies the results. [ node ] method Eval_Dcl09returns Check_Dcl08 09 12sets .type Code_Dcl12generates 'block' dcl... stmt... block() Ⓔ undefined Ⓒ not set Ⓖ 'dcl' type Name ... dcl() Ⓔ undefined Ⓒ sets each Name Ⓖ Push Store Pop [ node ] method Eval_Stmts05 09 Check_Stmts08 09 12 Code_Stmts11 12 'stmts' stmt ... stmts() Ⓔ undefined Ⓒ not set Ⓖ 'print' value ... print() Ⓔ undefined Ⓒ not set Ⓖ Print 'loop' cond stmt loop() Ⓔ undefined Ⓒ not set Ⓖ Branch 'select' cond then else? select() Ⓔ undefined Ⓒ not set Ⓖ Branch [ node ] method Eval_Names05 09 Check_Names08 09 12 Code_Names11 12 'name' Name name() Ⓔ Name's value Ⓒ Name's type Ⓖ Load 'assign' Name value assign() Ⓔ undefined Ⓒ not set Ⓖ Store Pop [ node ] method Eval_Cast06 07 09 Check_Cast07 08 09 12 Code_Cast12 'cast' type expr cast() Ⓔ type'ed value Ⓒ type Ⓖ Cast [ node ] method Eval_String06 07 09 Check_String07 08 09 12 Code_String12 'input' prompt? default? input() Ⓔ String Ⓒ 'string' Ⓖ InputString 'concat' a b concat() Ⓔ String Ⓒ 'string' Ⓖ Concat 'len' a len() Ⓔ Number Ⓒ 'number' Ⓖ Len 'string' String string() Ⓔ String Ⓒ 'string' Ⓖ Push [ node ] method Eval_Bool06 07 09 Check_Bool07 08 09 12 Code_Bool12 'or' a b or() Ⓔ Boolean Ⓒ 'bool' Ⓖ IfTrue 'and' a b and() Ⓔ Boolean Ⓒ 'bool' Ⓖ IfFalse 'not' a not() Ⓔ Boolean Ⓒ 'bool' Ⓖ Not 'bool' Boolean bool() Ⓔ Boolean Ⓒ 'bool' Ⓖ Push [ node ] method Eval_Cmps05 06 07 09 Check_Cmps07 08 09 12 Code_Cmps11 12 'eq' a b eq() Ⓔ Boolean Ⓒ 'bool' Ⓖ Eq 'ne' a b ne() Ⓔ Boolean Ⓒ 'bool' Ⓖ Ne 'gt' a b gt() Ⓔ Boolean Ⓒ 'bool' Ⓖ Gt 'ge' a b ge() Ⓔ Boolean Ⓒ 'bool' Ⓖ Ge 'lt' a b lt() Ⓔ Boolean Ⓒ 'bool' Ⓖ Lt 'le' a b le() Ⓔ Boolean Ⓒ 'bool' Ⓖ Le [ node ] method Eval_Number03 05 06 07 09 Check_Number07 08 09 12 Code_Number10 11 12 'add' a b add() Ⓔ Number Ⓒ 'number' Ⓖ Add 'subtract' a b subtract() Ⓔ Number Ⓒ 'number' Ⓖ Subtract 'multiply' a b multiply() Ⓔ Number Ⓒ 'number' Ⓖ Multiply 'divide' a b divide() Ⓔ Number Ⓒ 'number' Ⓖ Divide 'minus' a minus() Ⓔ Number Ⓒ 'number' Ⓖ Minus 'number' n number() Ⓔ Number Ⓒ 'number' Ⓖ Push × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
