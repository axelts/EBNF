%% output
  Interpret a typed expression [see 7/03].
  
  Try simple expressions, for example: 1 + 2, '3' + 4, true + input '' '5', false * 6.
  
  To dump the tree, remove the 'run' rule and replace the 'main' rule by 'dump: expr;'.
  Add '/./' to the call to 'Main' to trace interpretation.
  
  Output:
    error: 'and' non-boolean
    '6true'
    
  Tree:
    [ 'and' 
      [ 'eq' [ 'string' '2 ' ].1 [ 'number' 2 ].1 ].1 
      [ 'add' 
        [ 'multiply' [ 'string' '2' ].2 [ 'len' [ 'string' '1\\3' ].2 ].2 ].2 
        [ 'cast' 'string' [ 'bool' true ] ] ] ]
%% program
'2 ' = 2 and 
  '2' * len '1\\3' +
    (string) true
%% grammar
  %left     'or';
  %left     'and';
  %nonassoc '=' '<>' '>' '>=' '<' '<=';
  %left     '+' '-';
  %left     '*' '/';
  %right    '**';
  %right    Number;

  run:      main;
  main:     expr;
  expr:     or | and | eq | ne | gt | ge | lt | le
            | add | subtract | multiply | divide | power
            | minus | not | len | cast | input
            | number | bool | string | '(' expr ')';
            
  or:       expr 'or' expr;
  and:      expr 'and' expr;
  eq:       expr '=' expr;
  ne:       expr '<>' expr;
  gt:       expr '>' expr;
  ge:       expr '>=' expr;
  lt:       expr '<' expr;
  le:       expr '<=' expr;
  
  add:      expr '+' expr;
  subtract: expr '-' expr;
  multiply: expr '*' expr;
  divide:   expr '/' expr;
  power:    expr '**' expr;
  minus:    '-' expr %prec Number;
  not:      'not' expr %prec Number;
  len:      'len' expr %prec Number;
  cast:     '(' type ')' expr %prec Number;
  type:     'bool' | 'number' | 'string';

  input:    'input' [ String String ];
  number:   Number;
  bool:     'true' | 'false';
  string:   String;
%% tokens
  { 
    Number: /0|[1-9][0-9]*/, 
    String: /'(?:\\['\\\n]|[^'\\\n])*'/
  }
%% actions
  (() => {  // define and immediately use an anonymous function
    // mix-in with Boolean expression building
    const Build_Bool = superclass => class extends superclass {
      // or: expr 'or' expr; returns [ 'or' a b ]
      or (a, x, b) { return this._lineno([ 'or', a, b ]); }
    
      // and: expr 'and' expr; returns [ 'and' a b ]
      and (a, x, b) { return this._lineno([ 'and', a, b ]); }
    
      // not: 'not' expr; returns [ 'not' b ]
      not (x, b) { return this._lineno([ 'not', b ]); }
    
      // bool: 'true' | 'false'; returns [ 'bool' bool ]
      bool (bool) { return this._lineno([ 'bool', bool == 'true' ]); }
    };

    // mix-in with string expression building
    const Build_String = superclass => class extends superclass {
      // input: 'input' [ String String ]; returns [ 'input' unescaped-string unescaped-string ]
      input (i, opt) {
        return (opt ? opt : [ ]).
          reduce((r, s) =>
            (r.push(s.slice(1, -1).replace(/\\(.)/g, '$1')), r),
          [ 'input' ]);
      }
    
      // len: 'len' expr; returns [ 'len' b ]
      len (x, b) { return this._lineno([ 'len', b ]); }
    
      // string: String; returns [ 'string' unescaped-string ]
      string (string) {
        return this._lineno([ 'string',
          string.slice(1, -1).replace(/\\(.)/g, '$1') ]);
      }
    };

    // mix-in with cast building
    const Build_Cast = superclass => class extends superclass {
      // type: 'bool' | 'number' | 'string'; returns type
      type (type) { return type; }
    
      // cast: '(' type ')' expr; returns [ 'cast' type b ]
      cast (l, type, r, b) { return this._lineno([ 'cast', type, b ]); }
    };

    // mix-in with Boolean expression evaluation
    const Eval_Bool = superclass => class extends superclass {
      // [ 'or' a b ] returns Boolean.
      or (node) {
        return node.slice(1).reduce((result, tree) => {
          if (result) return result;  // short-circuit
          result = this.visit(tree);
          if (typeof result != 'boolean')
            this._error(node.lineno, "'or' non-boolean");
          return result;
        }, false);
      }
    
      // [ 'and' a b ] returns Boolean.
      and (node) {
        return node.slice(1).reduce((result, tree) => {
          if (!result) return result;  // short-circuit
          result = this.visit(tree);
          if (typeof result != 'boolean')
            this._error(node.lineno, "'and' non-boolean");
          return result;
        }, true);
      }
    
      // [ 'not' b ] returns Boolean.
      not (node) {
        const result = this.visit(node[1]);
        if (typeof result != 'boolean')
          this._error(node.lineno, "'not' non-boolean");
        return !result;
      }
    
      // [ 'bool' value ] returns Boolean.
      bool (node) {
        if (typeof node[1] != 'boolean')
          this._error(node.lineno, "'bool' non-boolean");
        return node[1];
      }
    };

    // mix-in with string expression evaluation
    const Eval_String = superclass => class extends superclass {
      // [ 'concat' a b ] returns String.
      concat (node) {
        const vals = node.slice(1).map(this.visit.bind(this));
        if (vals.some(val => typeof val != 'string'))
          this._error(node.lineno, "'concat' non-string");
        return vals[0] + vals[1];
      }
    
      // [ 'input' prompt? default? ] returns String.
      input (node) {
        return prompt(node[1] ?? '', node[2] ?? '');
      }
    
      // [ 'len' b ] returns Number.
      len (node) {
        const val = this.visit(node[1]);
        if (typeof val != 'string')
          this._error(node.lineno, "'len' non-string");
        return val.length;  // undefined if not string
      }
    
      // [ 'string' value ] returns String.
      string (node) {
        if (typeof node[1] != 'string')
          this._error(node.lineno, "'string' non-string");
        return node[1];
      }
    };

    // mix-in with cast evaluation
    const Eval_Cast = superclass => class extends superclass {
      // [ 'cast' type b ] returns type-cast value.
      cast (node) {
        switch (node[1]) {
        case 'bool':   return !! this.visit(node[2]);
        case 'number': return Number(this.visit(node[2]));
        case 'string': return String(this.visit(node[2]));
        default:       throw node[1] + ': not expected for cast';
        }
      }
    };

    // builder and interpreter for typed expressions
    return Eleven.Main(Build_Cast(
                         Build_String(
                           Build_Bool(
                             Eleven.Build_Cmps(
                               Eleven.Build_Number(Eleven.Build))))),
                       Eval_Cast(
                         Eval_String(
                           Eval_Bool(
                             Eleven.Eval_Cmps(
                               Eleven.Eval_Number(Eleven.Visit))))));
  }) ()
