%% output
  Type-check and interpret a typed expression [see 11/06].

  Try simple expressions, for example: 1 + 2, '3' + 4, true + input '' '5', false * 6.
  
  Add '/./' to the call to 'Main' to trace checking,
  dump the modified tree, and trace interpretation.
  
  Tree:
    [ 'and' 
      [ 'eq' [ 'string' '2 ' ].1 [ 'number' 2 ].1 ].1 
      [ 'add' 
        [ 'multiply' 
          [ 'string' '2' ].2 
          [ 'len' [ 'string' '1\\3' ].2 ].2 ].2 
        [ 'cast' 'string' [ 'bool' true ] ] ] ]
  
  Checked Tree:
    [ 'and' 
      [ 'eq' 
        [ 'string' '2 ' ].1:string
        [ 'cast' 'string' [ 'number' 2 ].1:number ]:string ].1:bool
      [ 'cast' 'bool' 
        [ 'concat' 
          [ 'cast' 'string' 
            [ 'multiply' 
              [ 'cast' 'number' [ 'string' '2' ].2:string ]:number 
              [ 'len' [ 'string' '1\\3' ].2:string ].2:number ].2:number ]:string
          [ 'cast' 'string' [ 'bool' true ]:bool ]:string ]:string ]:bool ]:bool
  
  Output: false (string to string comparison)
%% program
'2 ' = 2 and 
  '2' * len '1\\3' +
    (string) true
%% grammar
  %left     'or';
  %left     'and';
  %nonassoc '=' '<>' '>' '>=' '<' '<=';
  %left     '+' '-';
  %left     '*' '/';
  %right    '**';
  %right    Number;

  run:      main;
  main:     expr;
  expr:     or | and | eq | ne | gt | ge | lt | le
            | add | subtract | multiply | divide | power
            | minus | not | len | cast | input
            | number | bool | string | '(' expr ')';
            
  or:       expr 'or' expr;
  and:      expr 'and' expr;
  eq:       expr '=' expr;
  ne:       expr '<>' expr;
  gt:       expr '>' expr;
  ge:       expr '>=' expr;
  lt:       expr '<' expr;
  le:       expr '<=' expr;
  
  add:      expr '+' expr;
  subtract: expr '-' expr;
  multiply: expr '*' expr;
  divide:   expr '/' expr;
  power:    expr '**' expr;
  minus:    '-' expr %prec Number;
  not:      'not' expr %prec Number;
  len:      'len' expr %prec Number;
  cast:     '(' type ')' expr %prec Number;
  type:     'bool' | 'number' | 'string';

  input:    'input' [ String String ];
  number:   Number;
  bool:     'true' | 'false';
  string:   String;
%% tokens
  { 
    Number: /0|[1-9][0-9]*/, 
    String: /'(?:\\['\\\n]|[^'\\\n])*'/
  }
%% actions
  (() => {  // define and immediately use an anonymous function
    // base class for type checking
    class Check extends Eleven.Visit {
      // Utility: accepts [ type value ], sets .type from tag, returns node.
      _literal (node) {
        if (!(typeof node[1]).startsWith(node[0]))
          this._error(node.lineno, `expected ${node[0]} literal`);
        node.type = node[0]; return node;
      }
    
      // Utility: visits and casts node[index] to type if needed, returns node.
      _toType (type, node, index) {
        if (this.visit(node[index]).type != type)
          (node[index] = [ 'cast', type, node[index] ]).type = type;
        return node;
      }
    
      // Utility: casts all operands to type if needed, sets .type, returns node.
      _require (type, node) {
        node.slice(1).forEach((_, n) => this._toType(type, node, n+1));
        node.type = type;
        return node;
      }
    }

    // mix-in to check arithmetic expressions
    const Check_Number = superclass => class extends superclass {
      // [ 'add' a b ] casts to number.
      add (node) { return this._require('number', node); }
    
      // [ 'subtract' a b ] casts to number.
      subtract (node) { return this._require('number', node); }
    
      // [ 'multiply' a b ] casts to number.
      multiply (node) { return this._require('number', node); }
    
      // [ 'divide' a b ] casts to number.
      divide (node) { return this._require('number', node); }
    
      // [ 'power' a b ] casts to number.
      power (node) { return this._require('number', node); }
    
      // [ 'minus' b ] casts to number.
      minus (node) { return this._require('number', node); }
    
      // [ 'number' value ] expects number value.
      number (node) { return this._literal(node); }
    };

    // mix-in to check comparisons
    const Check_Cmps = superclass => class extends superclass {
      // Casts right operand to left operand's type if needed.
      _cmp (node) {
        const type = this.visit(node[1]).type;
        this._toType(type, node, 2);
        node.type = 'bool';
        return node;
      }
    
      // [ 'eq' a b ]
      eq (node) { return this._cmp(node); }
      // [ 'ne' a b ]
      ne (node) { return this._cmp(node); }
    
      // [ 'gt' a b ]
      gt (node) { return this._cmp(node); }
    
      // [ 'ge' a b ]
      ge (node) { return this._cmp(node); }
    
      // [ 'lt' a b ]
      lt (node) { return this._cmp(node); }
    
      // [ 'le' a b ]
      le (node) { return this._cmp(node); }
    };

    // mix-in to check Boolean expressions
    const Check_Bool = superclass => class extends superclass {
      // [ 'or' a b ] casts to bool.
      or (node) { return this._require('bool', node); }
    
      // [ 'and' a b ] casts to bool.
      and (node) { return this._require('bool', node); }
    
      // [ 'not' b ] casts to bool.
      not (node) { return this._require('bool', node); }
    
      // [ 'bool' value ] expects boolean value.
      bool (node) { return this._literal(node); }
    };

    // mix-in to check string expressions
    const Check_String = superclass => class extends superclass {
      // [ 'input' prompt? default? ] returns node.string.
      input (node) {
        node.type = 'string'; return node;
      }
    
      // [ 'add' a b ] for at least one string casts to string and returns node as concat.string.
      add (node) {
        const a = this.visit(node[1]), b = this.visit(node[2]);
        if (a.type != 'string') {
          if (b.type != 'string') return super.add(node);   // any  any
          this._toType('string', node, 1);               // any  string
        } else if (b.type != 'string')
          this._toType('string', node, 2);                // string any
        node[0] = 'concat';                            // string string
        node.type = 'string'; return node;
      }
    
      // [ 'len' b ] casts to string and returns node.number.
      len (node) {
        this._require('string', node);
        node.type = 'number'; return node;
      }
    
      // [ 'string' value ] expects string value, returns  node.string.
      string (node) { return this._literal(node); }
    };

    // mix-in to check casts??
    const Check_Cast = superclass => class extends superclass {
      // [ 'cast' type b ] returns node.type.
      cast (node) {
        this.visit(node[2]);
        node.type = node[1]; return node;
      }
    };

    // builder, type-checker, and interpreter for typed expressions
    return Eleven.Main(Eleven.Build_Cast(
                         Eleven.Build_String(
                           Eleven.Build_Bool(
                             Eleven.Build_Cmps(
                               Eleven.Build_Number(Eleven.Build))))),
                       Check_Cast(
                         Check_String(
                           Check_Bool(
                             Check_Cmps(
                               Check_Number(Check))))),
                       Eleven.Eval_Cast(
                         Eleven.Eval_String(
                           Eleven.Eval_Bool(
                             Eleven.Eval_Cmps(
                               Eleven.Eval_Number(Eleven.Visit))))));
  }) ()
