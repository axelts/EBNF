%% output
  Check a typed little language.
  Euclid's Algorithm, see [7/02].
  
  Remove the 'run' and 'main' rules to see the original tree.
  Add '/./' to the call to 'Main' to trace checking.
  Remove one or more of the declarations in the 'program' to see how the casts change.
  Add a duplicate declaration or remove a declaration to see error messages.
  
  Original tree:
    [ 'block' [ 'dcl' 'string' 'x' ] [ 'dcl' 'number' 'y' ] [ 'dcl' 'bool' 'eq' ]
      [ 'assign' 'x' [ 'input' 'x' '36' ] ] 
      [ 'assign' 'y' [ 'input' 'y' '54' ] ] 
      [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'name' 'y' ] ] ] 
      [ 'loop' [ 'not' [ 'name' 'eq' ] ] [ 'stmts' 
        [ 'select' [ 'gt' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ] 
          [ 'assign' 'x' [ 'subtract' [ 'name' 'x' ] [ 'name' 'y' ] ] ] 
          [ 'assign' 'y' [ 'subtract' [ 'name' 'y' ] [ 'name' 'x' ] ] ] ] 
        [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'name' 'y' ] ] ] ] ] 
      [ 'print' [ 'string' 'Greatest common divisor:' ] [ 'name' 'x' ] ] ]

  Checked tree:
    [ 'block' [ 'dcl' 'string' 'x' ] [ 'dcl' 'number' 'y' ] [ 'dcl' 'bool' 'eq' ]
      [ 'assign' 'x' [ 'input' 'x' '36' ] ] 
      [ 'assign' 'y' [ 'cast' 'number' [ 'input' 'y' '54' ] ] ] 
      [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'cast' 'string' [ 'name' 'y' ] ] ] ] 
      [ 'loop' [ 'not' [ 'name' 'eq' ] ] [ 'stmts' 
        [ 'select' [ 'gt' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ]
          [ 'assign' 'x' [ 'cast' 'string' 
            [ 'subtract' [ 'cast' 'number' [ 'name' 'x' ] ] [ 'name' 'y' ] ] ] ] 
          [ 'assign' 'y' [ 'subtract' [ 'name' 'y' ] [ 'cast' 'number' [ 'name' 'x' ] ] ] ] ]
        [ 'assign' 'eq' [ 'eq' [ 'name' 'x' ] [ 'cast' 'string' [ 'name' 'y' ] ] ] ] ] ]
      [ 'print' [ 'string' 'Greatest common divisor:' ] [ 'name' 'x' ] ] ]
%% program
  x = input 'x' '36'; y = input 'y' '54'; string x; number y;
  eq = x = y; bool eq;
  while not eq do
    if (number) x > y then
      x = x - y
    else
      y = y - x 
    fi;
    eq = x = y
  od;
  print 'Greatest common divisor:', x
%% grammar
  %left     'or';
  %left     'and';
  %nonassoc '=' '<>' '>' '>=' '<' '<=';
  %left     '+' '-';
  %left     '*' '/';
  %right    '**';
  %right    Number;

  run:      main;
  main:     block;
  block:    item [{ ';' item }];
  item:     dcl | stmt;
  dcl:      type Name [{ ',' Name }];
    
  stmts:    stmt [{ ';' stmt }];
  stmt:     assign | print | loop | select;
  assign:   Name '=' expr;
  print:    'print' expr [{ ',' expr }];
  loop:     'while' expr 'do' stmts 'od';
  select:   'if' expr 'then' stmts [ 'else' stmts ] 'fi';

  expr:     or | and | eq | ne | gt | ge | lt | le
            | add | subtract | multiply | divide | power
            | minus | not | len | cast | input
            | number | name | bool | string | '(' expr ')';

  or:       expr 'or' expr;
  and:      expr 'and' expr;

  eq:       expr '=' expr;
  ne:       expr '<>' expr;
  gt:       expr '>' expr;
  ge:       expr '>=' expr;
  lt:       expr '<' expr;
  le:       expr '<=' expr;   

  add:      expr '+' expr;
  subtract: expr '-' expr;
  multiply: expr '*' expr;
  divide:   expr '/' expr;
  power:    expr '**' expr;

  minus:    '-' expr %prec Number;
  not:      'not' expr %prec Number;
  len:      'len' expr %prec Number;
  cast:     '(' type ')' expr %prec Number;
  type:     'bool' | 'number' | 'string';

  input:    'input' [ String String ];  
  number:   Number;
  name:     Name;
  bool:     'true' | 'false';
  string:   String;
%% tokens
  { 
    Number: /0|[1-9][0-9]*/, 
    Name:   /[a-z]+/,
    String: /'(?:\\['\\\n]|[^'\\\n])*'/
  }
%% actions
  (() => {  // define and immediately use an anonymous function
    // mix-in with building for 'block' and 'dcl'
    const Build_Dcl = superclass => class extends superclass {
      // block: item [{ ';' item }]; item: dcl | stmt; returns [ 'block' dcl... stmt... ]
      block (item, many) {
        const items = (many ? many[0] : []).reduce(
          (items, alt) => { items.push(alt[1][0]); return items; }, [ item[0] ]);
        return this._lineno([ 'block' ].concat(
          items.filter(item => item[0] == 'dcl'),
          items.filter(item => item[0] != 'dcl')));
      }
    
      // dcl: type Name [{ ',' Name }]; returns [ 'dcl' type name ... ]
      dcl (type, name, many) {
        return this._lineno([ 'dcl', type, name ].
          concat(many ? many[0].map(alt => alt[1]) : []));
      }
    };

    // mix-in with type checking for statements
    const Check_Stmts = superclass => class extends superclass {
      // [ 'stmts' stmt ... ] checks each stmt.
      stmts (node) {
        node.slice(1).forEach(stmt => this.visit(stmt)); return node;
      }
    
      // [ 'print' value ... ] values cast to string.
      print (node) { return this._require('string', node); }
    
      // [ 'loop' cond stmt ] condition cast to bool.
      loop (node) {
        this.visit(node[2]);
        return this._toType('bool', node, 1);
      }
      // [ 'select' cond then else? ] condition cast to bool.
      select (node) {
        node.slice(2).forEach(node => this.visit(node));
        return this._toType('bool', node, 1);
      }
    };

    // mix-in with type checking for names
    const Check_Names = superclass => class extends superclass {
      // Returns node.type(name), if undefined node.number.
      name (node) {
        node.type = this._type(node.lineno, node[1]);
        return node;
      }
    
      // Utility: returns type of name, defaulted to number.
      _type (lineno, name) {
        const symbol = this._alloc(name);
        if (!('type' in symbol)) {
          this._error(lineno, name + ': undefined');
          symbol.type = 'number';
        }
        return symbol.type;
      }
    
      // [ 'assign' name value ] casts value to type of name.
      assign (node) {
        return this._toType(this._type(node.lineno, node[1]), node, 2);
      }
    };

    // mix-in with type checking for 'block' and 'dcl'
    const Check_Dcl = superclass => class extends superclass {
      // [ 'block' dcl ... other ... ] replaces each node by the result of the visit, returns node.
      block (node) {
        node.slice(1).forEach((item, n) => node[n + 1] = this.visit(item));
        return node;
      }
    
      // [ 'dcl' type Name ...] allocates and types each Name, returns node.
      dcl (node) {
        node.slice(2).forEach(name => {
          if (this.symbols.has(name))
            this._error(node.lineno, name + ': duplicate');
          this._alloc(name).type = node[1];
        });
        return node;
      }
    };

    // builder and checker for a typed little language
    return Eleven.Main(Build_Dcl(
                         Eleven.Build_Stmts(
                           Eleven.Build_Names(
                             Eleven.Build_Cast(
                               Eleven.Build_String(
                                 Eleven.Build_Bool(
                                   Eleven.Build_Cmps(
                                     Eleven.Build_Number(Eleven.Build)))))))),
                       Check_Dcl(
                         Check_Stmts(
                           Check_Names(
                             Eleven.Symbols(
                               Eleven.Check_Cast(
                                 Eleven.Check_String(
                                   Eleven.Check_Bool(
                                     Eleven.Check_Cmps(
                                       Eleven.Check_Number(Eleven.Check))))))))));
  }) ()
