%% output
  Check and interpret a typed little language [see 11/08].
  Euclid's Algorithm, see [7/02].
  
  Remove the 'main' rule to see the original tree.
  Add '/./' to the call to 'Main()' to trace checking,
  dump the checked tree, and trace interpretation.

  Default Output:
    Greatest common divisor: 18
%% program
  x = input 'x' '36'; y = input 'y' '54'; string x; number y;
  eq = x = y; bool eq;
  while not eq do
    if (number) x > y then
      x = x - y
    else
      y = y - x 
    fi;
    eq = x = y
  od;
  print 'Greatest common divisor:', x
%% grammar
  %left     'or';
  %left     'and';
  %nonassoc '=' '<>' '>' '>=' '<' '<=';
  %left     '+' '-';
  %left     '*' '/';
  %right    '**';
  %right    Number;

  run:      main;
  main:     block;
  block:    item [{ ';' item }];
  item:     dcl | stmt;
  dcl:      type Name [{ ',' Name }];
    
  stmts:    stmt [{ ';' stmt }];
  stmt:     assign | print | loop | select;
  assign:   Name '=' expr;
  print:    'print' expr [{ ',' expr }];
  loop:     'while' expr 'do' stmts 'od';
  select:   'if' expr 'then' stmts [ 'else' stmts ] 'fi';

  expr:     or | and | eq | ne | gt | ge | lt | le
            | add | subtract | multiply | divide | power
            | minus | not | len | cast | input
            | number | name | bool | string | '(' expr ')';

  or:       expr 'or' expr;
  and:      expr 'and' expr;

  eq:       expr '=' expr;
  ne:       expr '<>' expr;
  gt:       expr '>' expr;
  ge:       expr '>=' expr;
  lt:       expr '<' expr;
  le:       expr '<=' expr;   

  add:      expr '+' expr;
  subtract: expr '-' expr;
  multiply: expr '*' expr;
  divide:   expr '/' expr;
  power:    expr '**' expr;

  minus:    '-' expr %prec Number;
  not:      'not' expr %prec Number;
  len:      'len' expr %prec Number;
  cast:     '(' type ')' expr %prec Number;
  type:     'bool' | 'number' | 'string';

  input:    'input' [ String String ];  
  number:   Number;
  name:     Name;
  bool:     'true' | 'false';
  string:   String;
%% tokens
  { 
    Number: /0|[1-9][0-9]*/, 
    Name:   /[a-z]+/,
    String: /'(?:\\['\\\n]|[^'\\\n])*'/
  }
%% actions
  (() => {  // define and immediately use an anonymous function
    // mix-in for blocks and declarations
    const Eval_Dcl = superclass => class extends superclass {
      // [ 'block' dcl ... other ... ] visits all.
      block (node) {  node.slice(1).forEach(item => this.visit(item)); }
    
      // [ 'dcl' type name ...] defines as false, 0, or empty strings.
      dcl (node) {
        node.slice(2).forEach(name => {
          if (this.symbols.has(name) && 'value' in this.symbols.get(name))
            this._error(node.lineno, name + ': duplicate');
          switch (node[1]) {
          case 'bool':    this._alloc(name).value = false; break;
          case 'number':  this._alloc(name).value = 0; break;
          case 'string':  this._alloc(name).value = ''; break;
          default:        this._error(node.lineno, node[1] + ": not in 'dcl'");
          }
        });
      }
    };

    // builder, checker, and interpreter for a typed little language
    return Eleven.Main(Eleven.Build_Dcl(
                         Eleven.Build_Stmts(
                           Eleven.Build_Names(
                             Eleven.Build_Cast(
                               Eleven.Build_String(
                                 Eleven.Build_Bool(
                                   Eleven.Build_Cmps(
                                     Eleven.Build_Number(Eleven.Build)))))))),
                       Eleven.Check_Dcl(
                         Eleven.Check_Stmts(
                           Eleven.Check_Names(
                             Eleven.Symbols(
                               Eleven.Check_Cast(
                                 Eleven.Check_String(
                                   Eleven.Check_Bool(
                                     Eleven.Check_Cmps(
                                       Eleven.Check_Number(Eleven.Check))))))))),
                       Eval_Dcl(
                         Eleven.Eval_Stmts(
                           Eleven.Eval_Names(
                             Eleven.Symbols(
                               Eleven.Eval_Cast(
                                 Eleven.Eval_String(
                                   Eleven.Eval_Bool(
                                     Eleven.Eval_Cmps(
                                       Eleven.Eval_Number(Eleven.Visit))))))))));
  }) ()
