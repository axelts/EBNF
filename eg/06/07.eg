%% output
  Grammar for a comma-separated list of arithmetic expressions with variables.
  Compile an arithmetic expression into a JavaScript function.
  
  Expected output: 3 -6 5
%% grammar
  list: sum [{ ',' sum }];
  sum: 'let' Name '=' sum | product [{ add | subtract }];
  add: '+' product;
  subtract: '-' product;
  product: signed [{ multiply | divide }];
  multiply: '*' signed;
  divide: '/' signed;
  signed: [ '-' ] term;
  term: input | number | name | '(' sum ')';
  input: 'input' [ Number ];
  number: Number;
  name: Name;
%% tokens
  { Number: /0|[1-9][0-9]*/, Name: /[a-z]+/ }
%% program
  let x = input 3, (x + 1) / (y - 2) * 3,
  y + ((let y = 2) + 1) / (x - 2) + y
%% actions
  class Functions07 extends Six.Functions06 {
    /** `list: sum [{ ',' sum }];` returns executable  */
    list (sum, many) {
      const list = [ sum ].
        concat(many ? many[0].map(seq => seq[1]) : [ ]);
      return () => {
        const memory = { };
        puts(... list.map(fct => fct(memory)));
      }
    }
  
    /** `sum: 'let' Name '=' sum | product [{ add | subtract }];` */
    //              [1]      [3]   [0]     [1]
    sum (... arg) {
      if (arg.length == 4)
        return memory => memory[arg[1]] = arg[3](memory);
      else
        return this.product(arg[0], arg[1]);
    }
  
    /** `add: '+' product;` returns fct for composition */
    add (_, right) {
      return left => memory => left(memory) + right(memory);
    }
  
    /** `subtract: '-' product;` returns fct for composition */
    subtract (_, right) {
      return left => memory => left(memory) - right(memory);
    }
  
    /** `product: signed [{ multiply | divide }];` returns fct */
    product (signed, many) {
      const c = (a, b) => b(a);  // function composition
      return (many ? many[0] : []).
        reduce((product, list) => c(product, list[0]), signed);
    }
  
    /** `multiply: '*' signed;` returns fct for composition */
    multiply (_, right) {
      return left => memory => left(memory) * right(memory);
    }
  
    /** `divide: '/' signed;` returns fct for composition */
    divide (_, right) {
      return left => memory => left(memory) / right(memory);
    }
  
    /** `signed: [ '-' ] term;` returns fct */
    signed (minus, term) {
      return minus ? memory => - term(memory) : term;
    }
  
    // term: input | number | name | '(' sum ')';
    // input: 'input' [ Number ];
    // number: Number;
    // name: Name;
  }
