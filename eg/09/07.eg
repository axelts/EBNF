%% output
  Extending the EBNF Grammar's Grammar.
  Hidden, non-start rule.
%% grammar
  grammar: { rule };
  rule:    Token ':' alt ';';
  alt:     seq [{ '|' seq }];
  seq:     { lit | ref | opt | some | parens };
  lit:     Lit;
  ref:     Token;
  opt:     '[' alt ']';
  some:    '{' alt '}';
  parens:  '(' alt ')';
%% tokens
  EBNF.Grammar.terminals
%% program
  sum: Number [{ ( '+' | '-' ) Number }];
%% actions
  class Actions extends EBNF.Actions {
    #hidden = [];
    
    // parens: '(' alt ')';
    parens (lp, alt, rp) {   // returns reference to auxiliary rule
      const uniq = this.g.nt();              // unique non-terminal
      this.g.rule(uniq, ... alt.seqs);                // uniq: alt;
      this.#hidden.push(this.g.rules.pop()); // can't be start rule
      return uniq;
    }

    // grammar: { rule };
    grammar (some) {
      this.g.rules.push(... this.#hidden);   // append hidden rules
      this.g.check();                          // check new grammar
      puts(this.g.toString());               // display new grammar
        
      // executable uses new grammar to parse a sum
      return () => this.g.parser().parse('1 + 2 - 3');
    }

    // create new grammar for rules in program area
    constructor () {
      super(new EBNF.Grammar({ Number: /[0-9]+/ }));
      this.g.config.log = puts;               // report to output area
    }
    
    seq (some) { return super.seq(some, null); }
  }
