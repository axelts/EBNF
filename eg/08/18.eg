%% output
  Compile nested first-order functions into stack machine code.
  Local variables, blocks. Declare before use. Dynamic memory management.
      
  Currying pattern.
  
  Output:  3 7 -3
%% program
  type f  (number): number,
       f2 (number, number): number,
       f3 (number, number, number): number,
       f4 (number, number, number, number): number,
       curry  (f2): ff,   ff (number): f,
       curry3 (f3): fff,  fff (number): ff,
       curry4 (f4): ffff, ffff (number): fff;

  function curry (body) begin
    function ff (a) begin
      function f (b) begin f = body(a, b) end;
      ff = f
    end;
    curry = ff 
  end;

  function curry3 (body) begin
    function fff (a) begin
      function ff (b) begin
        function f (c) begin f = body(a, b, c) end;
        ff = f
      end;
      fff = ff 
    end;
    curry3 = fff
  end;
 
  function curry4 (body) begin
    function ffff (a) begin
      function fff (b) begin
        function ff (c) begin
          function f (d) begin f = body(a, b, c, d) end;
          ff = f
        end;
        fff = ff 
      end;
      ffff = fff
    end;
    curry4 = ffff
  end;

  function main () begin
    function f2 (a, b) begin return a + b end;
    function f3 (a, b, c) begin return a + b * c end;
    function f4 (a, b, c, d) begin return (a + b) * (c - d) end;
    print 1 + 2,             f2(1, 2),       curry (f2) (1)(2);
    print 1 + 2 * 3,         f3(1, 2, 3),    curry3(f3) (1)(2)(3);
    print (1 + 2) * (3 - 4), f4(1, 2, 3, 4), curry4(f4) (1)(2)(3)(4)
  end;
%% grammar
  prog: [ typedcls ] [ vars ] funs;
  typedcls: { 'type' typedcl [{ ',' typedcl }] ';' };
  typedcl: Name '(' [ types ] ')' [ ':' typename ];
  types: typename [{ ',' typename }];
  typename: Name | 'number';
  vars: 'var' varname [{ ',' varname }] ';';
  varname: Name [ ':' type ];
  type: Name | 'number';
  funs: { fun };
  fun: head parms [ block ] ';';
  head: 'function' Name;
  parms: '(' [ names ] ')' [ ':' Name ];
  names: Name [{ ',' Name }];
  block: begin body 'end';
  begin: 'begin';
  body: [ vars ] [ funs ] stmts;
  stmts: stmt [{ ';' stmt }];
  stmt: assign | print | return | block | loop | select;
  assign: symbol action;
  action: store | call;
  store: '=' sum;
  call: { args };
  args: '(' [ sums ] ')';
  print: 'print' sums;
  sums: sum [{ ',' sum }];
  return: 'return' [ sum ];
  loop: While cmp Do body 'od';
  While: 'while';
  Do: 'do';
  select: 'if' cmp then [ else ] 'fi';
  then: Then [ body ];
  else: Else body;
  Then: 'then';
  Else: 'else';
  cmp: sum rel;
  rel: eq | ne | gt | ge | lt | le;
  eq: '=' sum;
  ne: '<>' sum;
  gt: '>' sum;
  ge: '>=' sum;
  lt: '<' sum;
  le: '<=' sum;   
  sum: product [{ add | subtract }];
  add: '+' product;
  subtract: '-' product;
  product: signed [{ multiply | divide }];
  multiply: '*' signed;
  divide: '/' signed;
  signed: [ '-' ] term;
  term: input | number | name | '(' sum ')';
  input: 'input' [ Number ];
  number: Number;
  name: symbol [{ args }];
  symbol: Name;
%% tokens
  { Number: /0|[1-9][0-9]*/, Name: /[a-zA-Z][a-zA-Z0-9]*/ }
%% actions
  Eight.First14(Eight.Global01(Seven.Nest13(Seven.Blocks09)))
