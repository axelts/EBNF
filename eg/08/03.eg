%% output
  Compile global first-order functions into stack machine code.
  Local variables, blocks. Declare before use.
  
  Mutually recursive functions, two versions of Euclid's algorithm [see 7/08].

  Expected output:
    10
    1 18
    18
    20 36 54
    2 18
    1 36
    30
    0
%% program
  type Main ();
  type Euclid (number, number): number;
  
  var x, y, depth, euclida: Euclid, euclidb: Euclid;
  
  function b (a, b): Euclid;

  function a (x, y): Euclid begin var c, d;
    c = x - y; d = y - x;
    if c <> 0 then
      if x > y then a = euclidb(c, y)
      else a = b(x, d)
      fi
    else return x
    fi
  end;
  
  function b (x, y): Euclid begin
    depth = depth + 1;
    if x = y then b = x
    else
      if x > y then x = x - y
      else y = y - x
      fi;
      b = euclida(x, y)
    fi;
    print depth, x;
    depth = depth - 1
  end;

  function main (): Main begin
    euclida = a; euclidb = b;
    print 10; x = input 36; y = input 54; print euclida(x, y);
    print 20, x, y; euclidb(x, y);
    print 30; return; print 999
  end;
%% grammar
  prog: [ typedcls ] [ vars ] funs;
  typedcls: { 'type' typedcl [{ ',' typedcl }] ';' };
  typedcl: Name '(' [ types ] ')' [ ':' typename ];
  types: typename [{ ',' typename }];
  typename: Name | 'number';
  vars: 'var' varname [{ ',' varname }] ';';
  varname: Name [ ':' type ];
  type: Name | 'number';
  funs: { fun };
  fun: head parms [ block ] ';';
  head: 'function' Name;
  parms: '(' [ names ] ')' [ ':' Name ];
  names: Name [{ ',' Name }];
  block: begin [ vars ] stmts 'end';
  begin: 'begin';
  stmts: stmt [{ ';' stmt }];
  stmt: assign | print | return | block | loop | select;
  assign: symbol action;
  action: store | call;
  store: '=' sum;
  call: { args };
  args: '(' [ sums ] ')';
  print: 'print' sums;
  sums: sum [{ ',' sum }];
  return: 'return' [ sum ];
  loop: While cmp Do [ vars ] stmts 'od';
  While: 'while';
  Do: 'do';
  select: 'if' cmp then [ else ] 'fi';
  then: Then [ [ vars ] stmts ];
  else: Else [ vars ] stmts;
  Then: 'then';
  Else: 'else';
  cmp: sum rel;
  rel: eq | ne | gt | ge | lt | le;
  eq: '=' sum;
  ne: '<>' sum;
  gt: '>' sum;
  ge: '>=' sum;
  lt: '<' sum;
  le: '<=' sum;   
  sum: product [{ add | subtract }];
  add: '+' product;
  subtract: '-' product;
  product: signed [{ multiply | divide }];
  multiply: '*' signed;
  divide: '/' signed;
  signed: [ '-' ] term;
  term: input | number | name | '(' sum ')';
  input: 'input' [ Number ];
  number: Number;
  name: symbol [{ args }];
  symbol: Name;
%% tokens
  { Number: /0|[1-9][0-9]*/, Name: /[A-Za-z]+/ }
%% actions
  Eight.Global01(Seven.Blocks09)
